<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>image - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.23.0";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package image
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "image"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package image implements a basic 2-D image library.
<p>The fundamental interface is called <a href="#Image">Image</a>. An <a href="#Image">Image</a> contains colors, which
are described in the image/color package.
<p>Values of the <a href="#Image">Image</a> interface are created either by calling functions such
as <a href="#NewRGBA">NewRGBA</a> and <a href="#NewPaletted">NewPaletted</a>, or by calling <a href="#Decode">Decode</a> on an <a href="/io#Reader">io.Reader</a> containing
image data in a format such as GIF, JPEG or PNG. Decoding any particular
image format requires the prior registration of a decoder function.
Registration is typically automatic as a side effect of initializing that
format&apos;s package so that, to decode a PNG image, it suffices to have
<pre>import _ &quot;image/png&quot;
</pre>
<p>in a program&apos;s main package. The _ means to import a package purely for its
initialization side effects.
<p>See &quot;The Go image package&quot; for more details:
<a href="https://golang.org/doc/articles/image_package.html">https://golang.org/doc/articles/image_package.html</a>
<h3 id="hdr-Security_Considerations">Security Considerations</h3>
<p>The image package can be used to parse arbitrarily large images, which can
cause resource exhaustion on machines which do not have enough memory to
store them. When operating on arbitrary images, <a href="#DecodeConfig">DecodeConfig</a> should be called
before <a href="#Decode">Decode</a>, so that the program can decide whether the image, as defined
in the returned header, can be safely decoded with the available resources. A
call to <a href="#Decode">Decode</a> which produces an extremely large image, as defined in the
header returned by <a href="#DecodeConfig">DecodeConfig</a>, is not considered a security issue,
regardless of whether the image is itself malformed or not. A call to
<a href="#DecodeConfig">DecodeConfig</a> which returns a header which does not match the image returned
by <a href="#Decode">Decode</a> may be considered a security issue, and should be reported per the
[Go Security Policy](<a href="https://go.dev/security/policy">https://go.dev/security/policy</a>).

				<div id="example_" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Decode the JPEG data. If reading from file, create a reader with</span>
<span class="comment">//</span>
<span class="comment">// reader, err := os.Open(&#34;testdata/video-001.q50.420.jpeg&#34;)</span>
<span class="comment">// if err != nil {</span>
<span class="comment">//     log.Fatal(err)</span>
<span class="comment">// }</span>
<span class="comment">// defer reader.Close()</span>
reader := base64.NewDecoder(base64.StdEncoding, strings.NewReader(data))
m, _, err := image.Decode(reader)
if err != nil {
    log.Fatal(err)
}
bounds := m.Bounds()

<span class="comment">// Calculate a 16-bin histogram for m&#39;s red, green, blue and alpha components.</span>
<span class="comment">//</span>
<span class="comment">// An image&#39;s bounds do not necessarily start at (0, 0), so the two loops start</span>
<span class="comment">// at bounds.Min.Y and bounds.Min.X. Looping over Y first and X second is more</span>
<span class="comment">// likely to result in better memory access patterns than X first and Y second.</span>
var histogram [16][4]int
for y := bounds.Min.Y; y &lt; bounds.Max.Y; y++ {
    for x := bounds.Min.X; x &lt; bounds.Max.X; x++ {
        r, g, b, a := m.At(x, y).RGBA()
        <span class="comment">// A color&#39;s RGBA method returns values in the range [0, 65535].</span>
        <span class="comment">// Shifting by 12 reduces this to the range [0, 15].</span>
        histogram[r&gt;&gt;12][0]++
        histogram[g&gt;&gt;12][1]++
        histogram[b&gt;&gt;12][2]++
        histogram[a&gt;&gt;12][3]++
    }
}

<span class="comment">// Print the results.</span>
fmt.Printf(&#34;%-14s %6s %6s %6s %6s\n&#34;, &#34;bin&#34;, &#34;red&#34;, &#34;green&#34;, &#34;blue&#34;, &#34;alpha&#34;)
for i, x := range histogram {
    fmt.Printf(&#34;0x%04x-0x%04x: %6d %6d %6d %6d\n&#34;, i&lt;&lt;12, (i+1)&lt;&lt;12-1, x[0], x[1], x[2], x[3])
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">bin               red  green   blue  alpha
0x0000-0x0fff:    364    790   7242      0
0x1000-0x1fff:    645   2967   1039      0
0x2000-0x2fff:   1072   2299    979      0
0x3000-0x3fff:    820   2266    980      0
0x4000-0x4fff:    537   1305    541      0
0x5000-0x5fff:    319    962    261      0
0x6000-0x6fff:    322    375    177      0
0x7000-0x7fff:    601    279    214      0
0x8000-0x8fff:   3478    227    273      0
0x9000-0x9fff:   2260    234    329      0
0xa000-0xafff:    921    282    373      0
0xb000-0xbfff:    321    335    397      0
0xc000-0xcfff:    229    388    298      0
0xd000-0xdfff:    260    414    277      0
0xe000-0xefff:    516    428    298      0
0xf000-0xffff:   2785   1899   1772  15450
</pre>
			
		
	</div>
</div>
<div id="example__decodeConfig" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (DecodeConfig)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (DecodeConfig)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
reader := base64.NewDecoder(base64.StdEncoding, strings.NewReader(data))
config, format, err := image.DecodeConfig(reader)
if err != nil {
    log.Fatal(err)
}
fmt.Println(&#34;Width:&#34;, config.Width, &#34;Height:&#34;, config.Height, &#34;Format:&#34;, format)
</pre>
			
		
	</div>
</div>

			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#RegisterFormat">func RegisterFormat(name, magic string, decode func(io.Reader) (Image, error), decodeConfig func(io.Reader) (Config, error))</a></dd>
			
			
				
				<dd><a href="#Alpha">type Alpha</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAlpha">func NewAlpha(r Rectangle) *Alpha</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha.AlphaAt">func (p *Alpha) AlphaAt(x, y int) color.Alpha</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha.At">func (p *Alpha) At(x, y int) color.Color</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha.Bounds">func (p *Alpha) Bounds() Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha.ColorModel">func (p *Alpha) ColorModel() color.Model</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha.Opaque">func (p *Alpha) Opaque() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha.PixOffset">func (p *Alpha) PixOffset(x, y int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha.RGBA64At">func (p *Alpha) RGBA64At(x, y int) color.RGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha.Set">func (p *Alpha) Set(x, y int, c color.Color)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha.SetAlpha">func (p *Alpha) SetAlpha(x, y int, c color.Alpha)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha.SetRGBA64">func (p *Alpha) SetRGBA64(x, y int, c color.RGBA64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha.SubImage">func (p *Alpha) SubImage(r Rectangle) Image</a></dd>
				
			
				
				<dd><a href="#Alpha16">type Alpha16</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAlpha16">func NewAlpha16(r Rectangle) *Alpha16</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha16.Alpha16At">func (p *Alpha16) Alpha16At(x, y int) color.Alpha16</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha16.At">func (p *Alpha16) At(x, y int) color.Color</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha16.Bounds">func (p *Alpha16) Bounds() Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha16.ColorModel">func (p *Alpha16) ColorModel() color.Model</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha16.Opaque">func (p *Alpha16) Opaque() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha16.PixOffset">func (p *Alpha16) PixOffset(x, y int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha16.RGBA64At">func (p *Alpha16) RGBA64At(x, y int) color.RGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha16.Set">func (p *Alpha16) Set(x, y int, c color.Color)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha16.SetAlpha16">func (p *Alpha16) SetAlpha16(x, y int, c color.Alpha16)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha16.SetRGBA64">func (p *Alpha16) SetRGBA64(x, y int, c color.RGBA64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alpha16.SubImage">func (p *Alpha16) SubImage(r Rectangle) Image</a></dd>
				
			
				
				<dd><a href="#CMYK">type CMYK</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCMYK">func NewCMYK(r Rectangle) *CMYK</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CMYK.At">func (p *CMYK) At(x, y int) color.Color</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CMYK.Bounds">func (p *CMYK) Bounds() Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CMYK.CMYKAt">func (p *CMYK) CMYKAt(x, y int) color.CMYK</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CMYK.ColorModel">func (p *CMYK) ColorModel() color.Model</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CMYK.Opaque">func (p *CMYK) Opaque() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CMYK.PixOffset">func (p *CMYK) PixOffset(x, y int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CMYK.RGBA64At">func (p *CMYK) RGBA64At(x, y int) color.RGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CMYK.Set">func (p *CMYK) Set(x, y int, c color.Color)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CMYK.SetCMYK">func (p *CMYK) SetCMYK(x, y int, c color.CMYK)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CMYK.SetRGBA64">func (p *CMYK) SetRGBA64(x, y int, c color.RGBA64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CMYK.SubImage">func (p *CMYK) SubImage(r Rectangle) Image</a></dd>
				
			
				
				<dd><a href="#Config">type Config</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DecodeConfig">func DecodeConfig(r io.Reader) (Config, string, error)</a></dd>
				
				
			
				
				<dd><a href="#Gray">type Gray</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGray">func NewGray(r Rectangle) *Gray</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray.At">func (p *Gray) At(x, y int) color.Color</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray.Bounds">func (p *Gray) Bounds() Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray.ColorModel">func (p *Gray) ColorModel() color.Model</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray.GrayAt">func (p *Gray) GrayAt(x, y int) color.Gray</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray.Opaque">func (p *Gray) Opaque() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray.PixOffset">func (p *Gray) PixOffset(x, y int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray.RGBA64At">func (p *Gray) RGBA64At(x, y int) color.RGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray.Set">func (p *Gray) Set(x, y int, c color.Color)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray.SetGray">func (p *Gray) SetGray(x, y int, c color.Gray)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray.SetRGBA64">func (p *Gray) SetRGBA64(x, y int, c color.RGBA64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray.SubImage">func (p *Gray) SubImage(r Rectangle) Image</a></dd>
				
			
				
				<dd><a href="#Gray16">type Gray16</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewGray16">func NewGray16(r Rectangle) *Gray16</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray16.At">func (p *Gray16) At(x, y int) color.Color</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray16.Bounds">func (p *Gray16) Bounds() Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray16.ColorModel">func (p *Gray16) ColorModel() color.Model</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray16.Gray16At">func (p *Gray16) Gray16At(x, y int) color.Gray16</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray16.Opaque">func (p *Gray16) Opaque() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray16.PixOffset">func (p *Gray16) PixOffset(x, y int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray16.RGBA64At">func (p *Gray16) RGBA64At(x, y int) color.RGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray16.Set">func (p *Gray16) Set(x, y int, c color.Color)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray16.SetGray16">func (p *Gray16) SetGray16(x, y int, c color.Gray16)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray16.SetRGBA64">func (p *Gray16) SetRGBA64(x, y int, c color.RGBA64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Gray16.SubImage">func (p *Gray16) SubImage(r Rectangle) Image</a></dd>
				
			
				
				<dd><a href="#Image">type Image</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Decode">func Decode(r io.Reader) (Image, string, error)</a></dd>
				
				
			
				
				<dd><a href="#NRGBA">type NRGBA</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewNRGBA">func NewNRGBA(r Rectangle) *NRGBA</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA.At">func (p *NRGBA) At(x, y int) color.Color</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA.Bounds">func (p *NRGBA) Bounds() Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA.ColorModel">func (p *NRGBA) ColorModel() color.Model</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA.NRGBAAt">func (p *NRGBA) NRGBAAt(x, y int) color.NRGBA</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA.Opaque">func (p *NRGBA) Opaque() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA.PixOffset">func (p *NRGBA) PixOffset(x, y int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA.RGBA64At">func (p *NRGBA) RGBA64At(x, y int) color.RGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA.Set">func (p *NRGBA) Set(x, y int, c color.Color)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA.SetNRGBA">func (p *NRGBA) SetNRGBA(x, y int, c color.NRGBA)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA.SetRGBA64">func (p *NRGBA) SetRGBA64(x, y int, c color.RGBA64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA.SubImage">func (p *NRGBA) SubImage(r Rectangle) Image</a></dd>
				
			
				
				<dd><a href="#NRGBA64">type NRGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewNRGBA64">func NewNRGBA64(r Rectangle) *NRGBA64</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA64.At">func (p *NRGBA64) At(x, y int) color.Color</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA64.Bounds">func (p *NRGBA64) Bounds() Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA64.ColorModel">func (p *NRGBA64) ColorModel() color.Model</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA64.NRGBA64At">func (p *NRGBA64) NRGBA64At(x, y int) color.NRGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA64.Opaque">func (p *NRGBA64) Opaque() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA64.PixOffset">func (p *NRGBA64) PixOffset(x, y int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA64.RGBA64At">func (p *NRGBA64) RGBA64At(x, y int) color.RGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA64.Set">func (p *NRGBA64) Set(x, y int, c color.Color)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA64.SetNRGBA64">func (p *NRGBA64) SetNRGBA64(x, y int, c color.NRGBA64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA64.SetRGBA64">func (p *NRGBA64) SetRGBA64(x, y int, c color.RGBA64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NRGBA64.SubImage">func (p *NRGBA64) SubImage(r Rectangle) Image</a></dd>
				
			
				
				<dd><a href="#NYCbCrA">type NYCbCrA</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewNYCbCrA">func NewNYCbCrA(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *NYCbCrA</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NYCbCrA.AOffset">func (p *NYCbCrA) AOffset(x, y int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NYCbCrA.At">func (p *NYCbCrA) At(x, y int) color.Color</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NYCbCrA.ColorModel">func (p *NYCbCrA) ColorModel() color.Model</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NYCbCrA.NYCbCrAAt">func (p *NYCbCrA) NYCbCrAAt(x, y int) color.NYCbCrA</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NYCbCrA.Opaque">func (p *NYCbCrA) Opaque() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NYCbCrA.RGBA64At">func (p *NYCbCrA) RGBA64At(x, y int) color.RGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NYCbCrA.SubImage">func (p *NYCbCrA) SubImage(r Rectangle) Image</a></dd>
				
			
				
				<dd><a href="#Paletted">type Paletted</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewPaletted">func NewPaletted(r Rectangle, p color.Palette) *Paletted</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Paletted.At">func (p *Paletted) At(x, y int) color.Color</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Paletted.Bounds">func (p *Paletted) Bounds() Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Paletted.ColorIndexAt">func (p *Paletted) ColorIndexAt(x, y int) uint8</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Paletted.ColorModel">func (p *Paletted) ColorModel() color.Model</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Paletted.Opaque">func (p *Paletted) Opaque() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Paletted.PixOffset">func (p *Paletted) PixOffset(x, y int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Paletted.RGBA64At">func (p *Paletted) RGBA64At(x, y int) color.RGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Paletted.Set">func (p *Paletted) Set(x, y int, c color.Color)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Paletted.SetColorIndex">func (p *Paletted) SetColorIndex(x, y int, index uint8)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Paletted.SetRGBA64">func (p *Paletted) SetRGBA64(x, y int, c color.RGBA64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Paletted.SubImage">func (p *Paletted) SubImage(r Rectangle) Image</a></dd>
				
			
				
				<dd><a href="#PalettedImage">type PalettedImage</a></dd>
				
				
			
				
				<dd><a href="#Point">type Point</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Pt">func Pt(X, Y int) Point</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Point.Add">func (p Point) Add(q Point) Point</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Point.Div">func (p Point) Div(k int) Point</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Point.Eq">func (p Point) Eq(q Point) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Point.In">func (p Point) In(r Rectangle) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Point.Mod">func (p Point) Mod(r Rectangle) Point</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Point.Mul">func (p Point) Mul(k int) Point</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Point.String">func (p Point) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Point.Sub">func (p Point) Sub(q Point) Point</a></dd>
				
			
				
				<dd><a href="#RGBA">type RGBA</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRGBA">func NewRGBA(r Rectangle) *RGBA</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA.At">func (p *RGBA) At(x, y int) color.Color</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA.Bounds">func (p *RGBA) Bounds() Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA.ColorModel">func (p *RGBA) ColorModel() color.Model</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA.Opaque">func (p *RGBA) Opaque() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA.PixOffset">func (p *RGBA) PixOffset(x, y int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA.RGBA64At">func (p *RGBA) RGBA64At(x, y int) color.RGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA.RGBAAt">func (p *RGBA) RGBAAt(x, y int) color.RGBA</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA.Set">func (p *RGBA) Set(x, y int, c color.Color)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA.SetRGBA">func (p *RGBA) SetRGBA(x, y int, c color.RGBA)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA.SetRGBA64">func (p *RGBA) SetRGBA64(x, y int, c color.RGBA64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA.SubImage">func (p *RGBA) SubImage(r Rectangle) Image</a></dd>
				
			
				
				<dd><a href="#RGBA64">type RGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRGBA64">func NewRGBA64(r Rectangle) *RGBA64</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA64.At">func (p *RGBA64) At(x, y int) color.Color</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA64.Bounds">func (p *RGBA64) Bounds() Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA64.ColorModel">func (p *RGBA64) ColorModel() color.Model</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA64.Opaque">func (p *RGBA64) Opaque() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA64.PixOffset">func (p *RGBA64) PixOffset(x, y int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA64.RGBA64At">func (p *RGBA64) RGBA64At(x, y int) color.RGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA64.Set">func (p *RGBA64) Set(x, y int, c color.Color)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA64.SetRGBA64">func (p *RGBA64) SetRGBA64(x, y int, c color.RGBA64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RGBA64.SubImage">func (p *RGBA64) SubImage(r Rectangle) Image</a></dd>
				
			
				
				<dd><a href="#RGBA64Image">type RGBA64Image</a></dd>
				
				
			
				
				<dd><a href="#Rectangle">type Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rect">func Rect(x0, y0, x1, y1 int) Rectangle</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.Add">func (r Rectangle) Add(p Point) Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.At">func (r Rectangle) At(x, y int) color.Color</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.Bounds">func (r Rectangle) Bounds() Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.Canon">func (r Rectangle) Canon() Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.ColorModel">func (r Rectangle) ColorModel() color.Model</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.Dx">func (r Rectangle) Dx() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.Dy">func (r Rectangle) Dy() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.Empty">func (r Rectangle) Empty() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.Eq">func (r Rectangle) Eq(s Rectangle) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.In">func (r Rectangle) In(s Rectangle) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.Inset">func (r Rectangle) Inset(n int) Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.Intersect">func (r Rectangle) Intersect(s Rectangle) Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.Overlaps">func (r Rectangle) Overlaps(s Rectangle) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.RGBA64At">func (r Rectangle) RGBA64At(x, y int) color.RGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.Size">func (r Rectangle) Size() Point</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.String">func (r Rectangle) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.Sub">func (r Rectangle) Sub(p Point) Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rectangle.Union">func (r Rectangle) Union(s Rectangle) Rectangle</a></dd>
				
			
				
				<dd><a href="#Uniform">type Uniform</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewUniform">func NewUniform(c color.Color) *Uniform</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Uniform.At">func (c *Uniform) At(x, y int) color.Color</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uniform.Bounds">func (c *Uniform) Bounds() Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uniform.ColorModel">func (c *Uniform) ColorModel() color.Model</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uniform.Convert">func (c *Uniform) Convert(color.Color) color.Color</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uniform.Opaque">func (c *Uniform) Opaque() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uniform.RGBA">func (c *Uniform) RGBA() (r, g, b, a uint32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uniform.RGBA64At">func (c *Uniform) RGBA64At(x, y int) color.RGBA64</a></dd>
				
			
				
				<dd><a href="#YCbCr">type YCbCr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewYCbCr">func NewYCbCr(r Rectangle, subsampleRatio YCbCrSubsampleRatio) *YCbCr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#YCbCr.At">func (p *YCbCr) At(x, y int) color.Color</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#YCbCr.Bounds">func (p *YCbCr) Bounds() Rectangle</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#YCbCr.COffset">func (p *YCbCr) COffset(x, y int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#YCbCr.ColorModel">func (p *YCbCr) ColorModel() color.Model</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#YCbCr.Opaque">func (p *YCbCr) Opaque() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#YCbCr.RGBA64At">func (p *YCbCr) RGBA64At(x, y int) color.RGBA64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#YCbCr.SubImage">func (p *YCbCr) SubImage(r Rectangle) Image</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#YCbCr.YCbCrAt">func (p *YCbCr) YCbCrAt(x, y int) color.YCbCr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#YCbCr.YOffset">func (p *YCbCr) YOffset(x, y int) int</a></dd>
				
			
				
				<dd><a href="#YCbCrSubsampleRatio">type YCbCrSubsampleRatio</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#YCbCrSubsampleRatio.String">func (s YCbCrSubsampleRatio) String() string</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="#example_">Package</a></dd>
			
			<dd><a class="exampleLink" href="#example__decodeConfig">Package (DecodeConfig)</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/image/format.go">format.go</a>
			
				<a href="/src/image/geom.go">geom.go</a>
			
				<a href="/src/image/image.go">image.go</a>
			
				<a href="/src/image/names.go">names.go</a>
			
				<a href="/src/image/ycbcr.go">ycbcr.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
			<h2 id="pkg-variables">Variables</h2>
			
				
				<pre>var (
    <span class="comment">// Black is an opaque black uniform image.</span>
    <span id="Black">Black</span> = <a href="#NewUniform">NewUniform</a>(<a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Black">Black</a>)
    <span class="comment">// White is an opaque white uniform image.</span>
    <span id="White">White</span> = <a href="#NewUniform">NewUniform</a>(<a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#White">White</a>)
    <span class="comment">// Transparent is a fully transparent uniform image.</span>
    <span id="Transparent">Transparent</span> = <a href="#NewUniform">NewUniform</a>(<a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Transparent">Transparent</a>)
    <span class="comment">// Opaque is a fully opaque uniform image.</span>
    <span id="Opaque">Opaque</span> = <a href="#NewUniform">NewUniform</a>(<a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Opaque">Opaque</a>)
)</pre>
			
				<p>ErrFormat indicates that decoding encountered an unknown format.

				<pre>var <span id="ErrFormat">ErrFormat</span> = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;image: unknown format&#34;)</pre>
			
		
		
			
			
			<h2 id="RegisterFormat">func <a href="/src/image/format.go?s=1075:1199#L27">RegisterFormat</a>
				<a class="permalink" href="#RegisterFormat">&#xb6;</a>
				
				
			</h2>
			<pre>func RegisterFormat(name, magic <a href="/pkg/builtin/#string">string</a>, decode func(<a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>) (<a href="#Image">Image</a>, <a href="/pkg/builtin/#error">error</a>), decodeConfig func(<a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>) (<a href="#Config">Config</a>, <a href="/pkg/builtin/#error">error</a>))</pre>
			<p>RegisterFormat registers an image format for use by <a href="#Decode">Decode</a>.
Name is the name of the format, like &quot;jpeg&quot; or &quot;png&quot;.
Magic is the magic prefix that identifies the format&apos;s encoding. The magic
string can contain &quot;?&quot; wildcards that each match any one byte.
<a href="#Decode">Decode</a> is the function that decodes the encoded image.
<a href="#DecodeConfig">DecodeConfig</a> is the function that decodes just its configuration.

			
			

		
		
			
			
			<h2 id="Alpha">type <a href="/src/image/image.go?s=18446:18748#L614">Alpha</a>
				<a class="permalink" href="#Alpha">&#xb6;</a>
				
				
			</h2>
			<p>Alpha is an in-memory image whose At method returns <a href="/image/color#Alpha">color.Alpha</a> values.

			<pre>type Alpha struct {
<span id="Alpha.Pix"></span>    <span class="comment">// Pix holds the image&#39;s pixels, as alpha values. The pixel at</span>
    <span class="comment">// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].</span>
    Pix []<a href="/pkg/builtin/#uint8">uint8</a>
<span id="Alpha.Stride"></span>    <span class="comment">// Stride is the Pix stride (in bytes) between vertically adjacent pixels.</span>
    Stride <a href="/pkg/builtin/#int">int</a>
<span id="Alpha.Rect"></span>    <span class="comment">// Rect is the image&#39;s bounds.</span>
    Rect <a href="#Rectangle">Rectangle</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewAlpha">func <a href="/src/image/image.go?s=20902:20935#L713">NewAlpha</a>
					<a class="permalink" href="#NewAlpha">&#xb6;</a>
					
					
				</h3>
				<pre>func NewAlpha(r <a href="#Rectangle">Rectangle</a>) *<a href="#Alpha">Alpha</a></pre>
				<p>NewAlpha returns a new <a href="#Alpha">Alpha</a> image with the given bounds.

				
				
			

			
				
				<h3 id="Alpha.AlphaAt">func (*Alpha) <a href="/src/image/image.go?s=19075:19120#L638">AlphaAt</a>
					<a class="permalink" href="#Alpha.AlphaAt">&#xb6;</a>
					
					<span title="Added in Go 1.4">1.4</span>
				</h3>
				<pre>func (p *<a href="#Alpha">Alpha</a>) AlphaAt(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Alpha">Alpha</a></pre>
				
				
				
				
			
				
				<h3 id="Alpha.At">func (*Alpha) <a href="/src/image/image.go?s=18874:18914#L628">At</a>
					<a class="permalink" href="#Alpha.At">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha">Alpha</a>) At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a></pre>
				
				
				
				
			
				
				<h3 id="Alpha.Bounds">func (*Alpha) <a href="/src/image/image.go?s=18820:18854#L626">Bounds</a>
					<a class="permalink" href="#Alpha.Bounds">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha">Alpha</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
				
				
				
				
			
				
				<h3 id="Alpha.ColorModel">func (*Alpha) <a href="/src/image/image.go?s=18750:18790#L624">ColorModel</a>
					<a class="permalink" href="#Alpha.ColorModel">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha">Alpha</a>) ColorModel() <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a></pre>
				
				
				
				
			
				
				<h3 id="Alpha.Opaque">func (*Alpha) <a href="/src/image/image.go?s=20562:20591#L695">Opaque</a>
					<a class="permalink" href="#Alpha.Opaque">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha">Alpha</a>) Opaque() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Opaque scans the entire image and reports whether it is fully opaque.

				
				
				
			
				
				<h3 id="Alpha.PixOffset">func (*Alpha) <a href="/src/image/image.go?s=19341:19380#L648">PixOffset</a>
					<a class="permalink" href="#Alpha.PixOffset">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha">Alpha</a>) PixOffset(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>PixOffset returns the index of the first element of Pix that corresponds to
the pixel at (x, y).

				
				
				
			
				
				<h3 id="Alpha.RGBA64At">func (*Alpha) <a href="/src/image/image.go?s=18944:18991#L632">RGBA64At</a>
					<a class="permalink" href="#Alpha.RGBA64At">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#Alpha">Alpha</a>) RGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a></pre>
				
				
				
				
			
				
				<h3 id="Alpha.Set">func (*Alpha) <a href="/src/image/image.go?s=19441:19485#L652">Set</a>
					<a class="permalink" href="#Alpha.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha">Alpha</a>) Set(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a>)</pre>
				
				
				
				
			
				
				<h3 id="Alpha.SetAlpha">func (*Alpha) <a href="/src/image/image.go?s=19768:19817#L668">SetAlpha</a>
					<a class="permalink" href="#Alpha.SetAlpha">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha">Alpha</a>) SetAlpha(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Alpha">Alpha</a>)</pre>
				
				
				
				
			
				
				<h3 id="Alpha.SetRGBA64">func (*Alpha) <a href="/src/image/image.go?s=19615:19666#L660">SetRGBA64</a>
					<a class="permalink" href="#Alpha.SetRGBA64">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#Alpha">Alpha</a>) SetRGBA64(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a>)</pre>
				
				
				
				
			
				
				<h3 id="Alpha.SubImage">func (*Alpha) <a href="/src/image/image.go?s=20056:20099#L678">SubImage</a>
					<a class="permalink" href="#Alpha.SubImage">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha">Alpha</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
				<p>SubImage returns an image representing the portion of the image p visible
through r. The returned value shares pixels with the original image.

				
				
				
			
		
			
			
			<h2 id="Alpha16">type <a href="/src/image/image.go?s=21135:21460#L722">Alpha16</a>
				<a class="permalink" href="#Alpha16">&#xb6;</a>
				
				
			</h2>
			<p>Alpha16 is an in-memory image whose At method returns <a href="/image/color#Alpha16">color.Alpha16</a> values.

			<pre>type Alpha16 struct {
<span id="Alpha16.Pix"></span>    <span class="comment">// Pix holds the image&#39;s pixels, as alpha values in big-endian format. The pixel at</span>
    <span class="comment">// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2].</span>
    Pix []<a href="/pkg/builtin/#uint8">uint8</a>
<span id="Alpha16.Stride"></span>    <span class="comment">// Stride is the Pix stride (in bytes) between vertically adjacent pixels.</span>
    Stride <a href="/pkg/builtin/#int">int</a>
<span id="Alpha16.Rect"></span>    <span class="comment">// Rect is the image&#39;s bounds.</span>
    Rect <a href="#Rectangle">Rectangle</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewAlpha16">func <a href="/src/image/image.go?s=23824:23861#L824">NewAlpha16</a>
					<a class="permalink" href="#NewAlpha16">&#xb6;</a>
					
					
				</h3>
				<pre>func NewAlpha16(r <a href="#Rectangle">Rectangle</a>) *<a href="#Alpha16">Alpha16</a></pre>
				<p>NewAlpha16 returns a new <a href="#Alpha16">Alpha16</a> image with the given bounds.

				
				
			

			
				
				<h3 id="Alpha16.Alpha16At">func (*Alpha16) <a href="/src/image/image.go?s=21780:21831#L745">Alpha16At</a>
					<a class="permalink" href="#Alpha16.Alpha16At">&#xb6;</a>
					
					<span title="Added in Go 1.4">1.4</span>
				</h3>
				<pre>func (p *<a href="#Alpha16">Alpha16</a>) Alpha16At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Alpha16">Alpha16</a></pre>
				
				
				
				
			
				
				<h3 id="Alpha16.At">func (*Alpha16) <a href="/src/image/image.go?s=21592:21634#L736">At</a>
					<a class="permalink" href="#Alpha16.At">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha16">Alpha16</a>) At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a></pre>
				
				
				
				
			
				
				<h3 id="Alpha16.Bounds">func (*Alpha16) <a href="/src/image/image.go?s=21536:21572#L734">Bounds</a>
					<a class="permalink" href="#Alpha16.Bounds">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha16">Alpha16</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
				
				
				
				
			
				
				<h3 id="Alpha16.ColorModel">func (*Alpha16) <a href="/src/image/image.go?s=21462:21504#L732">ColorModel</a>
					<a class="permalink" href="#Alpha16.ColorModel">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha16">Alpha16</a>) ColorModel() <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a></pre>
				
				
				
				
			
				
				<h3 id="Alpha16.Opaque">func (*Alpha16) <a href="/src/image/image.go?s=23449:23480#L806">Opaque</a>
					<a class="permalink" href="#Alpha16.Opaque">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha16">Alpha16</a>) Opaque() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Opaque scans the entire image and reports whether it is fully opaque.

				
				
				
			
				
				<h3 id="Alpha16.PixOffset">func (*Alpha16) <a href="/src/image/image.go?s=22090:22131#L755">PixOffset</a>
					<a class="permalink" href="#Alpha16.PixOffset">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha16">Alpha16</a>) PixOffset(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>PixOffset returns the index of the first element of Pix that corresponds to
the pixel at (x, y).

				
				
				
			
				
				<h3 id="Alpha16.RGBA64At">func (*Alpha16) <a href="/src/image/image.go?s=21666:21715#L740">RGBA64At</a>
					<a class="permalink" href="#Alpha16.RGBA64At">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#Alpha16">Alpha16</a>) RGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a></pre>
				
				
				
				
			
				
				<h3 id="Alpha16.Set">func (*Alpha16) <a href="/src/image/image.go?s=22192:22238#L759">Set</a>
					<a class="permalink" href="#Alpha16.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha16">Alpha16</a>) Set(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a>)</pre>
				
				
				
				
			
				
				<h3 id="Alpha16.SetAlpha16">func (*Alpha16) <a href="/src/image/image.go?s=22604:22659#L778">SetAlpha16</a>
					<a class="permalink" href="#Alpha16.SetAlpha16">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha16">Alpha16</a>) SetAlpha16(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Alpha16">Alpha16</a>)</pre>
				
				
				
				
			
				
				<h3 id="Alpha16.SetRGBA64">func (*Alpha16) <a href="/src/image/image.go?s=22422:22475#L769">SetRGBA64</a>
					<a class="permalink" href="#Alpha16.SetRGBA64">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#Alpha16">Alpha16</a>) SetRGBA64(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a>)</pre>
				
				
				
				
			
				
				<h3 id="Alpha16.SubImage">func (*Alpha16) <a href="/src/image/image.go?s=22937:22982#L789">SubImage</a>
					<a class="permalink" href="#Alpha16.SubImage">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Alpha16">Alpha16</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
				<p>SubImage returns an image representing the portion of the image p visible
through r. The returned value shares pixels with the original image.

				
				
				
			
		
			
			
			<h2 id="CMYK">type <a href="/src/image/image.go?s=29427:29732#L1030">CMYK</a>
				<a class="permalink" href="#CMYK">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>CMYK is an in-memory image whose At method returns <a href="/image/color#CMYK">color.CMYK</a> values.

			<pre>type CMYK struct {
<span id="CMYK.Pix"></span>    <span class="comment">// Pix holds the image&#39;s pixels, in C, M, Y, K order. The pixel at</span>
    <span class="comment">// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].</span>
    Pix []<a href="/pkg/builtin/#uint8">uint8</a>
<span id="CMYK.Stride"></span>    <span class="comment">// Stride is the Pix stride (in bytes) between vertically adjacent pixels.</span>
    Stride <a href="/pkg/builtin/#int">int</a>
<span id="CMYK.Rect"></span>    <span class="comment">// Rect is the image&#39;s bounds.</span>
    Rect <a href="#Rectangle">Rectangle</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewCMYK">func <a href="/src/image/image.go?s=32229:32260#L1130">NewCMYK</a>
					<a class="permalink" href="#NewCMYK">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewCMYK(r <a href="#Rectangle">Rectangle</a>) *<a href="#CMYK">CMYK</a></pre>
				<p>NewCMYK returns a new CMYK image with the given bounds.

				
				
			

			
				
				<h3 id="CMYK.At">func (*CMYK) <a href="/src/image/image.go?s=29855:29894#L1044">At</a>
					<a class="permalink" href="#CMYK.At">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (p *<a href="#CMYK">CMYK</a>) At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a></pre>
				
				
				
				
			
				
				<h3 id="CMYK.Bounds">func (*CMYK) <a href="/src/image/image.go?s=29802:29835#L1042">Bounds</a>
					<a class="permalink" href="#CMYK.Bounds">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (p *<a href="#CMYK">CMYK</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
				
				
				
				
			
				
				<h3 id="CMYK.CMYKAt">func (*CMYK) <a href="/src/image/image.go?s=30077:30119#L1053">CMYKAt</a>
					<a class="permalink" href="#CMYK.CMYKAt">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (p *<a href="#CMYK">CMYK</a>) CMYKAt(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#CMYK">CMYK</a></pre>
				
				
				
				
			
				
				<h3 id="CMYK.ColorModel">func (*CMYK) <a href="/src/image/image.go?s=29734:29773#L1040">ColorModel</a>
					<a class="permalink" href="#CMYK.ColorModel">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (p *<a href="#CMYK">CMYK</a>) ColorModel() <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a></pre>
				
				
				
				
			
				
				<h3 id="CMYK.Opaque">func (*CMYK) <a href="/src/image/image.go?s=32123:32151#L1125">Opaque</a>
					<a class="permalink" href="#CMYK.Opaque">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (p *<a href="#CMYK">CMYK</a>) Opaque() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Opaque scans the entire image and reports whether it is fully opaque.

				
				
				
			
				
				<h3 id="CMYK.PixOffset">func (*CMYK) <a href="/src/image/image.go?s=30449:30487#L1064">PixOffset</a>
					<a class="permalink" href="#CMYK.PixOffset">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (p *<a href="#CMYK">CMYK</a>) PixOffset(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>PixOffset returns the index of the first element of Pix that corresponds to
the pixel at (x, y).

				
				
				
			
				
				<h3 id="CMYK.RGBA64At">func (*CMYK) <a href="/src/image/image.go?s=29923:29969#L1048">RGBA64At</a>
					<a class="permalink" href="#CMYK.RGBA64At">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#CMYK">CMYK</a>) RGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a></pre>
				
				
				
				
			
				
				<h3 id="CMYK.Set">func (*CMYK) <a href="/src/image/image.go?s=30548:30591#L1068">Set</a>
					<a class="permalink" href="#CMYK.Set">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (p *<a href="#CMYK">CMYK</a>) Set(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a>)</pre>
				
				
				
				
			
				
				<h3 id="CMYK.SetCMYK">func (*CMYK) <a href="/src/image/image.go?s=31206:31252#L1094">SetCMYK</a>
					<a class="permalink" href="#CMYK.SetCMYK">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (p *<a href="#CMYK">CMYK</a>) SetCMYK(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#CMYK">CMYK</a>)</pre>
				
				
				
				
			
				
				<h3 id="CMYK.SetRGBA64">func (*CMYK) <a href="/src/image/image.go?s=30861:30911#L1081">SetRGBA64</a>
					<a class="permalink" href="#CMYK.SetRGBA64">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#CMYK">CMYK</a>) SetRGBA64(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a>)</pre>
				
				
				
				
			
				
				<h3 id="CMYK.SubImage">func (*CMYK) <a href="/src/image/image.go?s=31620:31662#L1108">SubImage</a>
					<a class="permalink" href="#CMYK.SubImage">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (p *<a href="#CMYK">CMYK</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
				<p>SubImage returns an image representing the portion of the image p visible
through r. The returned value shares pixels with the original image.

				
				
				
			
		
			
			
			<h2 id="Config">type <a href="/src/image/image.go?s=2034:2102#L35">Config</a>
				<a class="permalink" href="#Config">&#xb6;</a>
				
				
			</h2>
			<p>Config holds an image&apos;s color model and dimensions.

			<pre>type Config struct {
<span id="Config.ColorModel"></span>    ColorModel    <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a>
<span id="Config.Width"></span>    Width, Height <a href="/pkg/builtin/#int">int</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="DecodeConfig">func <a href="/src/image/format.go?s=2889:2943#L91">DecodeConfig</a>
					<a class="permalink" href="#DecodeConfig">&#xb6;</a>
					
					
				</h3>
				<pre>func DecodeConfig(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>) (<a href="#Config">Config</a>, <a href="/pkg/builtin/#string">string</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>DecodeConfig decodes the color model and dimensions of an image that has
been encoded in a registered format. The string returned is the format name
used during format registration. Format registration is typically done by
an init function in the codec-specific package.

				
				
			

			
		
			
			
			<h2 id="Gray">type <a href="/src/image/image.go?s=24059:24359#L833">Gray</a>
				<a class="permalink" href="#Gray">&#xb6;</a>
				
				
			</h2>
			<p>Gray is an in-memory image whose At method returns <a href="/image/color#Gray">color.Gray</a> values.

			<pre>type Gray struct {
<span id="Gray.Pix"></span>    <span class="comment">// Pix holds the image&#39;s pixels, as gray values. The pixel at</span>
    <span class="comment">// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].</span>
    Pix []<a href="/pkg/builtin/#uint8">uint8</a>
<span id="Gray.Stride"></span>    <span class="comment">// Stride is the Pix stride (in bytes) between vertically adjacent pixels.</span>
    Stride <a href="/pkg/builtin/#int">int</a>
<span id="Gray.Rect"></span>    <span class="comment">// Rect is the image&#39;s bounds.</span>
    Rect <a href="#Rectangle">Rectangle</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewGray">func <a href="/src/image/image.go?s=26411:26442#L921">NewGray</a>
					<a class="permalink" href="#NewGray">&#xb6;</a>
					
					
				</h3>
				<pre>func NewGray(r <a href="#Rectangle">Rectangle</a>) *<a href="#Gray">Gray</a></pre>
				<p>NewGray returns a new <a href="#Gray">Gray</a> image with the given bounds.

				
				
			

			
				
				<h3 id="Gray.At">func (*Gray) <a href="/src/image/image.go?s=24482:24521#L847">At</a>
					<a class="permalink" href="#Gray.At">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray">Gray</a>) At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a></pre>
				
				
				
				
			
				
				<h3 id="Gray.Bounds">func (*Gray) <a href="/src/image/image.go?s=24429:24462#L845">Bounds</a>
					<a class="permalink" href="#Gray.Bounds">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray">Gray</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
				
				
				
				
			
				
				<h3 id="Gray.ColorModel">func (*Gray) <a href="/src/image/image.go?s=24361:24400#L843">ColorModel</a>
					<a class="permalink" href="#Gray.ColorModel">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray">Gray</a>) ColorModel() <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a></pre>
				
				
				
				
			
				
				<h3 id="Gray.GrayAt">func (*Gray) <a href="/src/image/image.go?s=24702:24744#L857">GrayAt</a>
					<a class="permalink" href="#Gray.GrayAt">&#xb6;</a>
					
					<span title="Added in Go 1.4">1.4</span>
				</h3>
				<pre>func (p *<a href="#Gray">Gray</a>) GrayAt(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Gray">Gray</a></pre>
				
				
				
				
			
				
				<h3 id="Gray.Opaque">func (*Gray) <a href="/src/image/image.go?s=26303:26331#L916">Opaque</a>
					<a class="permalink" href="#Gray.Opaque">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray">Gray</a>) Opaque() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Opaque scans the entire image and reports whether it is fully opaque.

				
				
				
			
				
				<h3 id="Gray.PixOffset">func (*Gray) <a href="/src/image/image.go?s=24963:25001#L867">PixOffset</a>
					<a class="permalink" href="#Gray.PixOffset">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray">Gray</a>) PixOffset(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>PixOffset returns the index of the first element of Pix that corresponds to
the pixel at (x, y).

				
				
				
			
				
				<h3 id="Gray.RGBA64At">func (*Gray) <a href="/src/image/image.go?s=24550:24596#L851">RGBA64At</a>
					<a class="permalink" href="#Gray.RGBA64At">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#Gray">Gray</a>) RGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a></pre>
				
				
				
				
			
				
				<h3 id="Gray.Set">func (*Gray) <a href="/src/image/image.go?s=25062:25105#L871">Set</a>
					<a class="permalink" href="#Gray.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray">Gray</a>) Set(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a>)</pre>
				
				
				
				
			
				
				<h3 id="Gray.SetGray">func (*Gray) <a href="/src/image/image.go?s=25515:25561#L889">SetGray</a>
					<a class="permalink" href="#Gray.SetGray">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray">Gray</a>) SetGray(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Gray">Gray</a>)</pre>
				
				
				
				
			
				
				<h3 id="Gray.SetRGBA64">func (*Gray) <a href="/src/image/image.go?s=25233:25283#L879">SetRGBA64</a>
					<a class="permalink" href="#Gray.SetRGBA64">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#Gray">Gray</a>) SetRGBA64(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a>)</pre>
				
				
				
				
			
				
				<h3 id="Gray.SubImage">func (*Gray) <a href="/src/image/image.go?s=25800:25842#L899">SubImage</a>
					<a class="permalink" href="#Gray.SubImage">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray">Gray</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
				<p>SubImage returns an image representing the portion of the image p visible
through r. The returned value shares pixels with the original image.

				
				
				
			
		
			
			
			<h2 id="Gray16">type <a href="/src/image/image.go?s=26638:26961#L930">Gray16</a>
				<a class="permalink" href="#Gray16">&#xb6;</a>
				
				
			</h2>
			<p>Gray16 is an in-memory image whose At method returns <a href="/image/color#Gray16">color.Gray16</a> values.

			<pre>type Gray16 struct {
<span id="Gray16.Pix"></span>    <span class="comment">// Pix holds the image&#39;s pixels, as gray values in big-endian format. The pixel at</span>
    <span class="comment">// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*2].</span>
    Pix []<a href="/pkg/builtin/#uint8">uint8</a>
<span id="Gray16.Stride"></span>    <span class="comment">// Stride is the Pix stride (in bytes) between vertically adjacent pixels.</span>
    Stride <a href="/pkg/builtin/#int">int</a>
<span id="Gray16.Rect"></span>    <span class="comment">// Rect is the image&#39;s bounds.</span>
    Rect <a href="#Rectangle">Rectangle</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewGray16">func <a href="/src/image/image.go?s=29196:29231#L1021">NewGray16</a>
					<a class="permalink" href="#NewGray16">&#xb6;</a>
					
					
				</h3>
				<pre>func NewGray16(r <a href="#Rectangle">Rectangle</a>) *<a href="#Gray16">Gray16</a></pre>
				<p>NewGray16 returns a new <a href="#Gray16">Gray16</a> image with the given bounds.

				
				
			

			
				
				<h3 id="Gray16.At">func (*Gray16) <a href="/src/image/image.go?s=27090:27131#L944">At</a>
					<a class="permalink" href="#Gray16.At">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray16">Gray16</a>) At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a></pre>
				
				
				
				
			
				
				<h3 id="Gray16.Bounds">func (*Gray16) <a href="/src/image/image.go?s=27035:27070#L942">Bounds</a>
					<a class="permalink" href="#Gray16.Bounds">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray16">Gray16</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
				
				
				
				
			
				
				<h3 id="Gray16.ColorModel">func (*Gray16) <a href="/src/image/image.go?s=26963:27004#L940">ColorModel</a>
					<a class="permalink" href="#Gray16.ColorModel">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray16">Gray16</a>) ColorModel() <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a></pre>
				
				
				
				
			
				
				<h3 id="Gray16.Gray16At">func (*Gray16) <a href="/src/image/image.go?s=27291:27339#L953">Gray16At</a>
					<a class="permalink" href="#Gray16.Gray16At">&#xb6;</a>
					
					<span title="Added in Go 1.4">1.4</span>
				</h3>
				<pre>func (p *<a href="#Gray16">Gray16</a>) Gray16At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Gray16">Gray16</a></pre>
				
				
				
				
			
				
				<h3 id="Gray16.Opaque">func (*Gray16) <a href="/src/image/image.go?s=29082:29112#L1016">Opaque</a>
					<a class="permalink" href="#Gray16.Opaque">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray16">Gray16</a>) Opaque() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Opaque scans the entire image and reports whether it is fully opaque.

				
				
				
			
				
				<h3 id="Gray16.PixOffset">func (*Gray16) <a href="/src/image/image.go?s=27596:27636#L963">PixOffset</a>
					<a class="permalink" href="#Gray16.PixOffset">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray16">Gray16</a>) PixOffset(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>PixOffset returns the index of the first element of Pix that corresponds to
the pixel at (x, y).

				
				
				
			
				
				<h3 id="Gray16.RGBA64At">func (*Gray16) <a href="/src/image/image.go?s=27162:27210#L948">RGBA64At</a>
					<a class="permalink" href="#Gray16.RGBA64At">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#Gray16">Gray16</a>) RGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a></pre>
				
				
				
				
			
				
				<h3 id="Gray16.Set">func (*Gray16) <a href="/src/image/image.go?s=27697:27742#L967">Set</a>
					<a class="permalink" href="#Gray16.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray16">Gray16</a>) Set(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a>)</pre>
				
				
				
				
			
				
				<h3 id="Gray16.SetGray16">func (*Gray16) <a href="/src/image/image.go?s=28243:28295#L988">SetGray16</a>
					<a class="permalink" href="#Gray16.SetGray16">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray16">Gray16</a>) SetGray16(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Gray16">Gray16</a>)</pre>
				
				
				
				
			
				
				<h3 id="Gray16.SetRGBA64">func (*Gray16) <a href="/src/image/image.go?s=27924:27976#L977">SetRGBA64</a>
					<a class="permalink" href="#Gray16.SetRGBA64">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#Gray16">Gray16</a>) SetRGBA64(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a>)</pre>
				
				
				
				
			
				
				<h3 id="Gray16.SubImage">func (*Gray16) <a href="/src/image/image.go?s=28573:28617#L999">SubImage</a>
					<a class="permalink" href="#Gray16.SubImage">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Gray16">Gray16</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
				<p>SubImage returns an image representing the portion of the image p visible
through r. The returned value shares pixels with the original image.

				
				
				
			
		
			
			
			<h2 id="Image">type <a href="/src/image/image.go?s=2195:2671#L42">Image</a>
				<a class="permalink" href="#Image">&#xb6;</a>
				
				
			</h2>
			<p>Image is a finite rectangular grid of <a href="/image/color#Color">color.Color</a> values taken from a color
model.

			<pre>type Image interface {
    <span class="comment">// ColorModel returns the Image&#39;s color model.</span>
    ColorModel() <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a>
    <span class="comment">// Bounds returns the domain for which At can return non-zero color.</span>
    <span class="comment">// The bounds do not necessarily contain the point (0, 0).</span>
    Bounds() <a href="#Rectangle">Rectangle</a>
    <span class="comment">// At returns the color of the pixel at (x, y).</span>
    <span class="comment">// At(Bounds().Min.X, Bounds().Min.Y) returns the upper-left pixel of the grid.</span>
    <span class="comment">// At(Bounds().Max.X-1, Bounds().Max.Y-1) returns the lower-right one.</span>
    At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="Decode">func <a href="/src/image/format.go?s=2418:2465#L77">Decode</a>
					<a class="permalink" href="#Decode">&#xb6;</a>
					
					
				</h3>
				<pre>func Decode(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>) (<a href="#Image">Image</a>, <a href="/pkg/builtin/#string">string</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Decode decodes an image that has been encoded in a registered format.
The string returned is the format name used during format registration.
Format registration is typically done by an init function in the codec-
specific package.

				
				
			

			
		
			
			
			<h2 id="NRGBA">type <a href="/src/image/image.go?s=11042:11348#L343">NRGBA</a>
				<a class="permalink" href="#NRGBA">&#xb6;</a>
				
				
			</h2>
			<p>NRGBA is an in-memory image whose At method returns <a href="/image/color#NRGBA">color.NRGBA</a> values.

			<pre>type NRGBA struct {
<span id="NRGBA.Pix"></span>    <span class="comment">// Pix holds the image&#39;s pixels, in R, G, B, A order. The pixel at</span>
    <span class="comment">// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].</span>
    Pix []<a href="/pkg/builtin/#uint8">uint8</a>
<span id="NRGBA.Stride"></span>    <span class="comment">// Stride is the Pix stride (in bytes) between vertically adjacent pixels.</span>
    Stride <a href="/pkg/builtin/#int">int</a>
<span id="NRGBA.Rect"></span>    <span class="comment">// Rect is the image&#39;s bounds.</span>
    Rect <a href="#Rectangle">Rectangle</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewNRGBA">func <a href="/src/image/image.go?s=14241:14274#L461">NewNRGBA</a>
					<a class="permalink" href="#NewNRGBA">&#xb6;</a>
					
					
				</h3>
				<pre>func NewNRGBA(r <a href="#Rectangle">Rectangle</a>) *<a href="#NRGBA">NRGBA</a></pre>
				<p>NewNRGBA returns a new <a href="#NRGBA">NRGBA</a> image with the given bounds.

				
				
			

			
				
				<h3 id="NRGBA.At">func (*NRGBA) <a href="/src/image/image.go?s=11474:11514#L357">At</a>
					<a class="permalink" href="#NRGBA.At">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA">NRGBA</a>) At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a></pre>
				
				
				
				
			
				
				<h3 id="NRGBA.Bounds">func (*NRGBA) <a href="/src/image/image.go?s=11420:11454#L355">Bounds</a>
					<a class="permalink" href="#NRGBA.Bounds">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA">NRGBA</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
				
				
				
				
			
				
				<h3 id="NRGBA.ColorModel">func (*NRGBA) <a href="/src/image/image.go?s=11350:11390#L353">ColorModel</a>
					<a class="permalink" href="#NRGBA.ColorModel">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA">NRGBA</a>) ColorModel() <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a></pre>
				
				
				
				
			
				
				<h3 id="NRGBA.NRGBAAt">func (*NRGBA) <a href="/src/image/image.go?s=11700:11745#L366">NRGBAAt</a>
					<a class="permalink" href="#NRGBA.NRGBAAt">&#xb6;</a>
					
					<span title="Added in Go 1.4">1.4</span>
				</h3>
				<pre>func (p *<a href="#NRGBA">NRGBA</a>) NRGBAAt(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#NRGBA">NRGBA</a></pre>
				
				
				
				
			
				
				<h3 id="NRGBA.Opaque">func (*NRGBA) <a href="/src/image/image.go?s=13896:13925#L443">Opaque</a>
					<a class="permalink" href="#NRGBA.Opaque">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA">NRGBA</a>) Opaque() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Opaque scans the entire image and reports whether it is fully opaque.

				
				
				
			
				
				<h3 id="NRGBA.PixOffset">func (*NRGBA) <a href="/src/image/image.go?s=12077:12116#L377">PixOffset</a>
					<a class="permalink" href="#NRGBA.PixOffset">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA">NRGBA</a>) PixOffset(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>PixOffset returns the index of the first element of Pix that corresponds to
the pixel at (x, y).

				
				
				
			
				
				<h3 id="NRGBA.RGBA64At">func (*NRGBA) <a href="/src/image/image.go?s=11544:11591#L361">RGBA64At</a>
					<a class="permalink" href="#NRGBA.RGBA64At">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#NRGBA">NRGBA</a>) RGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a></pre>
				
				
				
				
			
				
				<h3 id="NRGBA.Set">func (*NRGBA) <a href="/src/image/image.go?s=12177:12221#L381">Set</a>
					<a class="permalink" href="#NRGBA.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA">NRGBA</a>) Set(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a>)</pre>
				
				
				
				
			
				
				<h3 id="NRGBA.SetNRGBA">func (*NRGBA) <a href="/src/image/image.go?s=12973:13022#L412">SetNRGBA</a>
					<a class="permalink" href="#NRGBA.SetNRGBA">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA">NRGBA</a>) SetNRGBA(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#NRGBA">NRGBA</a>)</pre>
				
				
				
				
			
				
				<h3 id="NRGBA.SetRGBA64">func (*NRGBA) <a href="/src/image/image.go?s=12493:12544#L394">SetRGBA64</a>
					<a class="permalink" href="#NRGBA.SetRGBA64">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#NRGBA">NRGBA</a>) SetRGBA64(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a>)</pre>
				
				
				
				
			
				
				<h3 id="NRGBA.SubImage">func (*NRGBA) <a href="/src/image/image.go?s=13390:13433#L426">SubImage</a>
					<a class="permalink" href="#NRGBA.SubImage">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA">NRGBA</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
				<p>SubImage returns an image representing the portion of the image p visible
through r. The returned value shares pixels with the original image.

				
				
				
			
		
			
			
			<h2 id="NRGBA64">type <a href="/src/image/image.go?s=14474:14804#L470">NRGBA64</a>
				<a class="permalink" href="#NRGBA64">&#xb6;</a>
				
				
			</h2>
			<p>NRGBA64 is an in-memory image whose At method returns <a href="/image/color#NRGBA64">color.NRGBA64</a> values.

			<pre>type NRGBA64 struct {
<span id="NRGBA64.Pix"></span>    <span class="comment">// Pix holds the image&#39;s pixels, in R, G, B, A order and big-endian format. The pixel at</span>
    <span class="comment">// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8].</span>
    Pix []<a href="/pkg/builtin/#uint8">uint8</a>
<span id="NRGBA64.Stride"></span>    <span class="comment">// Stride is the Pix stride (in bytes) between vertically adjacent pixels.</span>
    Stride <a href="/pkg/builtin/#int">int</a>
<span id="NRGBA64.Rect"></span>    <span class="comment">// Rect is the image&#39;s bounds.</span>
    Rect <a href="#Rectangle">Rectangle</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewNRGBA64">func <a href="/src/image/image.go?s=18209:18246#L605">NewNRGBA64</a>
					<a class="permalink" href="#NewNRGBA64">&#xb6;</a>
					
					
				</h3>
				<pre>func NewNRGBA64(r <a href="#Rectangle">Rectangle</a>) *<a href="#NRGBA64">NRGBA64</a></pre>
				<p>NewNRGBA64 returns a new <a href="#NRGBA64">NRGBA64</a> image with the given bounds.

				
				
			

			
				
				<h3 id="NRGBA64.At">func (*NRGBA64) <a href="/src/image/image.go?s=14936:14978#L484">At</a>
					<a class="permalink" href="#NRGBA64.At">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA64">NRGBA64</a>) At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a></pre>
				
				
				
				
			
				
				<h3 id="NRGBA64.Bounds">func (*NRGBA64) <a href="/src/image/image.go?s=14880:14916#L482">Bounds</a>
					<a class="permalink" href="#NRGBA64.Bounds">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA64">NRGBA64</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
				
				
				
				
			
				
				<h3 id="NRGBA64.ColorModel">func (*NRGBA64) <a href="/src/image/image.go?s=14806:14848#L480">ColorModel</a>
					<a class="permalink" href="#NRGBA64.ColorModel">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA64">NRGBA64</a>) ColorModel() <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a></pre>
				
				
				
				
			
				
				<h3 id="NRGBA64.NRGBA64At">func (*NRGBA64) <a href="/src/image/image.go?s=15170:15221#L493">NRGBA64At</a>
					<a class="permalink" href="#NRGBA64.NRGBA64At">&#xb6;</a>
					
					<span title="Added in Go 1.4">1.4</span>
				</h3>
				<pre>func (p *<a href="#NRGBA64">NRGBA64</a>) NRGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#NRGBA64">NRGBA64</a></pre>
				
				
				
				
			
				
				<h3 id="NRGBA64.Opaque">func (*NRGBA64) <a href="/src/image/image.go?s=17834:17865#L587">Opaque</a>
					<a class="permalink" href="#NRGBA64.Opaque">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA64">NRGBA64</a>) Opaque() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Opaque scans the entire image and reports whether it is fully opaque.

				
				
				
			
				
				<h3 id="NRGBA64.PixOffset">func (*NRGBA64) <a href="/src/image/image.go?s=15673:15714#L509">PixOffset</a>
					<a class="permalink" href="#NRGBA64.PixOffset">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA64">NRGBA64</a>) PixOffset(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>PixOffset returns the index of the first element of Pix that corresponds to
the pixel at (x, y).

				
				
				
			
				
				<h3 id="NRGBA64.RGBA64At">func (*NRGBA64) <a href="/src/image/image.go?s=15010:15059#L488">RGBA64At</a>
					<a class="permalink" href="#NRGBA64.RGBA64At">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#NRGBA64">NRGBA64</a>) RGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a></pre>
				
				
				
				
			
				
				<h3 id="NRGBA64.Set">func (*NRGBA64) <a href="/src/image/image.go?s=15775:15821#L513">Set</a>
					<a class="permalink" href="#NRGBA64.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA64">NRGBA64</a>) Set(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a>)</pre>
				
				
				
				
			
				
				<h3 id="NRGBA64.SetNRGBA64">func (*NRGBA64) <a href="/src/image/image.go?s=16775:16830#L552">SetNRGBA64</a>
					<a class="permalink" href="#NRGBA64.SetNRGBA64">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA64">NRGBA64</a>) SetNRGBA64(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#NRGBA64">NRGBA64</a>)</pre>
				
				
				
				
			
				
				<h3 id="NRGBA64.SetRGBA64">func (*NRGBA64) <a href="/src/image/image.go?s=16225:16278#L530">SetRGBA64</a>
					<a class="permalink" href="#NRGBA64.SetRGBA64">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#NRGBA64">NRGBA64</a>) SetRGBA64(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a>)</pre>
				
				
				
				
			
				
				<h3 id="NRGBA64.SubImage">func (*NRGBA64) <a href="/src/image/image.go?s=17322:17367#L570">SubImage</a>
					<a class="permalink" href="#NRGBA64.SubImage">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#NRGBA64">NRGBA64</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
				<p>SubImage returns an image representing the portion of the image p visible
through r. The returned value shares pixels with the original image.

				
				
				
			
		
			
			
			<h2 id="NYCbCrA">type <a href="/src/image/ycbcr.go?s=5866:5926#L195">NYCbCrA</a>
				<a class="permalink" href="#NYCbCrA">&#xb6;</a>
				
				<span title="Added in Go 1.6">1.6</span>
			</h2>
			<p>NYCbCrA is an in-memory image of non-alpha-premultiplied Y&apos;CbCr-with-alpha
colors. A and AStride are analogous to the Y and YStride fields of the
embedded YCbCr.

			<pre>type NYCbCrA struct {
    <a href="#YCbCr">YCbCr</a>
<span id="NYCbCrA.A"></span>    A       []<a href="/pkg/builtin/#uint8">uint8</a>
<span id="NYCbCrA.AStride"></span>    AStride <a href="/pkg/builtin/#int">int</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewNYCbCrA">func <a href="/src/image/ycbcr.go?s=8116:8189#L289">NewNYCbCrA</a>
					<a class="permalink" href="#NewNYCbCrA">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func NewNYCbCrA(r <a href="#Rectangle">Rectangle</a>, subsampleRatio <a href="#YCbCrSubsampleRatio">YCbCrSubsampleRatio</a>) *<a href="#NYCbCrA">NYCbCrA</a></pre>
				<p>NewNYCbCrA returns a new <a href="#NYCbCrA">NYCbCrA</a> image with the given bounds and subsample
ratio.

				
				
			

			
				
				<h3 id="NYCbCrA.AOffset">func (*NYCbCrA) <a href="/src/image/ycbcr.go?s=6635:6674#L233">AOffset</a>
					<a class="permalink" href="#NYCbCrA.AOffset">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func (p *<a href="#NYCbCrA">NYCbCrA</a>) AOffset(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>AOffset returns the index of the first element of A that corresponds to the
pixel at (x, y).

				
				
				
			
				
				<h3 id="NYCbCrA.At">func (*NYCbCrA) <a href="/src/image/ycbcr.go?s=6003:6045#L205">At</a>
					<a class="permalink" href="#NYCbCrA.At">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func (p *<a href="#NYCbCrA">NYCbCrA</a>) At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a></pre>
				
				
				
				
			
				
				<h3 id="NYCbCrA.ColorModel">func (*NYCbCrA) <a href="/src/image/ycbcr.go?s=5928:5970#L201">ColorModel</a>
					<a class="permalink" href="#NYCbCrA.ColorModel">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func (p *<a href="#NYCbCrA">NYCbCrA</a>) ColorModel() <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a></pre>
				
				
				
				
			
				
				<h3 id="NYCbCrA.NYCbCrAAt">func (*NYCbCrA) <a href="/src/image/ycbcr.go?s=6237:6288#L214">NYCbCrAAt</a>
					<a class="permalink" href="#NYCbCrA.NYCbCrAAt">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func (p *<a href="#NYCbCrA">NYCbCrA</a>) NYCbCrAAt(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#NYCbCrA">NYCbCrA</a></pre>
				
				
				
				
			
				
				<h3 id="NYCbCrA.Opaque">func (*NYCbCrA) <a href="/src/image/ycbcr.go?s=7748:7779#L270">Opaque</a>
					<a class="permalink" href="#NYCbCrA.Opaque">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func (p *<a href="#NYCbCrA">NYCbCrA</a>) Opaque() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Opaque scans the entire image and reports whether it is fully opaque.

				
				
				
			
				
				<h3 id="NYCbCrA.RGBA64At">func (*NYCbCrA) <a href="/src/image/ycbcr.go?s=6077:6126#L209">RGBA64At</a>
					<a class="permalink" href="#NYCbCrA.RGBA64At">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#NYCbCrA">NYCbCrA</a>) RGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a></pre>
				
				
				
				
			
				
				<h3 id="NYCbCrA.SubImage">func (*NYCbCrA) <a href="/src/image/ycbcr.go?s=6885:6930#L239">SubImage</a>
					<a class="permalink" href="#NYCbCrA.SubImage">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func (p *<a href="#NYCbCrA">NYCbCrA</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
				<p>SubImage returns an image representing the portion of the image p visible
through r. The returned value shares pixels with the original image.

				
				
				
			
		
			
			
			<h2 id="Paletted">type <a href="/src/image/image.go?s=32450:32817#L1139">Paletted</a>
				<a class="permalink" href="#Paletted">&#xb6;</a>
				
				
			</h2>
			<p>Paletted is an in-memory image of uint8 indices into a given palette.

			<pre>type Paletted struct {
<span id="Paletted.Pix"></span>    <span class="comment">// Pix holds the image&#39;s pixels, as palette indices. The pixel at</span>
    <span class="comment">// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*1].</span>
    Pix []<a href="/pkg/builtin/#uint8">uint8</a>
<span id="Paletted.Stride"></span>    <span class="comment">// Stride is the Pix stride (in bytes) between vertically adjacent pixels.</span>
    Stride <a href="/pkg/builtin/#int">int</a>
<span id="Paletted.Rect"></span>    <span class="comment">// Rect is the image&#39;s bounds.</span>
    Rect <a href="#Rectangle">Rectangle</a>
<span id="Paletted.Palette"></span>    <span class="comment">// Palette is the image&#39;s palette.</span>
    Palette <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Palette">Palette</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewPaletted">func <a href="/src/image/image.go?s=35510:35566#L1270">NewPaletted</a>
					<a class="permalink" href="#NewPaletted">&#xb6;</a>
					
					
				</h3>
				<pre>func NewPaletted(r <a href="#Rectangle">Rectangle</a>, p <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Palette">Palette</a>) *<a href="#Paletted">Paletted</a></pre>
				<p>NewPaletted returns a new <a href="#Paletted">Paletted</a> image with the given width, height and
palette.

				
				
			

			
				
				<h3 id="Paletted.At">func (*Paletted) <a href="/src/image/image.go?s=32942:32985#L1155">At</a>
					<a class="permalink" href="#Paletted.At">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Paletted">Paletted</a>) At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a></pre>
				
				
				
				
			
				
				<h3 id="Paletted.Bounds">func (*Paletted) <a href="/src/image/image.go?s=32885:32922#L1153">Bounds</a>
					<a class="permalink" href="#Paletted.Bounds">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Paletted">Paletted</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
				
				
				
				
			
				
				<h3 id="Paletted.ColorIndexAt">func (*Paletted) <a href="/src/image/image.go?s=34021:34068#L1208">ColorIndexAt</a>
					<a class="permalink" href="#Paletted.ColorIndexAt">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Paletted">Paletted</a>) ColorIndexAt(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#uint8">uint8</a></pre>
				
				
				
				
			
				
				<h3 id="Paletted.ColorModel">func (*Paletted) <a href="/src/image/image.go?s=32819:32862#L1151">ColorModel</a>
					<a class="permalink" href="#Paletted.ColorModel">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Paletted">Paletted</a>) ColorModel() <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a></pre>
				
				
				
				
			
				
				<h3 id="Paletted.Opaque">func (*Paletted) <a href="/src/image/image.go?s=35041:35073#L1246">Opaque</a>
					<a class="permalink" href="#Paletted.Opaque">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Paletted">Paletted</a>) Opaque() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Opaque scans the entire image and reports whether it is fully opaque.

				
				
				
			
				
				<h3 id="Paletted.PixOffset">func (*Paletted) <a href="/src/image/image.go?s=33593:33635#L1188">PixOffset</a>
					<a class="permalink" href="#Paletted.PixOffset">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Paletted">Paletted</a>) PixOffset(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>PixOffset returns the index of the first element of Pix that corresponds to
the pixel at (x, y).

				
				
				
			
				
				<h3 id="Paletted.RGBA64At">func (*Paletted) <a href="/src/image/image.go?s=33142:33192#L1166">RGBA64At</a>
					<a class="permalink" href="#Paletted.RGBA64At">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#Paletted">Paletted</a>) RGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a></pre>
				
				
				
				
			
				
				<h3 id="Paletted.Set">func (*Paletted) <a href="/src/image/image.go?s=33696:33743#L1192">Set</a>
					<a class="permalink" href="#Paletted.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Paletted">Paletted</a>) Set(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a>)</pre>
				
				
				
				
			
				
				<h3 id="Paletted.SetColorIndex">func (*Paletted) <a href="/src/image/image.go?s=34161:34216#L1216">SetColorIndex</a>
					<a class="permalink" href="#Paletted.SetColorIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Paletted">Paletted</a>) SetColorIndex(x, y <a href="/pkg/builtin/#int">int</a>, index <a href="/pkg/builtin/#uint8">uint8</a>)</pre>
				
				
				
				
			
				
				<h3 id="Paletted.SetRGBA64">func (*Paletted) <a href="/src/image/image.go?s=33855:33909#L1200">SetRGBA64</a>
					<a class="permalink" href="#Paletted.SetRGBA64">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#Paletted">Paletted</a>) SetRGBA64(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a>)</pre>
				
				
				
				
			
				
				<h3 id="Paletted.SubImage">func (*Paletted) <a href="/src/image/image.go?s=34457:34503#L1226">SubImage</a>
					<a class="permalink" href="#Paletted.SubImage">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Paletted">Paletted</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
				<p>SubImage returns an image representing the portion of the image p visible
through r. The returned value shares pixels with the original image.

				
				
				
			
		
			
			
			<h2 id="PalettedImage">type <a href="/src/image/image.go?s=3433:3569#L70">PalettedImage</a>
				<a class="permalink" href="#PalettedImage">&#xb6;</a>
				
				
			</h2>
			<p>PalettedImage is an image whose colors may come from a limited palette.
If m is a PalettedImage and m.ColorModel() returns a <a href="/image/color#Palette">color.Palette</a> p,
then m.At(x, y) should be equivalent to p[m.ColorIndexAt(x, y)]. If m&apos;s
color model is not a color.Palette, then ColorIndexAt&apos;s behavior is
undefined.

			<pre>type PalettedImage interface {
    <span class="comment">// ColorIndexAt returns the palette index of the pixel at (x, y).</span>
    ColorIndexAt(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#uint8">uint8</a>
    <a href="#Image">Image</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Point">type <a href="/src/image/geom.go?s=299:330#L4">Point</a>
				<a class="permalink" href="#Point">&#xb6;</a>
				
				
			</h2>
			<p>A Point is an X, Y coordinate pair. The axes increase right and down.

			<pre>type Point struct {
<span id="Point.X"></span>    X, Y <a href="/pkg/builtin/#int">int</a>
}
</pre>

			

			
				<p>ZP is the zero <a href="#Point">Point</a>.
<p>Deprecated: Use a literal <a href="#Point">image.Point</a> instead.

				<pre>var <span id="ZP">ZP</span> <a href="#Point">Point</a></pre>
			

			
			
			

			
				
				<h3 id="Pt">func <a href="/src/image/geom.go?s=1596:1619#L66">Pt</a>
					<a class="permalink" href="#Pt">&#xb6;</a>
					
					
				</h3>
				<pre>func Pt(X, Y <a href="/pkg/builtin/#int">int</a>) <a href="#Point">Point</a></pre>
				<p>Pt is shorthand for <a href="#Point">Point</a>{X, Y}.

				
				
			

			
				
				<h3 id="Point.Add">func (Point) <a href="/src/image/geom.go?s=524:557#L14">Add</a>
					<a class="permalink" href="#Point.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (p <a href="#Point">Point</a>) Add(q <a href="#Point">Point</a>) <a href="#Point">Point</a></pre>
				<p>Add returns the vector p+q.

				
				
				
			
				
				<h3 id="Point.Div">func (Point) <a href="/src/image/geom.go?s=836:867#L29">Div</a>
					<a class="permalink" href="#Point.Div">&#xb6;</a>
					
					
				</h3>
				<pre>func (p <a href="#Point">Point</a>) Div(k <a href="/pkg/builtin/#int">int</a>) <a href="#Point">Point</a></pre>
				<p>Div returns the vector p/k.

				
				
				
			
				
				<h3 id="Point.Eq">func (Point) <a href="/src/image/geom.go?s=1410:1441#L56">Eq</a>
					<a class="permalink" href="#Point.Eq">&#xb6;</a>
					
					
				</h3>
				<pre>func (p <a href="#Point">Point</a>) Eq(q <a href="#Point">Point</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Eq reports whether p and q are equal.

				
				
				
			
				
				<h3 id="Point.In">func (Point) <a href="/src/image/geom.go?s=938:973#L34">In</a>
					<a class="permalink" href="#Point.In">&#xb6;</a>
					
					
				</h3>
				<pre>func (p <a href="#Point">Point</a>) In(r <a href="#Rectangle">Rectangle</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>In reports whether p is in r.

				
				
				
			
				
				<h3 id="Point.Mod">func (Point) <a href="/src/image/geom.go?s=1177:1214#L41">Mod</a>
					<a class="permalink" href="#Point.Mod">&#xb6;</a>
					
					
				</h3>
				<pre>func (p <a href="#Point">Point</a>) Mod(r <a href="#Rectangle">Rectangle</a>) <a href="#Point">Point</a></pre>
				<p>Mod returns the point q in r such that p.X-q.X is a multiple of r&apos;s width
and p.Y-q.Y is a multiple of r&apos;s height.

				
				
				
			
				
				<h3 id="Point.Mul">func (Point) <a href="/src/image/geom.go?s=736:767#L24">Mul</a>
					<a class="permalink" href="#Point.Mul">&#xb6;</a>
					
					
				</h3>
				<pre>func (p <a href="#Point">Point</a>) Mul(k <a href="/pkg/builtin/#int">int</a>) <a href="#Point">Point</a></pre>
				<p>Mul returns the vector p*k.

				
				
				
			
				
				<h3 id="Point.String">func (Point) <a href="/src/image/geom.go?s=393:423#L9">String</a>
					<a class="permalink" href="#Point.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (p <a href="#Point">Point</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>String returns a string representation of p like &quot;(3,4)&quot;.

				
				
				
			
				
				<h3 id="Point.Sub">func (Point) <a href="/src/image/geom.go?s=630:663#L19">Sub</a>
					<a class="permalink" href="#Point.Sub">&#xb6;</a>
					
					
				</h3>
				<pre>func (p <a href="#Point">Point</a>) Sub(q <a href="#Point">Point</a>) <a href="#Point">Point</a></pre>
				<p>Sub returns the vector p-q.

				
				
				
			
		
			
			
			<h2 id="RGBA">type <a href="/src/image/image.go?s=4328:4633#L92">RGBA</a>
				<a class="permalink" href="#RGBA">&#xb6;</a>
				
				
			</h2>
			<p>RGBA is an in-memory image whose At method returns <a href="/image/color#RGBA">color.RGBA</a> values.

			<pre>type RGBA struct {
<span id="RGBA.Pix"></span>    <span class="comment">// Pix holds the image&#39;s pixels, in R, G, B, A order. The pixel at</span>
    <span class="comment">// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*4].</span>
    Pix []<a href="/pkg/builtin/#uint8">uint8</a>
<span id="RGBA.Stride"></span>    <span class="comment">// Stride is the Pix stride (in bytes) between vertically adjacent pixels.</span>
    Stride <a href="/pkg/builtin/#int">int</a>
<span id="RGBA.Rect"></span>    <span class="comment">// Rect is the image&#39;s bounds.</span>
    Rect <a href="#Rectangle">Rectangle</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewRGBA">func <a href="/src/image/image.go?s=7581:7612#L217">NewRGBA</a>
					<a class="permalink" href="#NewRGBA">&#xb6;</a>
					
					
				</h3>
				<pre>func NewRGBA(r <a href="#Rectangle">Rectangle</a>) *<a href="#RGBA">RGBA</a></pre>
				<p>NewRGBA returns a new <a href="#RGBA">RGBA</a> image with the given bounds.

				
				
			

			
				
				<h3 id="RGBA.At">func (*RGBA) <a href="/src/image/image.go?s=4756:4795#L106">At</a>
					<a class="permalink" href="#RGBA.At">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA">RGBA</a>) At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a></pre>
				
				
				
				
			
				
				<h3 id="RGBA.Bounds">func (*RGBA) <a href="/src/image/image.go?s=4703:4736#L104">Bounds</a>
					<a class="permalink" href="#RGBA.Bounds">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA">RGBA</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
				
				
				
				
			
				
				<h3 id="RGBA.ColorModel">func (*RGBA) <a href="/src/image/image.go?s=4635:4674#L102">ColorModel</a>
					<a class="permalink" href="#RGBA.ColorModel">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA">RGBA</a>) ColorModel() <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a></pre>
				
				
				
				
			
				
				<h3 id="RGBA.Opaque">func (*RGBA) <a href="/src/image/image.go?s=7239:7267#L199">Opaque</a>
					<a class="permalink" href="#RGBA.Opaque">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA">RGBA</a>) Opaque() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Opaque scans the entire image and reports whether it is fully opaque.

				
				
				
			
				
				<h3 id="RGBA.PixOffset">func (*RGBA) <a href="/src/image/image.go?s=5593:5631#L139">PixOffset</a>
					<a class="permalink" href="#RGBA.PixOffset">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA">RGBA</a>) PixOffset(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>PixOffset returns the index of the first element of Pix that corresponds to
the pixel at (x, y).

				
				
				
			
				
				<h3 id="RGBA.RGBA64At">func (*RGBA) <a href="/src/image/image.go?s=4824:4870#L110">RGBA64At</a>
					<a class="permalink" href="#RGBA.RGBA64At">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#RGBA">RGBA</a>) RGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a></pre>
				
				
				
				
			
				
				<h3 id="RGBA.RGBAAt">func (*RGBA) <a href="/src/image/image.go?s=5221:5263#L128">RGBAAt</a>
					<a class="permalink" href="#RGBA.RGBAAt">&#xb6;</a>
					
					<span title="Added in Go 1.4">1.4</span>
				</h3>
				<pre>func (p *<a href="#RGBA">RGBA</a>) RGBAAt(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA">RGBA</a></pre>
				
				
				
				
			
				
				<h3 id="RGBA.Set">func (*RGBA) <a href="/src/image/image.go?s=5692:5735#L143">Set</a>
					<a class="permalink" href="#RGBA.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA">RGBA</a>) Set(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a>)</pre>
				
				
				
				
			
				
				<h3 id="RGBA.SetRGBA">func (*RGBA) <a href="/src/image/image.go?s=6322:6368#L168">SetRGBA</a>
					<a class="permalink" href="#RGBA.SetRGBA">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA">RGBA</a>) SetRGBA(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA">RGBA</a>)</pre>
				
				
				
				
			
				
				<h3 id="RGBA.SetRGBA64">func (*RGBA) <a href="/src/image/image.go?s=6005:6055#L156">SetRGBA64</a>
					<a class="permalink" href="#RGBA.SetRGBA64">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#RGBA">RGBA</a>) SetRGBA64(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a>)</pre>
				
				
				
				
			
				
				<h3 id="RGBA.SubImage">func (*RGBA) <a href="/src/image/image.go?s=6736:6778#L182">SubImage</a>
					<a class="permalink" href="#RGBA.SubImage">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA">RGBA</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
				<p>SubImage returns an image representing the portion of the image p visible
through r. The returned value shares pixels with the original image.

				
				
				
			
		
			
			
			<h2 id="RGBA64">type <a href="/src/image/image.go?s=7808:8137#L226">RGBA64</a>
				<a class="permalink" href="#RGBA64">&#xb6;</a>
				
				
			</h2>
			<p>RGBA64 is an in-memory image whose At method returns <a href="/image/color#RGBA64">color.RGBA64</a> values.

			<pre>type RGBA64 struct {
<span id="RGBA64.Pix"></span>    <span class="comment">// Pix holds the image&#39;s pixels, in R, G, B, A order and big-endian format. The pixel at</span>
    <span class="comment">// (x, y) starts at Pix[(y-Rect.Min.Y)*Stride + (x-Rect.Min.X)*8].</span>
    Pix []<a href="/pkg/builtin/#uint8">uint8</a>
<span id="RGBA64.Stride"></span>    <span class="comment">// Stride is the Pix stride (in bytes) between vertically adjacent pixels.</span>
    Stride <a href="/pkg/builtin/#int">int</a>
<span id="RGBA64.Rect"></span>    <span class="comment">// Rect is the image&#39;s bounds.</span>
    Rect <a href="#Rectangle">Rectangle</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewRGBA64">func <a href="/src/image/image.go?s=10809:10844#L334">NewRGBA64</a>
					<a class="permalink" href="#NewRGBA64">&#xb6;</a>
					
					
				</h3>
				<pre>func NewRGBA64(r <a href="#Rectangle">Rectangle</a>) *<a href="#RGBA64">RGBA64</a></pre>
				<p>NewRGBA64 returns a new <a href="#RGBA64">RGBA64</a> image with the given bounds.

				
				
			

			
				
				<h3 id="RGBA64.At">func (*RGBA64) <a href="/src/image/image.go?s=8266:8307#L240">At</a>
					<a class="permalink" href="#RGBA64.At">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA64">RGBA64</a>) At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a></pre>
				
				
				
				
			
				
				<h3 id="RGBA64.Bounds">func (*RGBA64) <a href="/src/image/image.go?s=8211:8246#L238">Bounds</a>
					<a class="permalink" href="#RGBA64.Bounds">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA64">RGBA64</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
				
				
				
				
			
				
				<h3 id="RGBA64.ColorModel">func (*RGBA64) <a href="/src/image/image.go?s=8139:8180#L236">ColorModel</a>
					<a class="permalink" href="#RGBA64.ColorModel">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA64">RGBA64</a>) ColorModel() <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a></pre>
				
				
				
				
			
				
				<h3 id="RGBA64.Opaque">func (*RGBA64) <a href="/src/image/image.go?s=10437:10467#L316">Opaque</a>
					<a class="permalink" href="#RGBA64.Opaque">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA64">RGBA64</a>) Opaque() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Opaque scans the entire image and reports whether it is fully opaque.

				
				
				
			
				
				<h3 id="RGBA64.PixOffset">func (*RGBA64) <a href="/src/image/image.go?s=8836:8876#L260">PixOffset</a>
					<a class="permalink" href="#RGBA64.PixOffset">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA64">RGBA64</a>) PixOffset(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>PixOffset returns the index of the first element of Pix that corresponds to
the pixel at (x, y).

				
				
				
			
				
				<h3 id="RGBA64.RGBA64At">func (*RGBA64) <a href="/src/image/image.go?s=8338:8386#L244">RGBA64At</a>
					<a class="permalink" href="#RGBA64.RGBA64At">&#xb6;</a>
					
					<span title="Added in Go 1.4">1.4</span>
				</h3>
				<pre>func (p *<a href="#RGBA64">RGBA64</a>) RGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a></pre>
				
				
				
				
			
				
				<h3 id="RGBA64.Set">func (*RGBA64) <a href="/src/image/image.go?s=8937:8982#L264">Set</a>
					<a class="permalink" href="#RGBA64.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA64">RGBA64</a>) Set(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a>)</pre>
				
				
				
				
			
				
				<h3 id="RGBA64.SetRGBA64">func (*RGBA64) <a href="/src/image/image.go?s=9384:9436#L281">SetRGBA64</a>
					<a class="permalink" href="#RGBA64.SetRGBA64">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA64">RGBA64</a>) SetRGBA64(x, y <a href="/pkg/builtin/#int">int</a>, c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a>)</pre>
				
				
				
				
			
				
				<h3 id="RGBA64.SubImage">func (*RGBA64) <a href="/src/image/image.go?s=9928:9972#L299">SubImage</a>
					<a class="permalink" href="#RGBA64.SubImage">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#RGBA64">RGBA64</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
				<p>SubImage returns an image representing the portion of the image p visible
through r. The returned value shares pixels with the original image.

				
				
				
			
		
			
			
			<h2 id="RGBA64Image">type <a href="/src/image/image.go?s=2763:3121#L56">RGBA64Image</a>
				<a class="permalink" href="#RGBA64Image">&#xb6;</a>
				
				<span title="Added in Go 1.17">1.17</span>
			</h2>
			<p>RGBA64Image is an <a href="#Image">Image</a> whose pixels can be converted directly to a
color.RGBA64.

			<pre>type RGBA64Image interface {
    <span class="comment">// RGBA64At returns the RGBA64 color of the pixel at (x, y). It is</span>
    <span class="comment">// equivalent to calling At(x, y).RGBA() and converting the resulting</span>
    <span class="comment">// 32-bit return values to a color.RGBA64, but it can avoid allocations</span>
    <span class="comment">// from converting concrete color types to the color.Color interface type.</span>
    RGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a>
    <a href="#Image">Image</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Rectangle">type <a href="/src/image/geom.go?s=2068:2109#L78">Rectangle</a>
				<a class="permalink" href="#Rectangle">&#xb6;</a>
				
				
			</h2>
			<p>A Rectangle contains the points with Min.X &lt;= X &lt; Max.X, Min.Y &lt;= Y &lt; Max.Y.
It is well-formed if Min.X &lt;= Max.X and likewise for Y. Points are always
well-formed. A rectangle&apos;s methods always return well-formed outputs for
well-formed inputs.
<p>A Rectangle is also an <a href="#Image">Image</a> whose bounds are the rectangle itself. At
returns color.Opaque for points in the rectangle and color.Transparent
otherwise.

			<pre>type Rectangle struct {
<span id="Rectangle.Min"></span>    Min, Max <a href="#Point">Point</a>
}
</pre>

			

			
				<p>ZR is the zero <a href="#Rectangle">Rectangle</a>.
<p>Deprecated: Use a literal <a href="#Rectangle">image.Rectangle</a> instead.

				<pre>var <span id="ZR">ZR</span> <a href="#Rectangle">Rectangle</a></pre>
			

			
			
			

			
				
				<h3 id="Rect">func <a href="/src/image/geom.go?s=6586:6625#L265">Rect</a>
					<a class="permalink" href="#Rect">&#xb6;</a>
					
					
				</h3>
				<pre>func Rect(x0, y0, x1, y1 <a href="/pkg/builtin/#int">int</a>) <a href="#Rectangle">Rectangle</a></pre>
				<p>Rect is shorthand for <a href="#Rectangle">Rectangle</a>{Pt(x0, y0), <a href="#Pt">Pt</a>(x1, y1)}. The returned
rectangle has minimum and maximum coordinates swapped if necessary so that
it is well-formed.

				
				
			

			
				
				<h3 id="Rectangle.Add">func (Rectangle) <a href="/src/image/geom.go?s=2616:2657#L106">Add</a>
					<a class="permalink" href="#Rectangle.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) Add(p <a href="#Point">Point</a>) <a href="#Rectangle">Rectangle</a></pre>
				<p>Add returns the rectangle r translated by p.

				
				
				
			
				
				<h3 id="Rectangle.At">func (Rectangle) <a href="/src/image/geom.go?s=5740:5783#L232">At</a>
					<a class="permalink" href="#Rectangle.At">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a></pre>
				<p>At implements the <a href="#Image">Image</a> interface.

				
				
				
			
				
				<h3 id="Rectangle.Bounds">func (Rectangle) <a href="/src/image/geom.go?s=6124:6161#L248">Bounds</a>
					<a class="permalink" href="#Rectangle.Bounds">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
				<p>Bounds implements the <a href="#Image">Image</a> interface.

				
				
				
			
				
				<h3 id="Rectangle.Canon">func (Rectangle) <a href="/src/image/geom.go?s=5518:5554#L221">Canon</a>
					<a class="permalink" href="#Rectangle.Canon">&#xb6;</a>
					
					
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) Canon() <a href="#Rectangle">Rectangle</a></pre>
				<p>Canon returns the canonical version of r. The returned rectangle has minimum
and maximum coordinates swapped if necessary so that it is well-formed.

				
				
				
			
				
				<h3 id="Rectangle.ColorModel">func (Rectangle) <a href="/src/image/geom.go?s=6225:6268#L253">ColorModel</a>
					<a class="permalink" href="#Rectangle.ColorModel">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) ColorModel() <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a></pre>
				<p>ColorModel implements the <a href="#Image">Image</a> interface.

				
				
				
			
				
				<h3 id="Rectangle.Dx">func (Rectangle) <a href="/src/image/geom.go?s=2289:2316#L88">Dx</a>
					<a class="permalink" href="#Rectangle.Dx">&#xb6;</a>
					
					
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) Dx() <a href="/pkg/builtin/#int">int</a></pre>
				<p>Dx returns r&apos;s width.

				
				
				
			
				
				<h3 id="Rectangle.Dy">func (Rectangle) <a href="/src/image/geom.go?s=2374:2401#L93">Dy</a>
					<a class="permalink" href="#Rectangle.Dy">&#xb6;</a>
					
					
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) Dy() <a href="/pkg/builtin/#int">int</a></pre>
				<p>Dy returns r&apos;s height.

				
				
				
			
				
				<h3 id="Rectangle.Empty">func (Rectangle) <a href="/src/image/geom.go?s=4519:4550#L191">Empty</a>
					<a class="permalink" href="#Rectangle.Empty">&#xb6;</a>
					
					
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) Empty() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Empty reports whether the rectangle contains no points.

				
				
				
			
				
				<h3 id="Rectangle.Eq">func (Rectangle) <a href="/src/image/geom.go?s=4713:4752#L197">Eq</a>
					<a class="permalink" href="#Rectangle.Eq">&#xb6;</a>
					
					
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) Eq(s <a href="#Rectangle">Rectangle</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Eq reports whether r and s contain the same set of points. All empty
rectangles are considered equal.

				
				
				
			
				
				<h3 id="Rectangle.In">func (Rectangle) <a href="/src/image/geom.go?s=5086:5125#L209">In</a>
					<a class="permalink" href="#Rectangle.In">&#xb6;</a>
					
					
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) In(s <a href="#Rectangle">Rectangle</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>In reports whether every point in r is in s.

				
				
				
			
				
				<h3 id="Rectangle.Inset">func (Rectangle) <a href="/src/image/geom.go?s=3141:3182#L124">Inset</a>
					<a class="permalink" href="#Rectangle.Inset">&#xb6;</a>
					
					
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) Inset(n <a href="/pkg/builtin/#int">int</a>) <a href="#Rectangle">Rectangle</a></pre>
				<p>Inset returns the rectangle r inset by n, which may be negative. If either
of r&apos;s dimensions is less than 2*n then an empty rectangle near the center
of r will be returned.

				
				
				
			
				
				<h3 id="Rectangle.Intersect">func (Rectangle) <a href="/src/image/geom.go?s=3586:3637#L144">Intersect</a>
					<a class="permalink" href="#Rectangle.Intersect">&#xb6;</a>
					
					
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) Intersect(s <a href="#Rectangle">Rectangle</a>) <a href="#Rectangle">Rectangle</a></pre>
				<p>Intersect returns the largest rectangle contained by both r and s. If the
two rectangles do not overlap then the zero rectangle will be returned.

				
				
				
			
				
				<h3 id="Rectangle.Overlaps">func (Rectangle) <a href="/src/image/geom.go?s=4866:4911#L202">Overlaps</a>
					<a class="permalink" href="#Rectangle.Overlaps">&#xb6;</a>
					
					
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) Overlaps(s <a href="#Rectangle">Rectangle</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Overlaps reports whether r and s have a non-empty intersection.

				
				
				
			
				
				<h3 id="Rectangle.RGBA64At">func (Rectangle) <a href="/src/image/geom.go?s=5918:5968#L240">RGBA64At</a>
					<a class="permalink" href="#Rectangle.RGBA64At">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) RGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a></pre>
				<p>RGBA64At implements the <a href="#RGBA64Image">RGBA64Image</a> interface.

				
				
				
			
				
				<h3 id="Rectangle.Size">func (Rectangle) <a href="/src/image/geom.go?s=2471:2502#L98">Size</a>
					<a class="permalink" href="#Rectangle.Size">&#xb6;</a>
					
					
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) Size() <a href="#Point">Point</a></pre>
				<p>Size returns r&apos;s width and height.

				
				
				
			
				
				<h3 id="Rectangle.String">func (Rectangle) <a href="/src/image/geom.go?s=2178:2212#L83">String</a>
					<a class="permalink" href="#Rectangle.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>String returns a string representation of r like &quot;(3,4)-(6,5)&quot;.

				
				
				
			
				
				<h3 id="Rectangle.Sub">func (Rectangle) <a href="/src/image/geom.go?s=2812:2853#L114">Sub</a>
					<a class="permalink" href="#Rectangle.Sub">&#xb6;</a>
					
					
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) Sub(p <a href="#Point">Point</a>) <a href="#Rectangle">Rectangle</a></pre>
				<p>Sub returns the rectangle r translated by -p.

				
				
				
			
				
				<h3 id="Rectangle.Union">func (Rectangle) <a href="/src/image/geom.go?s=4149:4196#L168">Union</a>
					<a class="permalink" href="#Rectangle.Union">&#xb6;</a>
					
					
				</h3>
				<pre>func (r <a href="#Rectangle">Rectangle</a>) Union(s <a href="#Rectangle">Rectangle</a>) <a href="#Rectangle">Rectangle</a></pre>
				<p>Union returns the smallest rectangle that contains both r and s.

				
				
				
			
		
			
			
			<h2 id="Uniform">type <a href="/src/image/names.go?s=676:714#L14">Uniform</a>
				<a class="permalink" href="#Uniform">&#xb6;</a>
				
				
			</h2>
			<p>Uniform is an infinite-sized <a href="#Image">Image</a> of uniform color.
It implements the <a href="/image/color#Color">color.Color</a>, <a href="/image/color#Model">color.Model</a>, and <a href="#Image">Image</a> interfaces.

			<pre>type Uniform struct {
<span id="Uniform.C"></span>    C <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewUniform">func <a href="/src/image/names.go?s=1431:1470#L46">NewUniform</a>
					<a class="permalink" href="#NewUniform">&#xb6;</a>
					
					
				</h3>
				<pre>func NewUniform(c <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a>) *<a href="#Uniform">Uniform</a></pre>
				<p>NewUniform returns a new <a href="#Uniform">Uniform</a> image of the given color.

				
				
			

			
				
				<h3 id="Uniform.At">func (*Uniform) <a href="/src/image/names.go?s=1006:1048#L32">At</a>
					<a class="permalink" href="#Uniform.At">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Uniform">Uniform</a>) At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a></pre>
				
				
				
				
			
				
				<h3 id="Uniform.Bounds">func (*Uniform) <a href="/src/image/names.go?s=911:947#L30">Bounds</a>
					<a class="permalink" href="#Uniform.Bounds">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Uniform">Uniform</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
				
				
				
				
			
				
				<h3 id="Uniform.ColorModel">func (*Uniform) <a href="/src/image/names.go?s=785:827#L22">ColorModel</a>
					<a class="permalink" href="#Uniform.ColorModel">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Uniform">Uniform</a>) ColorModel() <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a></pre>
				
				
				
				
			
				
				<h3 id="Uniform.Convert">func (*Uniform) <a href="/src/image/names.go?s=843:893#L26">Convert</a>
					<a class="permalink" href="#Uniform.Convert">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Uniform">Uniform</a>) Convert(<a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a></pre>
				
				
				
				
			
				
				<h3 id="Uniform.Opaque">func (*Uniform) <a href="/src/image/names.go?s=1284:1315#L40">Opaque</a>
					<a class="permalink" href="#Uniform.Opaque">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Uniform">Uniform</a>) Opaque() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Opaque scans the entire image and reports whether it is fully opaque.

				
				
				
			
				
				<h3 id="Uniform.RGBA">func (*Uniform) <a href="/src/image/names.go?s=716:760#L18">RGBA</a>
					<a class="permalink" href="#Uniform.RGBA">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Uniform">Uniform</a>) RGBA() (r, g, b, a <a href="/pkg/builtin/#uint32">uint32</a>)</pre>
				
				
				
				
			
				
				<h3 id="Uniform.RGBA64At">func (*Uniform) <a href="/src/image/names.go?s=1065:1114#L34">RGBA64At</a>
					<a class="permalink" href="#Uniform.RGBA64At">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (c *<a href="#Uniform">Uniform</a>) RGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="YCbCr">type <a href="/src/image/ycbcr.go?s=1833:1980#L45">YCbCr</a>
				<a class="permalink" href="#YCbCr">&#xb6;</a>
				
				
			</h2>
			<p>YCbCr is an in-memory image of Y&apos;CbCr colors. There is one Y sample per
pixel, but each Cb and Cr sample can span one or more pixels.
YStride is the Y slice index delta between vertically adjacent pixels.
CStride is the Cb and Cr slice index delta between vertically adjacent pixels
that map to separate chroma samples.
It is not an absolute requirement, but YStride and len(Y) are typically
multiples of 8, and:
<pre>For 4:4:4, CStride == YStride/1 &amp;&amp; len(Cb) == len(Cr) == len(Y)/1.
For 4:2:2, CStride == YStride/2 &amp;&amp; len(Cb) == len(Cr) == len(Y)/2.
For 4:2:0, CStride == YStride/2 &amp;&amp; len(Cb) == len(Cr) == len(Y)/4.
For 4:4:0, CStride == YStride/1 &amp;&amp; len(Cb) == len(Cr) == len(Y)/2.
For 4:1:1, CStride == YStride/4 &amp;&amp; len(Cb) == len(Cr) == len(Y)/4.
For 4:1:0, CStride == YStride/4 &amp;&amp; len(Cb) == len(Cr) == len(Y)/8.
</pre>

			<pre>type YCbCr struct {
<span id="YCbCr.Y"></span>    Y, Cb, Cr      []<a href="/pkg/builtin/#uint8">uint8</a>
<span id="YCbCr.YStride"></span>    YStride        <a href="/pkg/builtin/#int">int</a>
<span id="YCbCr.CStride"></span>    CStride        <a href="/pkg/builtin/#int">int</a>
<span id="YCbCr.SubsampleRatio"></span>    SubsampleRatio <a href="#YCbCrSubsampleRatio">YCbCrSubsampleRatio</a>
<span id="YCbCr.Rect"></span>    Rect           <a href="#Rectangle">Rectangle</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewYCbCr">func <a href="/src/image/ycbcr.go?s=5031:5100#L165">NewYCbCr</a>
					<a class="permalink" href="#NewYCbCr">&#xb6;</a>
					
					
				</h3>
				<pre>func NewYCbCr(r <a href="#Rectangle">Rectangle</a>, subsampleRatio <a href="#YCbCrSubsampleRatio">YCbCrSubsampleRatio</a>) *<a href="#YCbCr">YCbCr</a></pre>
				<p>NewYCbCr returns a new YCbCr image with the given bounds and subsample
ratio.

				
				
			

			
				
				<h3 id="YCbCr.At">func (*YCbCr) <a href="/src/image/ycbcr.go?s=2108:2148#L61">At</a>
					<a class="permalink" href="#YCbCr.At">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#YCbCr">YCbCr</a>) At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Color">Color</a></pre>
				
				
				
				
			
				
				<h3 id="YCbCr.Bounds">func (*YCbCr) <a href="/src/image/ycbcr.go?s=2053:2087#L57">Bounds</a>
					<a class="permalink" href="#YCbCr.Bounds">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#YCbCr">YCbCr</a>) Bounds() <a href="#Rectangle">Rectangle</a></pre>
				
				
				
				
			
				
				<h3 id="YCbCr.COffset">func (*YCbCr) <a href="/src/image/ycbcr.go?s=2852:2889#L91">COffset</a>
					<a class="permalink" href="#YCbCr.COffset">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#YCbCr">YCbCr</a>) COffset(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>COffset returns the index of the first element of Cb or Cr that corresponds
to the pixel at (x, y).

				
				
				
			
				
				<h3 id="YCbCr.ColorModel">func (*YCbCr) <a href="/src/image/ycbcr.go?s=1982:2022#L53">ColorModel</a>
					<a class="permalink" href="#YCbCr.ColorModel">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#YCbCr">YCbCr</a>) ColorModel() <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#Model">Model</a></pre>
				
				
				
				
			
				
				<h3 id="YCbCr.Opaque">func (*YCbCr) <a href="/src/image/ycbcr.go?s=4281:4310#L133">Opaque</a>
					<a class="permalink" href="#YCbCr.Opaque">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#YCbCr">YCbCr</a>) Opaque() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="YCbCr.RGBA64At">func (*YCbCr) <a href="/src/image/ycbcr.go?s=2178:2225#L65">RGBA64At</a>
					<a class="permalink" href="#YCbCr.RGBA64At">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (p *<a href="#YCbCr">YCbCr</a>) RGBA64At(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#RGBA64">RGBA64</a></pre>
				
				
				
				
			
				
				<h3 id="YCbCr.SubImage">func (*YCbCr) <a href="/src/image/ycbcr.go?s=3627:3670#L110">SubImage</a>
					<a class="permalink" href="#YCbCr.SubImage">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#YCbCr">YCbCr</a>) SubImage(r <a href="#Rectangle">Rectangle</a>) <a href="#Image">Image</a></pre>
				<p>SubImage returns an image representing the portion of the image p visible
through r. The returned value shares pixels with the original image.

				
				
				
			
				
				<h3 id="YCbCr.YCbCrAt">func (*YCbCr) <a href="/src/image/ycbcr.go?s=2334:2379#L70">YCbCrAt</a>
					<a class="permalink" href="#YCbCr.YCbCrAt">&#xb6;</a>
					
					<span title="Added in Go 1.4">1.4</span>
				</h3>
				<pre>func (p *<a href="#YCbCr">YCbCr</a>) YCbCrAt(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/image/color/">color</a>.<a href="/pkg/image/color/#YCbCr">YCbCr</a></pre>
				
				
				
				
			
				
				<h3 id="YCbCr.YOffset">func (*YCbCr) <a href="/src/image/ycbcr.go?s=2647:2684#L85">YOffset</a>
					<a class="permalink" href="#YCbCr.YOffset">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#YCbCr">YCbCr</a>) YOffset(x, y <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>YOffset returns the index of the first element of Y that corresponds to
the pixel at (x, y).

				
				
				
			
		
			
			
			<h2 id="YCbCrSubsampleRatio">type <a href="/src/image/ycbcr.go?s=278:306#L2">YCbCrSubsampleRatio</a>
				<a class="permalink" href="#YCbCrSubsampleRatio">&#xb6;</a>
				
				
			</h2>
			<p>YCbCrSubsampleRatio is the chroma subsample ratio used in a YCbCr image.

			<pre>type YCbCrSubsampleRatio <a href="/pkg/builtin/#int">int</a></pre>

			
				
				<pre>const (
    <span id="YCbCrSubsampleRatio444">YCbCrSubsampleRatio444</span> <a href="#YCbCrSubsampleRatio">YCbCrSubsampleRatio</a> = <a href="/pkg/builtin/#iota">iota</a>
    <span id="YCbCrSubsampleRatio422">YCbCrSubsampleRatio422</span>
    <span id="YCbCrSubsampleRatio420">YCbCrSubsampleRatio420</span>
    <span id="YCbCrSubsampleRatio440">YCbCrSubsampleRatio440</span>
    <span id="YCbCrSubsampleRatio411">YCbCrSubsampleRatio411</span>
    <span id="YCbCrSubsampleRatio410">YCbCrSubsampleRatio410</span>
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="YCbCrSubsampleRatio.String">func (YCbCrSubsampleRatio) <a href="/src/image/ycbcr.go?s=490:534#L13">String</a>
					<a class="permalink" href="#YCbCrSubsampleRatio.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s <a href="#YCbCrSubsampleRatio">YCbCrSubsampleRatio</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="..">..</a></td>
			</tr>
			

			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="color/">color</a>
					</td>
				
					<td class="pkg-synopsis">
						Package color implements a basic color library.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="color/palette/">palette</a>
					</td>
				
					<td class="pkg-synopsis">
						Package palette provides standard color palettes.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="draw/">draw</a>
					</td>
				
					<td class="pkg-synopsis">
						Package draw provides image composition functions.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="gif/">gif</a>
					</td>
				
					<td class="pkg-synopsis">
						Package gif implements a GIF image decoder and encoder.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="jpeg/">jpeg</a>
					</td>
				
					<td class="pkg-synopsis">
						Package jpeg implements a JPEG image decoder and encoder.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="png/">png</a>
					</td>
				
					<td class="pkg-synopsis">
						Package png implements a PNG image decoder and encoder.
					</td>
				</tr>
			
		</table>
	</div>



<div id="footer">
Build version go1.23.0.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
