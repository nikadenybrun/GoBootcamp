<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>ecdsa - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.23.0";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package ecdsa
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "crypto/ecdsa"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as
defined in FIPS 186-4 and SEC 1, Version 2.0.
<p>Signatures generated by this package are not deterministic, but entropy is
mixed with the private key and the message, achieving the same level of
security in case of randomness source failure.
<p>Operations involving private keys are implemented using constant-time
algorithms, as long as an <a href="/crypto/elliptic#Curve">elliptic.Curve</a> returned by <a href="/crypto/elliptic#P224">elliptic.P224</a>,
<a href="/crypto/elliptic#P256">elliptic.P256</a>, <a href="/crypto/elliptic#P384">elliptic.P384</a>, or <a href="/crypto/elliptic#P521">elliptic.P521</a> is used.

				<div id="example_" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
privateKey, err := ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
if err != nil {
    panic(err)
}

msg := &#34;hello, world&#34;
hash := sha256.Sum256([]byte(msg))

sig, err := ecdsa.SignASN1(rand.Reader, privateKey, hash[:])
if err != nil {
    panic(err)
}
fmt.Printf(&#34;signature: %x\n&#34;, sig)

valid := ecdsa.VerifyASN1(&amp;privateKey.PublicKey, hash[:], sig)
fmt.Println(&#34;signature verified:&#34;, valid)
</pre>
			
		
	</div>
</div>

			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#Sign">func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err error)</a></dd>
			
				
				<dd><a href="#SignASN1">func SignASN1(rand io.Reader, priv *PrivateKey, hash []byte) ([]byte, error)</a></dd>
			
				
				<dd><a href="#Verify">func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool</a></dd>
			
				
				<dd><a href="#VerifyASN1">func VerifyASN1(pub *PublicKey, hash, sig []byte) bool</a></dd>
			
			
				
				<dd><a href="#PrivateKey">type PrivateKey</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#GenerateKey">func GenerateKey(c elliptic.Curve, rand io.Reader) (*PrivateKey, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PrivateKey.ECDH">func (k *PrivateKey) ECDH() (*ecdh.PrivateKey, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PrivateKey.Equal">func (priv *PrivateKey) Equal(x crypto.PrivateKey) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PrivateKey.Public">func (priv *PrivateKey) Public() crypto.PublicKey</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PrivateKey.Sign">func (priv *PrivateKey) Sign(rand io.Reader, digest []byte, opts crypto.SignerOpts) ([]byte, error)</a></dd>
				
			
				
				<dd><a href="#PublicKey">type PublicKey</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PublicKey.ECDH">func (k *PublicKey) ECDH() (*ecdh.PublicKey, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PublicKey.Equal">func (pub *PublicKey) Equal(x crypto.PublicKey) bool</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="#example_">Package</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/crypto/ecdsa/ecdsa.go">ecdsa.go</a>
			
				<a href="/src/crypto/ecdsa/ecdsa_legacy.go">ecdsa_legacy.go</a>
			
				<a href="/src/crypto/ecdsa/ecdsa_noasm.go">ecdsa_noasm.go</a>
			
				<a href="/src/crypto/ecdsa/notboring.go">notboring.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
		
			
			
			<h2 id="Sign">func <a href="/src/crypto/ecdsa/ecdsa_legacy.go?s=1695:1778#L48">Sign</a>
				<a class="permalink" href="#Sign">&#xb6;</a>
				
				
			</h2>
			<pre>func Sign(rand <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>, priv *<a href="#PrivateKey">PrivateKey</a>, hash []<a href="/pkg/builtin/#byte">byte</a>) (r, s *<a href="/pkg/math/big/">big</a>.<a href="/pkg/math/big/#Int">Int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>Sign signs a hash (which should be the result of hashing a larger message)
using the private key, priv. If the hash is longer than the bit-length of the
private key&apos;s curve order, the hash will be truncated to that length. It
returns the signature as a pair of integers. Most applications should use
<a href="#SignASN1">SignASN1</a> instead of dealing directly with r, s.

			
			

		
			
			
			<h2 id="SignASN1">func <a href="/src/crypto/ecdsa/ecdsa.go?s=9101:9177#L250">SignASN1</a>
				<a class="permalink" href="#SignASN1">&#xb6;</a>
				
				<span title="Added in Go 1.15">1.15</span>
			</h2>
			<pre>func SignASN1(rand <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>, priv *<a href="#PrivateKey">PrivateKey</a>, hash []<a href="/pkg/builtin/#byte">byte</a>) ([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>SignASN1 signs a hash (which should be the result of hashing a larger message)
using the private key, priv. If the hash is longer than the bit-length of the
private key&apos;s curve order, the hash will be truncated to that length. It
returns the ASN.1 encoded signature.
<p>The signature is randomized. Most applications should use <a href="/crypto/rand#Reader">crypto/rand.Reader</a>
as rand. Note that the returned signature does not depend deterministically on
the bytes read from rand, and may change between calls and/or between versions.

			
			

		
			
			
			<h2 id="Verify">func <a href="/src/crypto/ecdsa/ecdsa_legacy.go?s=3243:3303#L111">Verify</a>
				<a class="permalink" href="#Verify">&#xb6;</a>
				
				
			</h2>
			<pre>func Verify(pub *<a href="#PublicKey">PublicKey</a>, hash []<a href="/pkg/builtin/#byte">byte</a>, r, s *<a href="/pkg/math/big/">big</a>.<a href="/pkg/math/big/#Int">Int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>Verify verifies the signature in r, s of hash using the public key, pub. Its
return value records whether the signature is valid. Most applications should
use VerifyASN1 instead of dealing directly with r, s.
<p>The inputs are not considered confidential, and may leak through timing side
channels, or if an attacker has control of part of the inputs.

			
			

		
			
			
			<h2 id="VerifyASN1">func <a href="/src/crypto/ecdsa/ecdsa.go?s=15620:15674#L463">VerifyASN1</a>
				<a class="permalink" href="#VerifyASN1">&#xb6;</a>
				
				<span title="Added in Go 1.15">1.15</span>
			</h2>
			<pre>func VerifyASN1(pub *<a href="#PublicKey">PublicKey</a>, hash, sig []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>VerifyASN1 verifies the ASN.1 encoded signature, sig, of hash using the
public key, pub. Its return value records whether the signature is valid.
<p>The inputs are not considered confidential, and may leak through timing side
channels, or if an attacker has control of part of the inputs.

			
			

		
		
			
			
			<h2 id="PrivateKey">type <a href="/src/crypto/ecdsa/ecdsa.go?s=3214:3263#L81">PrivateKey</a>
				<a class="permalink" href="#PrivateKey">&#xb6;</a>
				
				
			</h2>
			<p>PrivateKey represents an ECDSA private key.

			<pre>type PrivateKey struct {
    <a href="#PublicKey">PublicKey</a>
<span id="PrivateKey.D"></span>    D *<a href="/pkg/math/big/">big</a>.<a href="/pkg/math/big/#Int">Int</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="GenerateKey">func <a href="/src/crypto/ecdsa/ecdsa.go?s=5583:5654#L152">GenerateKey</a>
					<a class="permalink" href="#GenerateKey">&#xb6;</a>
					
					
				</h3>
				<pre>func GenerateKey(c <a href="/pkg/crypto/elliptic/">elliptic</a>.<a href="/pkg/crypto/elliptic/#Curve">Curve</a>, rand <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>) (*<a href="#PrivateKey">PrivateKey</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>GenerateKey generates a new ECDSA private key for the specified curve.
<p>Most applications should use <a href="/crypto/rand#Reader">crypto/rand.Reader</a> as rand. Note that the
returned key does not depend deterministically on the bytes read from rand,
and may change between calls and/or between versions.

				
				
			

			
				
				<h3 id="PrivateKey.ECDH">func (*PrivateKey) <a href="/src/crypto/ecdsa/ecdsa.go?s=3465:3518#L89">ECDH</a>
					<a class="permalink" href="#PrivateKey.ECDH">&#xb6;</a>
					
					<span title="Added in Go 1.20">1.20</span>
				</h3>
				<pre>func (k *<a href="#PrivateKey">PrivateKey</a>) ECDH() (*<a href="/pkg/crypto/ecdh/">ecdh</a>.<a href="/pkg/crypto/ecdh/#PrivateKey">PrivateKey</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ECDH returns k as a <a href="/crypto/ecdh#PrivateKey">ecdh.PrivateKey</a>. It returns an error if the key is
invalid according to the definition of <a href="/crypto/ecdh#Curve.NewPrivateKey">ecdh.Curve.NewPrivateKey</a>, or if the
Curve is not supported by <a href="/crypto/ecdh">crypto/ecdh</a>.

				
				
				
			
				
				<h3 id="PrivateKey.Equal">func (*PrivateKey) <a href="/src/crypto/ecdsa/ecdsa.go?s=4308:4363#L122">Equal</a>
					<a class="permalink" href="#PrivateKey.Equal">&#xb6;</a>
					
					<span title="Added in Go 1.15">1.15</span>
				</h3>
				<pre>func (priv *<a href="#PrivateKey">PrivateKey</a>) Equal(x <a href="/pkg/crypto/">crypto</a>.<a href="/pkg/crypto/#PrivateKey">PrivateKey</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Equal reports whether priv and x have the same value.
<p>See <a href="#PublicKey.Equal">PublicKey.Equal</a> for details on how Curve is compared.

				
				
				
			
				
				<h3 id="PrivateKey.Public">func (*PrivateKey) <a href="/src/crypto/ecdsa/ecdsa.go?s=4106:4155#L115">Public</a>
					<a class="permalink" href="#PrivateKey.Public">&#xb6;</a>
					
					<span title="Added in Go 1.4">1.4</span>
				</h3>
				<pre>func (priv *<a href="#PrivateKey">PrivateKey</a>) Public() <a href="/pkg/crypto/">crypto</a>.<a href="/pkg/crypto/#PublicKey">PublicKey</a></pre>
				<p>Public returns the public key corresponding to priv.

				
				
				
			
				
				<h3 id="PrivateKey.Sign">func (*PrivateKey) <a href="/src/crypto/ecdsa/ecdsa.go?s=5152:5251#L143">Sign</a>
					<a class="permalink" href="#PrivateKey.Sign">&#xb6;</a>
					
					<span title="Added in Go 1.4">1.4</span>
				</h3>
				<pre>func (priv *<a href="#PrivateKey">PrivateKey</a>) Sign(rand <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>, digest []<a href="/pkg/builtin/#byte">byte</a>, opts <a href="/pkg/crypto/">crypto</a>.<a href="/pkg/crypto/#SignerOpts">SignerOpts</a>) ([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Sign signs digest with priv, reading randomness from rand. The opts argument
is not currently used but, in keeping with the crypto.Signer interface,
should be the hash function used to digest the message.
<p>This method implements crypto.Signer, which is an interface to support keys
where the private part is kept in, for example, a hardware module. Common
uses can use the <a href="#SignASN1">SignASN1</a> function in this package directly.

				
				
				
			
		
			
			
			<h2 id="PublicKey">type <a href="/src/crypto/ecdsa/ecdsa.go?s=1674:1730#L40">PublicKey</a>
				<a class="permalink" href="#PublicKey">&#xb6;</a>
				
				
			</h2>
			<p>PublicKey represents an ECDSA public key.

			<pre>type PublicKey struct {
    <a href="/pkg/crypto/elliptic/">elliptic</a>.<a href="/pkg/crypto/elliptic/#Curve">Curve</a>
<span id="PublicKey.X"></span>    X, Y *<a href="/pkg/math/big/">big</a>.<a href="/pkg/math/big/#Int">Int</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="PublicKey.ECDH">func (*PublicKey) <a href="/src/crypto/ecdsa/ecdsa.go?s=2082:2133#L51">ECDH</a>
					<a class="permalink" href="#PublicKey.ECDH">&#xb6;</a>
					
					<span title="Added in Go 1.20">1.20</span>
				</h3>
				<pre>func (k *<a href="#PublicKey">PublicKey</a>) ECDH() (*<a href="/pkg/crypto/ecdh/">ecdh</a>.<a href="/pkg/crypto/ecdh/#PublicKey">PublicKey</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ECDH returns k as a <a href="/crypto/ecdh#PublicKey">ecdh.PublicKey</a>. It returns an error if the key is
invalid according to the definition of <a href="/crypto/ecdh#Curve.NewPublicKey">ecdh.Curve.NewPublicKey</a>, or if the
Curve is not supported by crypto/ecdh.

				
				
				
			
				
				<h3 id="PublicKey.Equal">func (*PublicKey) <a href="/src/crypto/ecdsa/ecdsa.go?s=2709:2761#L67">Equal</a>
					<a class="permalink" href="#PublicKey.Equal">&#xb6;</a>
					
					<span title="Added in Go 1.15">1.15</span>
				</h3>
				<pre>func (pub *<a href="#PublicKey">PublicKey</a>) Equal(x <a href="/pkg/crypto/">crypto</a>.<a href="/pkg/crypto/#PublicKey">PublicKey</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Equal reports whether pub and x have the same value.
<p>Two keys are only considered to have the same value if they have the same Curve value.
Note that for example <a href="/crypto/elliptic#P256">elliptic.P256</a> and elliptic.P256().Params() are different
values, as the latter is a generic not constant time implementation.

				
				
				
			
		
	

	







<div id="footer">
Build version go1.23.0.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
