<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>zip - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.23.0";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package zip
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "archive/zip"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package zip provides support for reading and writing ZIP archives.
<p>See the <a href="https://support.pkware.com/pkzip/appnote">ZIP specification</a> for details.
<p>This package does not support disk spanning.
<p>A note about ZIP64:
<p>To be backwards compatible the FileHeader has both 32 and 64 bit Size
fields. The 64 bit fields will always contain the correct value and
for normal archives both fields will be the same. For files requiring
the ZIP64 format the 32 bit fields will be 0xffffffff and the 64 bit
fields must be used instead.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#RegisterCompressor">func RegisterCompressor(method uint16, comp Compressor)</a></dd>
			
				
				<dd><a href="#RegisterDecompressor">func RegisterDecompressor(method uint16, dcomp Decompressor)</a></dd>
			
			
				
				<dd><a href="#Compressor">type Compressor</a></dd>
				
				
			
				
				<dd><a href="#Decompressor">type Decompressor</a></dd>
				
				
			
				
				<dd><a href="#File">type File</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#File.DataOffset">func (f *File) DataOffset() (offset int64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.Open">func (f *File) Open() (io.ReadCloser, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#File.OpenRaw">func (f *File) OpenRaw() (io.Reader, error)</a></dd>
				
			
				
				<dd><a href="#FileHeader">type FileHeader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FileInfoHeader">func FileInfoHeader(fi fs.FileInfo) (*FileHeader, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FileHeader.FileInfo">func (h *FileHeader) FileInfo() fs.FileInfo</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FileHeader.ModTime">func (h *FileHeader) ModTime() time.Time</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FileHeader.Mode">func (h *FileHeader) Mode() (mode fs.FileMode)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FileHeader.SetModTime">func (h *FileHeader) SetModTime(t time.Time)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FileHeader.SetMode">func (h *FileHeader) SetMode(mode fs.FileMode)</a></dd>
				
			
				
				<dd><a href="#ReadCloser">type ReadCloser</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#OpenReader">func OpenReader(name string) (*ReadCloser, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ReadCloser.Close">func (rc *ReadCloser) Close() error</a></dd>
				
			
				
				<dd><a href="#Reader">type Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReader">func NewReader(r io.ReaderAt, size int64) (*Reader, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Open">func (r *Reader) Open(name string) (fs.File, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.RegisterDecompressor">func (r *Reader) RegisterDecompressor(method uint16, dcomp Decompressor)</a></dd>
				
			
				
				<dd><a href="#Writer">type Writer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewWriter">func NewWriter(w io.Writer) *Writer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.AddFS">func (w *Writer) AddFS(fsys fs.FS) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.Close">func (w *Writer) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.Copy">func (w *Writer) Copy(f *File) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.Create">func (w *Writer) Create(name string) (io.Writer, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.CreateHeader">func (w *Writer) CreateHeader(fh *FileHeader) (io.Writer, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.CreateRaw">func (w *Writer) CreateRaw(fh *FileHeader) (io.Writer, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.Flush">func (w *Writer) Flush() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.RegisterCompressor">func (w *Writer) RegisterCompressor(method uint16, comp Compressor)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.SetComment">func (w *Writer) SetComment(comment string) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Writer.SetOffset">func (w *Writer) SetOffset(n int64)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Reader">Reader</a></dd>
			
			<dd><a class="exampleLink" href="#example_Writer">Writer</a></dd>
			
			<dd><a class="exampleLink" href="#example_Writer_RegisterCompressor">Writer.RegisterCompressor</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/archive/zip/reader.go">reader.go</a>
			
				<a href="/src/archive/zip/register.go">register.go</a>
			
				<a href="/src/archive/zip/struct.go">struct.go</a>
			
				<a href="/src/archive/zip/writer.go">writer.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				<p>Compression methods.

				<pre>const (
    <span id="Store">Store</span>   <a href="/pkg/builtin/#uint16">uint16</a> = 0 <span class="comment">// no compression</span>
    <span id="Deflate">Deflate</span> <a href="/pkg/builtin/#uint16">uint16</a> = 8 <span class="comment">// DEFLATE compressed</span>
)</pre>
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				
				<pre>var (
    <span id="ErrFormat">ErrFormat</span>       = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;zip: not a valid zip file&#34;)
    <span id="ErrAlgorithm">ErrAlgorithm</span>    = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;zip: unsupported compression algorithm&#34;)
    <span id="ErrChecksum">ErrChecksum</span>     = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;zip: checksum error&#34;)
    <span id="ErrInsecurePath">ErrInsecurePath</span> = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;zip: insecure file path&#34;)
)</pre>
			
		
		
			
			
			<h2 id="RegisterCompressor">func <a href="/src/archive/zip/register.go?s=3313:3368#L117">RegisterCompressor</a>
				<a class="permalink" href="#RegisterCompressor">&#xb6;</a>
				
				<span title="Added in Go 1.2">1.2</span>
			</h2>
			<pre>func RegisterCompressor(method <a href="/pkg/builtin/#uint16">uint16</a>, comp <a href="#Compressor">Compressor</a>)</pre>
			<p>RegisterCompressor registers custom compressors for a specified method ID.
The common methods <a href="#Store">Store</a> and <a href="#Deflate">Deflate</a> are built in.

			
			

		
			
			
			<h2 id="RegisterDecompressor">func <a href="/src/archive/zip/register.go?s=3003:3063#L109">RegisterDecompressor</a>
				<a class="permalink" href="#RegisterDecompressor">&#xb6;</a>
				
				<span title="Added in Go 1.2">1.2</span>
			</h2>
			<pre>func RegisterDecompressor(method <a href="/pkg/builtin/#uint16">uint16</a>, dcomp <a href="#Decompressor">Decompressor</a>)</pre>
			<p>RegisterDecompressor allows custom decompressors for a specified method ID.
The common methods <a href="#Store">Store</a> and <a href="#Deflate">Deflate</a> are built in.

			
			

		
		
			
			
			<h2 id="Compressor">type <a href="/src/archive/zip/register.go?s=532:589#L9">Compressor</a>
				<a class="permalink" href="#Compressor">&#xb6;</a>
				
				<span title="Added in Go 1.2">1.2</span>
			</h2>
			<p>A Compressor returns a new compressing writer, writing to w.
The WriteCloser&apos;s Close method must be used to flush pending data to w.
The Compressor itself must be safe to invoke from multiple goroutines
simultaneously, but each returned writer will be used only by
one goroutine at a time.

			<pre>type Compressor func(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>) (<a href="/pkg/io/">io</a>.<a href="/pkg/io/#WriteCloser">WriteCloser</a>, <a href="/pkg/builtin/#error">error</a>)</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Decompressor">type <a href="/src/archive/zip/register.go?s=913:962#L16">Decompressor</a>
				<a class="permalink" href="#Decompressor">&#xb6;</a>
				
				<span title="Added in Go 1.2">1.2</span>
			</h2>
			<p>A Decompressor returns a new decompressing reader, reading from r.
The <a href="/io#ReadCloser">io.ReadCloser</a>&apos;s Close method must be used to release associated resources.
The Decompressor itself must be safe to invoke from multiple goroutines
simultaneously, but each returned reader will be used only by
one goroutine at a time.

			<pre>type Decompressor func(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>) <a href="/pkg/io/">io</a>.<a href="/pkg/io/#ReadCloser">ReadCloser</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="File">type <a href="/src/archive/zip/reader.go?s=1404:1618#L50">File</a>
				<a class="permalink" href="#File">&#xb6;</a>
				
				
			</h2>
			<p>A File is a single file in a ZIP archive.
The file information is in the embedded <a href="#FileHeader">FileHeader</a>.
The file content can be accessed by calling <a href="#File.Open">File.Open</a>.

			<pre>type File struct {
    <a href="#FileHeader">FileHeader</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="File.DataOffset">func (*File) <a href="/src/archive/zip/reader.go?s=6320:6373#L197">DataOffset</a>
					<a class="permalink" href="#File.DataOffset">&#xb6;</a>
					
					<span title="Added in Go 1.2">1.2</span>
				</h3>
				<pre>func (f *<a href="#File">File</a>) DataOffset() (offset <a href="/pkg/builtin/#int64">int64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>DataOffset returns the offset of the file&apos;s possibly-compressed
data, relative to the beginning of the zip file.
<p>Most callers should instead use <a href="#File.Open">File.Open</a>, which transparently
decompresses data and verifies checksums.

				
				
				
			
				
				<h3 id="File.Open">func (*File) <a href="/src/archive/zip/reader.go?s=6610:6654#L207">Open</a>
					<a class="permalink" href="#File.Open">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="#File">File</a>) Open() (<a href="/pkg/io/">io</a>.<a href="/pkg/io/#ReadCloser">ReadCloser</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Open returns a <a href="#ReadCloser">ReadCloser</a> that provides access to the <a href="#File">File</a>&apos;s contents.
Multiple files may be read concurrently.

				
				
				
			
				
				<h3 id="File.OpenRaw">func (*File) <a href="/src/archive/zip/reader.go?s=8083:8126#L250">OpenRaw</a>
					<a class="permalink" href="#File.OpenRaw">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (f *<a href="#File">File</a>) OpenRaw() (<a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>OpenRaw returns a <a href="#Reader">Reader</a> that provides access to the <a href="#File">File</a>&apos;s contents without
decompression.

				
				
				
			
		
			
			
			<h2 id="FileHeader">type <a href="/src/archive/zip/struct.go?s=2837:5476#L76">FileHeader</a>
				<a class="permalink" href="#FileHeader">&#xb6;</a>
				
				
			</h2>
			<p>FileHeader describes a file within a ZIP file.
See the <a href="https://support.pkware.com/pkzip/appnote">ZIP specification</a> for details.

			<pre>type FileHeader struct {
<span id="FileHeader.Name"></span>    <span class="comment">// Name is the name of the file.</span>
    <span class="comment">//</span>
    <span class="comment">// It must be a relative path, not start with a drive letter (such as &#34;C:&#34;),</span>
    <span class="comment">// and must use forward slashes instead of back slashes. A trailing slash</span>
    <span class="comment">// indicates that this file is a directory and should have no data.</span>
    Name <a href="/pkg/builtin/#string">string</a>

<span id="FileHeader.Comment"></span>    <span class="comment">// Comment is any arbitrary user-defined string shorter than 64KiB.</span>
    Comment <a href="/pkg/builtin/#string">string</a>

<span id="FileHeader.NonUTF8"></span>    <span class="comment">// NonUTF8 indicates that Name and Comment are not encoded in UTF-8.</span>
    <span class="comment">//</span>
    <span class="comment">// By specification, the only other encoding permitted should be CP-437,</span>
    <span class="comment">// but historically many ZIP readers interpret Name and Comment as whatever</span>
    <span class="comment">// the system&#39;s local character encoding happens to be.</span>
    <span class="comment">//</span>
    <span class="comment">// This flag should only be set if the user intends to encode a non-portable</span>
    <span class="comment">// ZIP file for a specific localized region. Otherwise, the Writer</span>
    <span class="comment">// automatically sets the ZIP format&#39;s UTF-8 flag for valid UTF-8 strings.</span>
    NonUTF8 <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// Go 1.10</span>

<span id="FileHeader.CreatorVersion"></span>    CreatorVersion <a href="/pkg/builtin/#uint16">uint16</a>
<span id="FileHeader.ReaderVersion"></span>    ReaderVersion  <a href="/pkg/builtin/#uint16">uint16</a>
<span id="FileHeader.Flags"></span>    Flags          <a href="/pkg/builtin/#uint16">uint16</a>

<span id="FileHeader.Method"></span>    <span class="comment">// Method is the compression method. If zero, Store is used.</span>
    Method <a href="/pkg/builtin/#uint16">uint16</a>

<span id="FileHeader.Modified"></span>    <span class="comment">// Modified is the modified time of the file.</span>
    <span class="comment">//</span>
    <span class="comment">// When reading, an extended timestamp is preferred over the legacy MS-DOS</span>
    <span class="comment">// date field, and the offset between the times is used as the timezone.</span>
    <span class="comment">// If only the MS-DOS date is present, the timezone is assumed to be UTC.</span>
    <span class="comment">//</span>
    <span class="comment">// When writing, an extended timestamp (which is timezone-agnostic) is</span>
    <span class="comment">// always emitted. The legacy MS-DOS date field is encoded according to the</span>
    <span class="comment">// location of the Modified time.</span>
    Modified <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a> <span class="comment">// Go 1.10</span>

<span id="FileHeader.ModifiedTime"></span>    <span class="comment">// ModifiedTime is an MS-DOS-encoded time.</span>
    <span class="comment">//</span>
    <span class="comment">// Deprecated: Use Modified instead.</span>
    ModifiedTime <a href="/pkg/builtin/#uint16">uint16</a>

<span id="FileHeader.ModifiedDate"></span>    <span class="comment">// ModifiedDate is an MS-DOS-encoded date.</span>
    <span class="comment">//</span>
    <span class="comment">// Deprecated: Use Modified instead.</span>
    ModifiedDate <a href="/pkg/builtin/#uint16">uint16</a>

<span id="FileHeader.CRC32"></span>    <span class="comment">// CRC32 is the CRC32 checksum of the file content.</span>
    CRC32 <a href="/pkg/builtin/#uint32">uint32</a>

<span id="FileHeader.CompressedSize"></span>    <span class="comment">// CompressedSize is the compressed size of the file in bytes.</span>
    <span class="comment">// If either the uncompressed or compressed size of the file</span>
    <span class="comment">// does not fit in 32 bits, CompressedSize is set to ^uint32(0).</span>
    <span class="comment">//</span>
    <span class="comment">// Deprecated: Use CompressedSize64 instead.</span>
    CompressedSize <a href="/pkg/builtin/#uint32">uint32</a>

<span id="FileHeader.UncompressedSize"></span>    <span class="comment">// UncompressedSize is the uncompressed size of the file in bytes.</span>
    <span class="comment">// If either the uncompressed or compressed size of the file</span>
    <span class="comment">// does not fit in 32 bits, UncompressedSize is set to ^uint32(0).</span>
    <span class="comment">//</span>
    <span class="comment">// Deprecated: Use UncompressedSize64 instead.</span>
    UncompressedSize <a href="/pkg/builtin/#uint32">uint32</a>

<span id="FileHeader.CompressedSize64"></span>    <span class="comment">// CompressedSize64 is the compressed size of the file in bytes.</span>
    CompressedSize64 <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// Go 1.1</span>

<span id="FileHeader.UncompressedSize64"></span>    <span class="comment">// UncompressedSize64 is the uncompressed size of the file in bytes.</span>
    UncompressedSize64 <a href="/pkg/builtin/#uint64">uint64</a> <span class="comment">// Go 1.1</span>

<span id="FileHeader.Extra"></span>    Extra         []<a href="/pkg/builtin/#byte">byte</a>
<span id="FileHeader.ExternalAttrs"></span>    ExternalAttrs <a href="/pkg/builtin/#uint32">uint32</a> <span class="comment">// Meaning depends on CreatorVersion</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="FileInfoHeader">func <a href="/src/archive/zip/struct.go?s=6887:6943#L194">FileInfoHeader</a>
					<a class="permalink" href="#FileInfoHeader">&#xb6;</a>
					
					
				</h3>
				<pre>func FileInfoHeader(fi <a href="/pkg/io/fs/">fs</a>.<a href="/pkg/io/fs/#FileInfo">FileInfo</a>) (*<a href="#FileHeader">FileHeader</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>FileInfoHeader creates a partially-populated <a href="#FileHeader">FileHeader</a> from an
fs.FileInfo.
Because fs.FileInfo&apos;s Name method returns only the base name of
the file it describes, it may be necessary to modify the Name field
of the returned header to provide the full path name of the file.
If compression is desired, callers should set the FileHeader.Method
field; it is unset by default.

				
				
			

			
				
				<h3 id="FileHeader.FileInfo">func (*FileHeader) <a href="/src/archive/zip/struct.go?s=5535:5578#L154">FileInfo</a>
					<a class="permalink" href="#FileHeader.FileInfo">&#xb6;</a>
					
					
				</h3>
				<pre>func (h *<a href="#FileHeader">FileHeader</a>) FileInfo() <a href="/pkg/io/fs/">fs</a>.<a href="/pkg/io/fs/#FileInfo">FileInfo</a></pre>
				<p>FileInfo returns an fs.FileInfo for the <a href="#FileHeader">FileHeader</a>.

				
				
				
			
				
				<h3 id="FileHeader.ModTime">func (*FileHeader) <a href="/src/archive/zip/struct.go?s=9234:9274#L269">ModTime</a>
					<a class="permalink" href="#FileHeader.ModTime">&#xb6;</a>
					
					
				</h3>
				<pre>func (h *<a href="#FileHeader">FileHeader</a>) ModTime() <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a></pre>
				<p>ModTime returns the modification time in UTC using the legacy
[ModifiedDate] and [ModifiedTime] fields.
<p>Deprecated: Use [Modified] instead.

				
				
				
			
				
				<h3 id="FileHeader.Mode">func (*FileHeader) <a href="/src/archive/zip/struct.go?s=10097:10143#L303">Mode</a>
					<a class="permalink" href="#FileHeader.Mode">&#xb6;</a>
					
					
				</h3>
				<pre>func (h *<a href="#FileHeader">FileHeader</a>) Mode() (mode <a href="/pkg/io/fs/">fs</a>.<a href="/pkg/io/fs/#FileMode">FileMode</a>)</pre>
				<p>Mode returns the permission and mode bits for the <a href="#FileHeader">FileHeader</a>.

				
				
				
			
				
				<h3 id="FileHeader.SetModTime">func (*FileHeader) <a href="/src/archive/zip/struct.go?s=9484:9528#L277">SetModTime</a>
					<a class="permalink" href="#FileHeader.SetModTime">&#xb6;</a>
					
					
				</h3>
				<pre>func (h *<a href="#FileHeader">FileHeader</a>) SetModTime(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>)</pre>
				<p>SetModTime sets the [Modified], [ModifiedTime], and [ModifiedDate] fields
to the given time in UTC.
<p>Deprecated: Use [Modified] instead.

				
				
				
			
				
				<h3 id="FileHeader.SetMode">func (*FileHeader) <a href="/src/archive/zip/struct.go?s=10520:10566#L317">SetMode</a>
					<a class="permalink" href="#FileHeader.SetMode">&#xb6;</a>
					
					
				</h3>
				<pre>func (h *<a href="#FileHeader">FileHeader</a>) SetMode(mode <a href="/pkg/io/fs/">fs</a>.<a href="/pkg/io/fs/#FileMode">FileMode</a>)</pre>
				<p>SetMode changes the permission and mode bits for the <a href="#FileHeader">FileHeader</a>.

				
				
				
			
		
			
			
			<h2 id="ReadCloser">type <a href="/src/archive/zip/reader.go?s=1194:1240#L42">ReadCloser</a>
				<a class="permalink" href="#ReadCloser">&#xb6;</a>
				
				
			</h2>
			<p>A ReadCloser is a <a href="#Reader">Reader</a> that must be closed when no longer needed.

			<pre>type ReadCloser struct {
    <a href="#Reader">Reader</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="OpenReader">func <a href="/src/archive/zip/reader.go?s=2147:2196#L67">OpenReader</a>
					<a class="permalink" href="#OpenReader">&#xb6;</a>
					
					
				</h3>
				<pre>func OpenReader(name <a href="/pkg/builtin/#string">string</a>) (*<a href="#ReadCloser">ReadCloser</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>OpenReader will open the Zip file specified by name and return a ReadCloser.
<p>If any file inside the archive uses a non-local name
(as defined by <a href="/path/filepath#IsLocal">filepath.IsLocal</a>) or a name containing backslashes
and the GODEBUG environment variable contains `zipinsecurepath=0`,
OpenReader returns the reader with an ErrInsecurePath error.
A future version of Go may introduce this behavior by default.
Programs that want to accept non-local names can ignore
the ErrInsecurePath error and use the returned reader.

				
				
			

			
				
				<h3 id="ReadCloser.Close">func (*ReadCloser) <a href="/src/archive/zip/reader.go?s=6023:6058#L188">Close</a>
					<a class="permalink" href="#ReadCloser.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (rc *<a href="#ReadCloser">ReadCloser</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Close closes the Zip file, rendering it unusable for I/O.

				
				
				
			
		
			
			
			<h2 id="Reader">type <a href="/src/archive/zip/reader.go?s=699:1119#L25">Reader</a>
				<a class="permalink" href="#Reader">&#xb6;</a>
				
				
			</h2>
			<p>A Reader serves content from a ZIP archive.

			<pre>type Reader struct {
<span id="Reader.File"></span>    File    []*<a href="#File">File</a>
<span id="Reader.Comment"></span>    Comment <a href="/pkg/builtin/#string">string</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Reader" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Open a zip archive for reading.</span>
r, err := zip.OpenReader(&#34;testdata/readme.zip&#34;)
if err != nil {
    log.Fatal(err)
}
defer r.Close()

<span class="comment">// Iterate through the files in the archive,</span>
<span class="comment">// printing some of their contents.</span>
for _, f := range r.File {
    fmt.Printf(&#34;Contents of %s:\n&#34;, f.Name)
    rc, err := f.Open()
    if err != nil {
        log.Fatal(err)
    }
    _, err = io.CopyN(os.Stdout, rc, 68)
    if err != nil {
        log.Fatal(err)
    }
    rc.Close()
    fmt.Println()
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Contents of README:
This is the source code repository for the Go programming language.
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewReader">func <a href="/src/archive/zip/reader.go?s=3041:3099#L96">NewReader</a>
					<a class="permalink" href="#NewReader">&#xb6;</a>
					
					
				</h3>
				<pre>func NewReader(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#ReaderAt">ReaderAt</a>, size <a href="/pkg/builtin/#int64">int64</a>) (*<a href="#Reader">Reader</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>NewReader returns a new <a href="#Reader">Reader</a> reading from r, which is assumed to
have the given size in bytes.
<p>If any file inside the archive uses a non-local name
(as defined by <a href="/path/filepath#IsLocal">filepath.IsLocal</a>) or a name containing backslashes
and the GODEBUG environment variable contains `zipinsecurepath=0`,
NewReader returns the reader with an <a href="#ErrInsecurePath">ErrInsecurePath</a> error.
A future version of Go may introduce this behavior by default.
Programs that want to accept non-local names can ignore
the <a href="#ErrInsecurePath">ErrInsecurePath</a> error and use the returned reader.

				
				
			

			
				
				<h3 id="Reader.Open">func (*Reader) <a href="/src/archive/zip/reader.go?s=26155:26206#L874">Open</a>
					<a class="permalink" href="#Reader.Open">&#xb6;</a>
					
					<span title="Added in Go 1.16">1.16</span>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) Open(name <a href="/pkg/builtin/#string">string</a>) (<a href="/pkg/io/fs/">fs</a>.<a href="/pkg/io/fs/#File">File</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Open opens the named file in the ZIP archive,
using the semantics of fs.FS.Open:
paths are always slash separated, with no
leading / or ../ elements.

				
				
				
			
				
				<h3 id="Reader.RegisterDecompressor">func (*Reader) <a href="/src/archive/zip/reader.go?s=5605:5677#L172">RegisterDecompressor</a>
					<a class="permalink" href="#Reader.RegisterDecompressor">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) RegisterDecompressor(method <a href="/pkg/builtin/#uint16">uint16</a>, dcomp <a href="#Decompressor">Decompressor</a>)</pre>
				<p>RegisterDecompressor registers or overrides a custom decompressor for a
specific method ID. If a decompressor for a given method is not found,
<a href="#Reader">Reader</a> will default to looking up the decompressor at the package level.

				
				
				
			
		
			
			
			<h2 id="Writer">type <a href="/src/archive/zip/writer.go?s=457:790#L15">Writer</a>
				<a class="permalink" href="#Writer">&#xb6;</a>
				
				
			</h2>
			<p>Writer implements a zip file writer.

			<pre>type Writer struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Writer" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Create a buffer to write our archive to.</span>
buf := new(bytes.Buffer)

<span class="comment">// Create a new zip archive.</span>
w := zip.NewWriter(buf)

<span class="comment">// Add some files to the archive.</span>
var files = []struct {
    Name, Body string
}{
    {&#34;readme.txt&#34;, &#34;This archive contains some text files.&#34;},
    {&#34;gopher.txt&#34;, &#34;Gopher names:\nGeorge\nGeoffrey\nGonzo&#34;},
    {&#34;todo.txt&#34;, &#34;Get animal handling licence.\nWrite more examples.&#34;},
}
for _, file := range files {
    f, err := w.Create(file.Name)
    if err != nil {
        log.Fatal(err)
    }
    _, err = f.Write([]byte(file.Body))
    if err != nil {
        log.Fatal(err)
    }
}

<span class="comment">// Make sure to check the error on Close.</span>
err := w.Close()
if err != nil {
    log.Fatal(err)
}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewWriter">func <a href="/src/archive/zip/writer.go?s=918:953#L35">NewWriter</a>
					<a class="permalink" href="#NewWriter">&#xb6;</a>
					
					
				</h3>
				<pre>func NewWriter(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>) *<a href="#Writer">Writer</a></pre>
				<p>NewWriter returns a new <a href="#Writer">Writer</a> writing a zip file to w.

				
				
			

			
				
				<h3 id="Writer.AddFS">func (*Writer) <a href="/src/archive/zip/writer.go?s=16264:16304#L493">AddFS</a>
					<a class="permalink" href="#Writer.AddFS">&#xb6;</a>
					
					<span title="Added in Go 1.22">1.22</span>
				</h3>
				<pre>func (w *<a href="#Writer">Writer</a>) AddFS(fsys <a href="/pkg/io/fs/">fs</a>.<a href="/pkg/io/fs/#FS">FS</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>AddFS adds the files from fs.FS to the archive.
It walks the directory tree starting at the root of the filesystem
adding each file to the zip using deflate while maintaining the directory structure.

				
				
				
			
				
				<h3 id="Writer.Close">func (*Writer) <a href="/src/archive/zip/writer.go?s=2010:2040#L68">Close</a>
					<a class="permalink" href="#Writer.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (w *<a href="#Writer">Writer</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Close finishes writing the zip file by writing the central directory.
It does not close the underlying writer.

				
				
				
			
				
				<h3 id="Writer.Copy">func (*Writer) <a href="/src/archive/zip/writer.go?s=15336:15372#L464">Copy</a>
					<a class="permalink" href="#Writer.Copy">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (w *<a href="#Writer">Writer</a>) Copy(f *<a href="#File">File</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>Copy copies the file f (obtained from a <a href="#Reader">Reader</a>) into w. It copies the raw
form directly bypassing decompression, compression, and validation.

				
				
				
			
				
				<h3 id="Writer.Create">func (*Writer) <a href="/src/archive/zip/writer.go?s=6916:6971#L210">Create</a>
					<a class="permalink" href="#Writer.Create">&#xb6;</a>
					
					
				</h3>
				<pre>func (w *<a href="#Writer">Writer</a>) Create(name <a href="/pkg/builtin/#string">string</a>) (<a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Create adds a file to the zip file using the provided name.
It returns a <a href="#Writer">Writer</a> to which the file contents should be written.
The file contents will be compressed using the <a href="#Deflate">Deflate</a> method.
The name must be a relative path: it must not start with a drive
letter (e.g. C:) or leading slash, and only forward slashes are
allowed. To create a directory instead of a file, add a trailing
slash to the name. Duplicate names will not overwrite previous entries
and are appended to the zip file.
The file&apos;s contents must be written to the <a href="/io#Writer">io.Writer</a> before the next
call to <a href="#Writer.Create">Writer.Create</a>, <a href="#Writer.CreateHeader">Writer.CreateHeader</a>, or <a href="#Writer.Close">Writer.Close</a>.

				
				
				
			
				
				<h3 id="Writer.CreateHeader">func (*Writer) <a href="/src/archive/zip/writer.go?s=8828:8892#L263">CreateHeader</a>
					<a class="permalink" href="#Writer.CreateHeader">&#xb6;</a>
					
					
				</h3>
				<pre>func (w *<a href="#Writer">Writer</a>) CreateHeader(fh *<a href="#FileHeader">FileHeader</a>) (<a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>CreateHeader adds a file to the zip archive using the provided <a href="#FileHeader">FileHeader</a>
for the file metadata. <a href="#Writer">Writer</a> takes ownership of fh and may mutate
its fields. The caller must not modify fh after calling <a href="#Writer.CreateHeader">Writer.CreateHeader</a>.
<p>This returns a <a href="#Writer">Writer</a> to which the file contents should be written.
The file&apos;s contents must be written to the io.Writer before the next
call to <a href="#Writer.Create">Writer.Create</a>, <a href="#Writer.CreateHeader">Writer.CreateHeader</a>, <a href="#Writer.CreateRaw">Writer.CreateRaw</a>, or <a href="#Writer.Close">Writer.Close</a>.

				
				
				
			
				
				<h3 id="Writer.CreateRaw">func (*Writer) <a href="/src/archive/zip/writer.go?s=14575:14636#L431">CreateRaw</a>
					<a class="permalink" href="#Writer.CreateRaw">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (w *<a href="#Writer">Writer</a>) CreateRaw(fh *<a href="#FileHeader">FileHeader</a>) (<a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>CreateRaw adds a file to the zip archive using the provided <a href="#FileHeader">FileHeader</a> and
returns a <a href="#Writer">Writer</a> to which the file contents should be written. The file&apos;s
contents must be written to the io.Writer before the next call to <a href="#Writer.Create">Writer.Create</a>,
<a href="#Writer.CreateHeader">Writer.CreateHeader</a>, <a href="#Writer.CreateRaw">Writer.CreateRaw</a>, or <a href="#Writer.Close">Writer.Close</a>.
<p>In contrast to <a href="#Writer.CreateHeader">Writer.CreateHeader</a>, the bytes passed to Writer are not compressed.
<p>CreateRaw&apos;s argument is stored in w. If the argument is a pointer to the embedded
<a href="#FileHeader">FileHeader</a> in a <a href="#File">File</a> obtained from a <a href="#Reader">Reader</a> created from in-memory data,
then w will refer to all of that memory.

				
				
				
			
				
				<h3 id="Writer.Flush">func (*Writer) <a href="/src/archive/zip/writer.go?s=1533:1563#L52">Flush</a>
					<a class="permalink" href="#Writer.Flush">&#xb6;</a>
					
					<span title="Added in Go 1.4">1.4</span>
				</h3>
				<pre>func (w *<a href="#Writer">Writer</a>) Flush() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Flush flushes any buffered data to the underlying writer.
Calling Flush is not normally necessary; calling Close is sufficient.

				
				
				
			
				
				<h3 id="Writer.RegisterCompressor">func (*Writer) <a href="/src/archive/zip/writer.go?s=15876:15943#L483">RegisterCompressor</a>
					<a class="permalink" href="#Writer.RegisterCompressor">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func (w *<a href="#Writer">Writer</a>) RegisterCompressor(method <a href="/pkg/builtin/#uint16">uint16</a>, comp <a href="#Compressor">Compressor</a>)</pre>
				<p>RegisterCompressor registers or overrides a custom compressor for a specific
method ID. If a compressor for a given method is not found, <a href="#Writer">Writer</a> will
default to looking up the compressor at the package level.

				
				<div id="example_Writer_RegisterCompressor" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Override the default Deflate compressor with a higher compression level.</span>

<span class="comment">// Create a buffer to write our archive to.</span>
buf := new(bytes.Buffer)

<span class="comment">// Create a new zip archive.</span>
w := zip.NewWriter(buf)

<span class="comment">// Register a custom Deflate compressor.</span>
w.RegisterCompressor(zip.Deflate, func(out io.Writer) (io.WriteCloser, error) {
    return flate.NewWriter(out, flate.BestCompression)
})

<span class="comment">// Proceed to add files to w.</span>
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Writer.SetComment">func (*Writer) <a href="/src/archive/zip/writer.go?s=1719:1768#L58">SetComment</a>
					<a class="permalink" href="#Writer.SetComment">&#xb6;</a>
					
					<span title="Added in Go 1.10">1.10</span>
				</h3>
				<pre>func (w *<a href="#Writer">Writer</a>) SetComment(comment <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetComment sets the end-of-central-directory comment field.
It can only be called before <a href="#Writer.Close">Writer.Close</a>.

				
				
				
			
				
				<h3 id="Writer.SetOffset">func (*Writer) <a href="/src/archive/zip/writer.go?s=1261:1296#L43">SetOffset</a>
					<a class="permalink" href="#Writer.SetOffset">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (w *<a href="#Writer">Writer</a>) SetOffset(n <a href="/pkg/builtin/#int64">int64</a>)</pre>
				<p>SetOffset sets the offset of the beginning of the zip data within the
underlying writer. It should be used when the zip data is appended to an
existing file, such as a binary executable.
It must be called before any data is written.

				
				
				
			
		
	

	







<div id="footer">
Build version go1.23.0.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
