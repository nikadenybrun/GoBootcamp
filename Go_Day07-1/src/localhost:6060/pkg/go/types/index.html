<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>types - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.23.0";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package types
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "go/types"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package types declares the data types and implements
the algorithms for type-checking of Go packages. Use
<a href="#Config.Check">Config.Check</a> to invoke the type checker for a package.
Alternatively, create a new type checker with <a href="#NewChecker">NewChecker</a>
and invoke it incrementally by calling <a href="#Checker.Files">Checker.Files</a>.
<p>Type-checking consists of several interdependent phases:
<p>Name resolution maps each identifier (<a href="/go/ast#Ident">ast.Ident</a>) in the program
to the symbol (<a href="#Object">Object</a>) it denotes. Use the Defs and Uses fields
of <a href="#Info">Info</a> or the <a href="#Info.ObjectOf">Info.ObjectOf</a> method to find the symbol for an
identifier, and use the Implicits field of <a href="#Info">Info</a> to find the
symbol for certain other kinds of syntax node.
<p>Constant folding computes the exact constant value
(<a href="/go/constant#Value">constant.Value</a>) of every expression (<a href="/go/ast#Expr">ast.Expr</a>) that is a
compile-time constant. Use the Types field of <a href="#Info">Info</a> to find the
results of constant folding for an expression.
<p>Type deduction computes the type (<a href="#Type">Type</a>) of every expression
(<a href="/go/ast#Expr">ast.Expr</a>) and checks for compliance with the language
specification. Use the Types field of <a href="#Info">Info</a> for the results of
type deduction.
<p>For a tutorial, see <a href="https://go.dev/s/types-tutorial">https://go.dev/s/types-tutorial</a>.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#AssertableTo">func AssertableTo(V *Interface, T Type) bool</a></dd>
			
				
				<dd><a href="#AssignableTo">func AssignableTo(V, T Type) bool</a></dd>
			
				
				<dd><a href="#CheckExpr">func CheckExpr(fset *token.FileSet, pkg *Package, pos token.Pos, expr ast.Expr, info *Info) (err error)</a></dd>
			
				
				<dd><a href="#Comparable">func Comparable(T Type) bool</a></dd>
			
				
				<dd><a href="#ConvertibleTo">func ConvertibleTo(V, T Type) bool</a></dd>
			
				
				<dd><a href="#DefPredeclaredTestFuncs">func DefPredeclaredTestFuncs()</a></dd>
			
				
				<dd><a href="#ExprString">func ExprString(x ast.Expr) string</a></dd>
			
				
				<dd><a href="#Id">func Id(pkg *Package, name string) string</a></dd>
			
				
				<dd><a href="#Identical">func Identical(x, y Type) bool</a></dd>
			
				
				<dd><a href="#IdenticalIgnoreTags">func IdenticalIgnoreTags(x, y Type) bool</a></dd>
			
				
				<dd><a href="#Implements">func Implements(V Type, T *Interface) bool</a></dd>
			
				
				<dd><a href="#IsInterface">func IsInterface(t Type) bool</a></dd>
			
				
				<dd><a href="#ObjectString">func ObjectString(obj Object, qf Qualifier) string</a></dd>
			
				
				<dd><a href="#Satisfies">func Satisfies(V Type, T *Interface) bool</a></dd>
			
				
				<dd><a href="#SelectionString">func SelectionString(s *Selection, qf Qualifier) string</a></dd>
			
				
				<dd><a href="#TypeString">func TypeString(typ Type, qf Qualifier) string</a></dd>
			
				
				<dd><a href="#WriteExpr">func WriteExpr(buf *bytes.Buffer, x ast.Expr)</a></dd>
			
				
				<dd><a href="#WriteSignature">func WriteSignature(buf *bytes.Buffer, sig *Signature, qf Qualifier)</a></dd>
			
				
				<dd><a href="#WriteType">func WriteType(buf *bytes.Buffer, typ Type, qf Qualifier)</a></dd>
			
			
				
				<dd><a href="#Alias">type Alias</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAlias">func NewAlias(obj *TypeName, rhs Type) *Alias</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Alias.Obj">func (a *Alias) Obj() *TypeName</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alias.Origin">func (a *Alias) Origin() *Alias</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alias.Rhs">func (a *Alias) Rhs() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alias.SetTypeParams">func (a *Alias) SetTypeParams(tparams []*TypeParam)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alias.String">func (a *Alias) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alias.TypeArgs">func (a *Alias) TypeArgs() *TypeList</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alias.TypeParams">func (a *Alias) TypeParams() *TypeParamList</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alias.Underlying">func (a *Alias) Underlying() Type</a></dd>
				
			
				
				<dd><a href="#ArgumentError">type ArgumentError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ArgumentError.Error">func (e *ArgumentError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ArgumentError.Unwrap">func (e *ArgumentError) Unwrap() error</a></dd>
				
			
				
				<dd><a href="#Array">type Array</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewArray">func NewArray(elem Type, len int64) *Array</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Array.Elem">func (a *Array) Elem() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Array.Len">func (a *Array) Len() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Array.String">func (a *Array) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Array.Underlying">func (a *Array) Underlying() Type</a></dd>
				
			
				
				<dd><a href="#Basic">type Basic</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Basic.Info">func (b *Basic) Info() BasicInfo</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Basic.Kind">func (b *Basic) Kind() BasicKind</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Basic.Name">func (b *Basic) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Basic.String">func (b *Basic) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Basic.Underlying">func (b *Basic) Underlying() Type</a></dd>
				
			
				
				<dd><a href="#BasicInfo">type BasicInfo</a></dd>
				
				
			
				
				<dd><a href="#BasicKind">type BasicKind</a></dd>
				
				
			
				
				<dd><a href="#Builtin">type Builtin</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.Exported">func (obj *Builtin) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.Id">func (obj *Builtin) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.Name">func (obj *Builtin) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.Parent">func (obj *Builtin) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.Pkg">func (obj *Builtin) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.Pos">func (obj *Builtin) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.String">func (obj *Builtin) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.Type">func (obj *Builtin) Type() Type</a></dd>
				
			
				
				<dd><a href="#Chan">type Chan</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewChan">func NewChan(dir ChanDir, elem Type) *Chan</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Chan.Dir">func (c *Chan) Dir() ChanDir</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Chan.Elem">func (c *Chan) Elem() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Chan.String">func (c *Chan) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Chan.Underlying">func (c *Chan) Underlying() Type</a></dd>
				
			
				
				<dd><a href="#ChanDir">type ChanDir</a></dd>
				
				
			
				
				<dd><a href="#Checker">type Checker</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewChecker">func NewChecker(conf *Config, fset *token.FileSet, pkg *Package, info *Info) *Checker</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Checker.Files">func (check *Checker) Files(files []*ast.File) (err error)</a></dd>
				
			
				
				<dd><a href="#Config">type Config</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Config.Check">func (conf *Config) Check(path string, fset *token.FileSet, files []*ast.File, info *Info) (*Package, error)</a></dd>
				
			
				
				<dd><a href="#Const">type Const</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewConst">func NewConst(pos token.Pos, pkg *Package, name string, typ Type, val constant.Value) *Const</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Exported">func (obj *Const) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Id">func (obj *Const) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Name">func (obj *Const) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Parent">func (obj *Const) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Pkg">func (obj *Const) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Pos">func (obj *Const) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.String">func (obj *Const) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Type">func (obj *Const) Type() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Val">func (obj *Const) Val() constant.Value</a></dd>
				
			
				
				<dd><a href="#Context">type Context</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewContext">func NewContext() *Context</a></dd>
				
				
			
				
				<dd><a href="#Error">type Error</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Error.Error">func (err Error) Error() string</a></dd>
				
			
				
				<dd><a href="#Func">type Func</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MissingMethod">func MissingMethod(V Type, T *Interface, static bool) (method *Func, wrongType bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFunc">func NewFunc(pos token.Pos, pkg *Package, name string, sig *Signature) *Func</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.Exported">func (obj *Func) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.FullName">func (obj *Func) FullName() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.Id">func (obj *Func) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.Name">func (obj *Func) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.Origin">func (obj *Func) Origin() *Func</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.Parent">func (obj *Func) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.Pkg">func (obj *Func) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.Pos">func (obj *Func) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.Scope">func (obj *Func) Scope() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.Signature">func (obj *Func) Signature() *Signature</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.String">func (obj *Func) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Func.Type">func (obj *Func) Type() Type</a></dd>
				
			
				
				<dd><a href="#ImportMode">type ImportMode</a></dd>
				
				
			
				
				<dd><a href="#Importer">type Importer</a></dd>
				
				
			
				
				<dd><a href="#ImporterFrom">type ImporterFrom</a></dd>
				
				
			
				
				<dd><a href="#Info">type Info</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Info.ObjectOf">func (info *Info) ObjectOf(id *ast.Ident) Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Info.PkgNameOf">func (info *Info) PkgNameOf(imp *ast.ImportSpec) *PkgName</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Info.TypeOf">func (info *Info) TypeOf(e ast.Expr) Type</a></dd>
				
			
				
				<dd><a href="#Initializer">type Initializer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Initializer.String">func (init *Initializer) String() string</a></dd>
				
			
				
				<dd><a href="#Instance">type Instance</a></dd>
				
				
			
				
				<dd><a href="#Interface">type Interface</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewInterface">func NewInterface(methods []*Func, embeddeds []*Named) *Interface</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewInterfaceType">func NewInterfaceType(methods []*Func, embeddeds []Type) *Interface</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.Complete">func (t *Interface) Complete() *Interface</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.Embedded">func (t *Interface) Embedded(i int) *Named</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.EmbeddedType">func (t *Interface) EmbeddedType(i int) Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.Empty">func (t *Interface) Empty() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.ExplicitMethod">func (t *Interface) ExplicitMethod(i int) *Func</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.IsComparable">func (t *Interface) IsComparable() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.IsImplicit">func (t *Interface) IsImplicit() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.IsMethodSet">func (t *Interface) IsMethodSet() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.MarkImplicit">func (t *Interface) MarkImplicit()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.Method">func (t *Interface) Method(i int) *Func</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.NumEmbeddeds">func (t *Interface) NumEmbeddeds() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.NumExplicitMethods">func (t *Interface) NumExplicitMethods() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.NumMethods">func (t *Interface) NumMethods() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.String">func (t *Interface) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.Underlying">func (t *Interface) Underlying() Type</a></dd>
				
			
				
				<dd><a href="#Label">type Label</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewLabel">func NewLabel(pos token.Pos, pkg *Package, name string) *Label</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Label.Exported">func (obj *Label) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Label.Id">func (obj *Label) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Label.Name">func (obj *Label) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Label.Parent">func (obj *Label) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Label.Pkg">func (obj *Label) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Label.Pos">func (obj *Label) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Label.String">func (obj *Label) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Label.Type">func (obj *Label) Type() Type</a></dd>
				
			
				
				<dd><a href="#Map">type Map</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMap">func NewMap(key, elem Type) *Map</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Map.Elem">func (m *Map) Elem() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Map.Key">func (m *Map) Key() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Map.String">func (t *Map) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Map.Underlying">func (t *Map) Underlying() Type</a></dd>
				
			
				
				<dd><a href="#MethodSet">type MethodSet</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewMethodSet">func NewMethodSet(T Type) *MethodSet</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MethodSet.At">func (s *MethodSet) At(i int) *Selection</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MethodSet.Len">func (s *MethodSet) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MethodSet.Lookup">func (s *MethodSet) Lookup(pkg *Package, name string) *Selection</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MethodSet.String">func (s *MethodSet) String() string</a></dd>
				
			
				
				<dd><a href="#Named">type Named</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewNamed">func NewNamed(obj *TypeName, underlying Type, methods []*Func) *Named</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Named.AddMethod">func (t *Named) AddMethod(m *Func)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Named.Method">func (t *Named) Method(i int) *Func</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Named.NumMethods">func (t *Named) NumMethods() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Named.Obj">func (t *Named) Obj() *TypeName</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Named.Origin">func (t *Named) Origin() *Named</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Named.SetTypeParams">func (t *Named) SetTypeParams(tparams []*TypeParam)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Named.SetUnderlying">func (t *Named) SetUnderlying(underlying Type)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Named.String">func (t *Named) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Named.TypeArgs">func (t *Named) TypeArgs() *TypeList</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Named.TypeParams">func (t *Named) TypeParams() *TypeParamList</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Named.Underlying">func (t *Named) Underlying() Type</a></dd>
				
			
				
				<dd><a href="#Nil">type Nil</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Nil.Exported">func (obj *Nil) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Nil.Id">func (obj *Nil) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Nil.Name">func (obj *Nil) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Nil.Parent">func (obj *Nil) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Nil.Pkg">func (obj *Nil) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Nil.Pos">func (obj *Nil) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Nil.String">func (obj *Nil) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Nil.Type">func (obj *Nil) Type() Type</a></dd>
				
			
				
				<dd><a href="#Object">type Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LookupFieldOrMethod">func LookupFieldOrMethod(T Type, addressable bool, pkg *Package, name string) (obj Object, index []int, indirect bool)</a></dd>
				
				
			
				
				<dd><a href="#Package">type Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewPackage">func NewPackage(path, name string) *Package</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.Complete">func (pkg *Package) Complete() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.GoVersion">func (pkg *Package) GoVersion() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.Imports">func (pkg *Package) Imports() []*Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.MarkComplete">func (pkg *Package) MarkComplete()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.Name">func (pkg *Package) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.Path">func (pkg *Package) Path() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.Scope">func (pkg *Package) Scope() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.SetImports">func (pkg *Package) SetImports(list []*Package)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.SetName">func (pkg *Package) SetName(name string)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.String">func (pkg *Package) String() string</a></dd>
				
			
				
				<dd><a href="#PkgName">type PkgName</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewPkgName">func NewPkgName(pos token.Pos, pkg *Package, name string, imported *Package) *PkgName</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#PkgName.Exported">func (obj *PkgName) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PkgName.Id">func (obj *PkgName) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PkgName.Imported">func (obj *PkgName) Imported() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PkgName.Name">func (obj *PkgName) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PkgName.Parent">func (obj *PkgName) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PkgName.Pkg">func (obj *PkgName) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PkgName.Pos">func (obj *PkgName) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PkgName.String">func (obj *PkgName) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#PkgName.Type">func (obj *PkgName) Type() Type</a></dd>
				
			
				
				<dd><a href="#Pointer">type Pointer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewPointer">func NewPointer(elem Type) *Pointer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Pointer.Elem">func (p *Pointer) Elem() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Pointer.String">func (p *Pointer) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Pointer.Underlying">func (p *Pointer) Underlying() Type</a></dd>
				
			
				
				<dd><a href="#Qualifier">type Qualifier</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RelativeTo">func RelativeTo(pkg *Package) Qualifier</a></dd>
				
				
			
				
				<dd><a href="#Scope">type Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewScope">func NewScope(parent *Scope, pos, end token.Pos, comment string) *Scope</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.Child">func (s *Scope) Child(i int) *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.Contains">func (s *Scope) Contains(pos token.Pos) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.End">func (s *Scope) End() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.Innermost">func (s *Scope) Innermost(pos token.Pos) *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.Insert">func (s *Scope) Insert(obj Object) Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.Len">func (s *Scope) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.Lookup">func (s *Scope) Lookup(name string) Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.LookupParent">func (s *Scope) LookupParent(name string, pos token.Pos) (*Scope, Object)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.Names">func (s *Scope) Names() []string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.NumChildren">func (s *Scope) NumChildren() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.Parent">func (s *Scope) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.Pos">func (s *Scope) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.String">func (s *Scope) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Scope.WriteTo">func (s *Scope) WriteTo(w io.Writer, n int, recurse bool)</a></dd>
				
			
				
				<dd><a href="#Selection">type Selection</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Selection.Index">func (s *Selection) Index() []int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Selection.Indirect">func (s *Selection) Indirect() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Selection.Kind">func (s *Selection) Kind() SelectionKind</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Selection.Obj">func (s *Selection) Obj() Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Selection.Recv">func (s *Selection) Recv() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Selection.String">func (s *Selection) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Selection.Type">func (s *Selection) Type() Type</a></dd>
				
			
				
				<dd><a href="#SelectionKind">type SelectionKind</a></dd>
				
				
			
				
				<dd><a href="#Signature">type Signature</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSignature">func NewSignature(recv *Var, params, results *Tuple, variadic bool) *Signature</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSignatureType">func NewSignatureType(recv *Var, recvTypeParams, typeParams []*TypeParam, params, results *Tuple, variadic bool) *Signature</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Signature.Params">func (s *Signature) Params() *Tuple</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Signature.Recv">func (s *Signature) Recv() *Var</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Signature.RecvTypeParams">func (s *Signature) RecvTypeParams() *TypeParamList</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Signature.Results">func (s *Signature) Results() *Tuple</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Signature.String">func (t *Signature) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Signature.TypeParams">func (s *Signature) TypeParams() *TypeParamList</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Signature.Underlying">func (t *Signature) Underlying() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Signature.Variadic">func (s *Signature) Variadic() bool</a></dd>
				
			
				
				<dd><a href="#Sizes">type Sizes</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SizesFor">func SizesFor(compiler, arch string) Sizes</a></dd>
				
				
			
				
				<dd><a href="#Slice">type Slice</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewSlice">func NewSlice(elem Type) *Slice</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Slice.Elem">func (s *Slice) Elem() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Slice.String">func (s *Slice) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Slice.Underlying">func (s *Slice) Underlying() Type</a></dd>
				
			
				
				<dd><a href="#StdSizes">type StdSizes</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#StdSizes.Alignof">func (s *StdSizes) Alignof(T Type) (result int64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StdSizes.Offsetsof">func (s *StdSizes) Offsetsof(fields []*Var) []int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#StdSizes.Sizeof">func (s *StdSizes) Sizeof(T Type) int64</a></dd>
				
			
				
				<dd><a href="#Struct">type Struct</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewStruct">func NewStruct(fields []*Var, tags []string) *Struct</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Struct.Field">func (s *Struct) Field(i int) *Var</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Struct.NumFields">func (s *Struct) NumFields() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Struct.String">func (t *Struct) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Struct.Tag">func (s *Struct) Tag(i int) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Struct.Underlying">func (t *Struct) Underlying() Type</a></dd>
				
			
				
				<dd><a href="#Term">type Term</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewTerm">func NewTerm(tilde bool, typ Type) *Term</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Term.String">func (t *Term) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Term.Tilde">func (t *Term) Tilde() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Term.Type">func (t *Term) Type() Type</a></dd>
				
			
				
				<dd><a href="#Tuple">type Tuple</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewTuple">func NewTuple(x ...*Var) *Tuple</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Tuple.At">func (t *Tuple) At(i int) *Var</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Tuple.Len">func (t *Tuple) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Tuple.String">func (t *Tuple) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Tuple.Underlying">func (t *Tuple) Underlying() Type</a></dd>
				
			
				
				<dd><a href="#Type">type Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Default">func Default(t Type) Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Instantiate">func Instantiate(ctxt *Context, orig Type, targs []Type, validate bool) (Type, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Unalias">func Unalias(t Type) Type</a></dd>
				
				
			
				
				<dd><a href="#TypeAndValue">type TypeAndValue</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Eval">func Eval(fset *token.FileSet, pkg *Package, pos token.Pos, expr string) (_ TypeAndValue, err error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAndValue.Addressable">func (tv TypeAndValue) Addressable() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAndValue.Assignable">func (tv TypeAndValue) Assignable() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAndValue.HasOk">func (tv TypeAndValue) HasOk() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAndValue.IsBuiltin">func (tv TypeAndValue) IsBuiltin() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAndValue.IsNil">func (tv TypeAndValue) IsNil() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAndValue.IsType">func (tv TypeAndValue) IsType() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAndValue.IsValue">func (tv TypeAndValue) IsValue() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAndValue.IsVoid">func (tv TypeAndValue) IsVoid() bool</a></dd>
				
			
				
				<dd><a href="#TypeList">type TypeList</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeList.At">func (l *TypeList) At(i int) Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeList.Len">func (l *TypeList) Len() int</a></dd>
				
			
				
				<dd><a href="#TypeName">type TypeName</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewTypeName">func NewTypeName(pos token.Pos, pkg *Package, name string, typ Type) *TypeName</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeName.Exported">func (obj *TypeName) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeName.Id">func (obj *TypeName) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeName.IsAlias">func (obj *TypeName) IsAlias() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeName.Name">func (obj *TypeName) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeName.Parent">func (obj *TypeName) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeName.Pkg">func (obj *TypeName) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeName.Pos">func (obj *TypeName) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeName.String">func (obj *TypeName) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeName.Type">func (obj *TypeName) Type() Type</a></dd>
				
			
				
				<dd><a href="#TypeParam">type TypeParam</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewTypeParam">func NewTypeParam(obj *TypeName, constraint Type) *TypeParam</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeParam.Constraint">func (t *TypeParam) Constraint() Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeParam.Index">func (t *TypeParam) Index() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeParam.Obj">func (t *TypeParam) Obj() *TypeName</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeParam.SetConstraint">func (t *TypeParam) SetConstraint(bound Type)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeParam.String">func (t *TypeParam) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeParam.Underlying">func (t *TypeParam) Underlying() Type</a></dd>
				
			
				
				<dd><a href="#TypeParamList">type TypeParamList</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeParamList.At">func (l *TypeParamList) At(i int) *TypeParam</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeParamList.Len">func (l *TypeParamList) Len() int</a></dd>
				
			
				
				<dd><a href="#Union">type Union</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewUnion">func NewUnion(terms []*Term) *Union</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Union.Len">func (u *Union) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Union.String">func (u *Union) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Union.Term">func (u *Union) Term(i int) *Term</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Union.Underlying">func (u *Union) Underlying() Type</a></dd>
				
			
				
				<dd><a href="#Var">type Var</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewField">func NewField(pos token.Pos, pkg *Package, name string, typ Type, embedded bool) *Var</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewParam">func NewParam(pos token.Pos, pkg *Package, name string, typ Type) *Var</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewVar">func NewVar(pos token.Pos, pkg *Package, name string, typ Type) *Var</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Var.Anonymous">func (obj *Var) Anonymous() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Var.Embedded">func (obj *Var) Embedded() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Var.Exported">func (obj *Var) Exported() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Var.Id">func (obj *Var) Id() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Var.IsField">func (obj *Var) IsField() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Var.Name">func (obj *Var) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Var.Origin">func (obj *Var) Origin() *Var</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Var.Parent">func (obj *Var) Parent() *Scope</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Var.Pkg">func (obj *Var) Pkg() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Var.Pos">func (obj *Var) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Var.String">func (obj *Var) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Var.Type">func (obj *Var) Type() Type</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Info">Info</a></dd>
			
			<dd><a class="exampleLink" href="#example_MethodSet">MethodSet</a></dd>
			
			<dd><a class="exampleLink" href="#example_Scope">Scope</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/go/types/alias.go">alias.go</a>
			
				<a href="/src/go/types/api.go">api.go</a>
			
				<a href="/src/go/types/api_predicates.go">api_predicates.go</a>
			
				<a href="/src/go/types/array.go">array.go</a>
			
				<a href="/src/go/types/assignments.go">assignments.go</a>
			
				<a href="/src/go/types/badlinkname.go">badlinkname.go</a>
			
				<a href="/src/go/types/basic.go">basic.go</a>
			
				<a href="/src/go/types/builtins.go">builtins.go</a>
			
				<a href="/src/go/types/call.go">call.go</a>
			
				<a href="/src/go/types/chan.go">chan.go</a>
			
				<a href="/src/go/types/check.go">check.go</a>
			
				<a href="/src/go/types/const.go">const.go</a>
			
				<a href="/src/go/types/context.go">context.go</a>
			
				<a href="/src/go/types/conversions.go">conversions.go</a>
			
				<a href="/src/go/types/decl.go">decl.go</a>
			
				<a href="/src/go/types/errors.go">errors.go</a>
			
				<a href="/src/go/types/errsupport.go">errsupport.go</a>
			
				<a href="/src/go/types/eval.go">eval.go</a>
			
				<a href="/src/go/types/expr.go">expr.go</a>
			
				<a href="/src/go/types/exprstring.go">exprstring.go</a>
			
				<a href="/src/go/types/format.go">format.go</a>
			
				<a href="/src/go/types/gccgosizes.go">gccgosizes.go</a>
			
				<a href="/src/go/types/gcsizes.go">gcsizes.go</a>
			
				<a href="/src/go/types/generate.go">generate.go</a>
			
				<a href="/src/go/types/index.go">index.go</a>
			
				<a href="/src/go/types/infer.go">infer.go</a>
			
				<a href="/src/go/types/initorder.go">initorder.go</a>
			
				<a href="/src/go/types/instantiate.go">instantiate.go</a>
			
				<a href="/src/go/types/interface.go">interface.go</a>
			
				<a href="/src/go/types/labels.go">labels.go</a>
			
				<a href="/src/go/types/lookup.go">lookup.go</a>
			
				<a href="/src/go/types/map.go">map.go</a>
			
				<a href="/src/go/types/methodset.go">methodset.go</a>
			
				<a href="/src/go/types/mono.go">mono.go</a>
			
				<a href="/src/go/types/named.go">named.go</a>
			
				<a href="/src/go/types/object.go">object.go</a>
			
				<a href="/src/go/types/objset.go">objset.go</a>
			
				<a href="/src/go/types/operand.go">operand.go</a>
			
				<a href="/src/go/types/package.go">package.go</a>
			
				<a href="/src/go/types/pointer.go">pointer.go</a>
			
				<a href="/src/go/types/predicates.go">predicates.go</a>
			
				<a href="/src/go/types/resolver.go">resolver.go</a>
			
				<a href="/src/go/types/return.go">return.go</a>
			
				<a href="/src/go/types/scope.go">scope.go</a>
			
				<a href="/src/go/types/selection.go">selection.go</a>
			
				<a href="/src/go/types/signature.go">signature.go</a>
			
				<a href="/src/go/types/sizes.go">sizes.go</a>
			
				<a href="/src/go/types/slice.go">slice.go</a>
			
				<a href="/src/go/types/stmt.go">stmt.go</a>
			
				<a href="/src/go/types/struct.go">struct.go</a>
			
				<a href="/src/go/types/subst.go">subst.go</a>
			
				<a href="/src/go/types/termlist.go">termlist.go</a>
			
				<a href="/src/go/types/tuple.go">tuple.go</a>
			
				<a href="/src/go/types/type.go">type.go</a>
			
				<a href="/src/go/types/typelists.go">typelists.go</a>
			
				<a href="/src/go/types/typeparam.go">typeparam.go</a>
			
				<a href="/src/go/types/typeset.go">typeset.go</a>
			
				<a href="/src/go/types/typestring.go">typestring.go</a>
			
				<a href="/src/go/types/typeterm.go">typeterm.go</a>
			
				<a href="/src/go/types/typexpr.go">typexpr.go</a>
			
				<a href="/src/go/types/under.go">under.go</a>
			
				<a href="/src/go/types/unify.go">unify.go</a>
			
				<a href="/src/go/types/union.go">union.go</a>
			
				<a href="/src/go/types/universe.go">universe.go</a>
			
				<a href="/src/go/types/util.go">util.go</a>
			
				<a href="/src/go/types/validtype.go">validtype.go</a>
			
				<a href="/src/go/types/version.go">version.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>Typ contains the predeclared *Basic types indexed by their
corresponding BasicKind.
<p>The *Basic type for Typ[Byte] will have the name &quot;uint8&quot;.
Use Universe.Lookup(&quot;byte&quot;).Type() to obtain the specific
alias basic type named &quot;byte&quot; (and analogous for &quot;rune&quot;).

				<pre>var <span id="Typ">Typ</span> = []*<a href="#Basic">Basic</a>{
    <a href="#Invalid">Invalid</a>: {<a href="#Invalid">Invalid</a>, 0, &#34;invalid type&#34;},

    <a href="#Bool">Bool</a>:          {<a href="#Bool">Bool</a>, <a href="#IsBoolean">IsBoolean</a>, &#34;bool&#34;},
    <a href="#Int">Int</a>:           {<a href="#Int">Int</a>, <a href="#IsInteger">IsInteger</a>, &#34;int&#34;},
    <a href="#Int8">Int8</a>:          {<a href="#Int8">Int8</a>, <a href="#IsInteger">IsInteger</a>, &#34;int8&#34;},
    <a href="#Int16">Int16</a>:         {<a href="#Int16">Int16</a>, <a href="#IsInteger">IsInteger</a>, &#34;int16&#34;},
    <a href="#Int32">Int32</a>:         {<a href="#Int32">Int32</a>, <a href="#IsInteger">IsInteger</a>, &#34;int32&#34;},
    <a href="#Int64">Int64</a>:         {<a href="#Int64">Int64</a>, <a href="#IsInteger">IsInteger</a>, &#34;int64&#34;},
    <a href="#Uint">Uint</a>:          {<a href="#Uint">Uint</a>, <a href="#IsInteger">IsInteger</a> | <a href="#IsUnsigned">IsUnsigned</a>, &#34;uint&#34;},
    <a href="#Uint8">Uint8</a>:         {<a href="#Uint8">Uint8</a>, <a href="#IsInteger">IsInteger</a> | <a href="#IsUnsigned">IsUnsigned</a>, &#34;uint8&#34;},
    <a href="#Uint16">Uint16</a>:        {<a href="#Uint16">Uint16</a>, <a href="#IsInteger">IsInteger</a> | <a href="#IsUnsigned">IsUnsigned</a>, &#34;uint16&#34;},
    <a href="#Uint32">Uint32</a>:        {<a href="#Uint32">Uint32</a>, <a href="#IsInteger">IsInteger</a> | <a href="#IsUnsigned">IsUnsigned</a>, &#34;uint32&#34;},
    <a href="#Uint64">Uint64</a>:        {<a href="#Uint64">Uint64</a>, <a href="#IsInteger">IsInteger</a> | <a href="#IsUnsigned">IsUnsigned</a>, &#34;uint64&#34;},
    <a href="#Uintptr">Uintptr</a>:       {<a href="#Uintptr">Uintptr</a>, <a href="#IsInteger">IsInteger</a> | <a href="#IsUnsigned">IsUnsigned</a>, &#34;uintptr&#34;},
    <a href="#Float32">Float32</a>:       {<a href="#Float32">Float32</a>, <a href="#IsFloat">IsFloat</a>, &#34;float32&#34;},
    <a href="#Float64">Float64</a>:       {<a href="#Float64">Float64</a>, <a href="#IsFloat">IsFloat</a>, &#34;float64&#34;},
    <a href="#Complex64">Complex64</a>:     {<a href="#Complex64">Complex64</a>, <a href="#IsComplex">IsComplex</a>, &#34;complex64&#34;},
    <a href="#Complex128">Complex128</a>:    {<a href="#Complex128">Complex128</a>, <a href="#IsComplex">IsComplex</a>, &#34;complex128&#34;},
    <a href="#String">String</a>:        {<a href="#String">String</a>, <a href="#IsString">IsString</a>, &#34;string&#34;},
    <a href="#UnsafePointer">UnsafePointer</a>: {<a href="#UnsafePointer">UnsafePointer</a>, 0, &#34;Pointer&#34;},

    <a href="#UntypedBool">UntypedBool</a>:    {<a href="#UntypedBool">UntypedBool</a>, <a href="#IsBoolean">IsBoolean</a> | <a href="#IsUntyped">IsUntyped</a>, &#34;untyped bool&#34;},
    <a href="#UntypedInt">UntypedInt</a>:     {<a href="#UntypedInt">UntypedInt</a>, <a href="#IsInteger">IsInteger</a> | <a href="#IsUntyped">IsUntyped</a>, &#34;untyped int&#34;},
    <a href="#UntypedRune">UntypedRune</a>:    {<a href="#UntypedRune">UntypedRune</a>, <a href="#IsInteger">IsInteger</a> | <a href="#IsUntyped">IsUntyped</a>, &#34;untyped rune&#34;},
    <a href="#UntypedFloat">UntypedFloat</a>:   {<a href="#UntypedFloat">UntypedFloat</a>, <a href="#IsFloat">IsFloat</a> | <a href="#IsUntyped">IsUntyped</a>, &#34;untyped float&#34;},
    <a href="#UntypedComplex">UntypedComplex</a>: {<a href="#UntypedComplex">UntypedComplex</a>, <a href="#IsComplex">IsComplex</a> | <a href="#IsUntyped">IsUntyped</a>, &#34;untyped complex&#34;},
    <a href="#UntypedString">UntypedString</a>:  {<a href="#UntypedString">UntypedString</a>, <a href="#IsString">IsString</a> | <a href="#IsUntyped">IsUntyped</a>, &#34;untyped string&#34;},
    <a href="#UntypedNil">UntypedNil</a>:     {<a href="#UntypedNil">UntypedNil</a>, <a href="#IsUntyped">IsUntyped</a>, &#34;untyped nil&#34;},
}</pre>
			
		
		
			
			
			<h2 id="AssertableTo">func <a href="/src/go/types/api_predicates.go?s=702:746#L9">AssertableTo</a>
				<a class="permalink" href="#AssertableTo">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func AssertableTo(V *<a href="#Interface">Interface</a>, T <a href="#Type">Type</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>AssertableTo reports whether a value of type V can be asserted to have type T.
<p>The behavior of AssertableTo is unspecified in three cases:
<ul>
<li>if T is Typ[Invalid]
<li>if V is a generalized interface; i.e., an interface that may only be used
as a type constraint in Go code
<li>if T is an uninstantiated generic type
</ul>

			
			

		
			
			
			<h2 id="AssignableTo">func <a href="/src/go/types/api_predicates.go?s=1168:1201#L23">AssignableTo</a>
				<a class="permalink" href="#AssignableTo">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func AssignableTo(V, T <a href="#Type">Type</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>AssignableTo reports whether a value of type V is assignable to a variable
of type T.
<p>The behavior of AssignableTo is unspecified if V or T is Typ[Invalid] or an
uninstantiated generic type.

			
			

		
			
			
			<h2 id="CheckExpr">func <a href="/src/go/types/eval.go?s=1977:2080#L46">CheckExpr</a>
				<a class="permalink" href="#CheckExpr">&#xb6;</a>
				
				<span title="Added in Go 1.13">1.13</span>
			</h2>
			<pre>func CheckExpr(fset *<a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#FileSet">FileSet</a>, pkg *<a href="#Package">Package</a>, pos <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>, expr <a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Expr">Expr</a>, info *<a href="#Info">Info</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>CheckExpr type checks the expression expr as if it had appeared at position
pos of package pkg. <a href="#Type">Type</a> information about the expression is recorded in
info. The expression may be an identifier denoting an uninstantiated generic
function or type.
<p>If pkg == nil, the <a href="#Universe">Universe</a> scope is used and the provided
position pos is ignored. If pkg != nil, and pos is invalid,
the package scope is used. Otherwise, pos must belong to the
package.
<p>An error is returned if pos is not within the package or
if the node cannot be type-checked.
<p>Note: <a href="#Eval">Eval</a> and CheckExpr should not be used instead of running Check
to compute types and values, but in addition to Check, as these
functions ignore the context in which an expression is used (e.g., an
assignment). Thus, top-level untyped constants will return an
untyped type rather than the respective context-specific type.

			
			

		
			
			
			<h2 id="Comparable">func <a href="/src/go/types/predicates.go?s=5832:5860#L141">Comparable</a>
				<a class="permalink" href="#Comparable">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func Comparable(T <a href="#Type">Type</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>Comparable reports whether values of type T are comparable.

			
			

		
			
			
			<h2 id="ConvertibleTo">func <a href="/src/go/types/api_predicates.go?s=1536:1570#L34">ConvertibleTo</a>
				<a class="permalink" href="#ConvertibleTo">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func ConvertibleTo(V, T <a href="#Type">Type</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>ConvertibleTo reports whether a value of type V is convertible to a value of
type T.
<p>The behavior of ConvertibleTo is unspecified if V or T is Typ[Invalid] or an
uninstantiated generic type.

			
			

		
			
			
			<h2 id="DefPredeclaredTestFuncs">func <a href="/src/go/types/universe.go?s=8046:8076#L252">DefPredeclaredTestFuncs</a>
				<a class="permalink" href="#DefPredeclaredTestFuncs">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func DefPredeclaredTestFuncs()</pre>
			<p>DefPredeclaredTestFuncs defines the assert and trace built-ins.
These built-ins are intended for debugging and testing of this
package only.

			
			

		
			
			
			<h2 id="ExprString">func <a href="/src/go/types/exprstring.go?s=472:506#L9">ExprString</a>
				<a class="permalink" href="#ExprString">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func ExprString(x <a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Expr">Expr</a>) <a href="/pkg/builtin/#string">string</a></pre>
			<p>ExprString returns the (possibly shortened) string representation for x.
Shortened representations are suitable for user interfaces but may not
necessarily follow Go syntax.

			
			

		
			
			
			<h2 id="Id">func <a href="/src/go/types/object.go?s=2525:2566#L65">Id</a>
				<a class="permalink" href="#Id">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func Id(pkg *<a href="#Package">Package</a>, name <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#string">string</a></pre>
			<p>Id returns name if it is exported, otherwise it
returns the name qualified with the package path.

			
			

		
			
			
			<h2 id="Identical">func <a href="/src/go/types/api_predicates.go?s=3224:3254#L78">Identical</a>
				<a class="permalink" href="#Identical">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func Identical(x, y <a href="#Type">Type</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>Identical reports whether x and y are identical types.
Receivers of <a href="#Signature">Signature</a> types are ignored.
<p>Predicates such as <a href="#Identical">Identical</a>, <a href="#Implements">Implements</a>, and
<a href="#Satisfies">Satisfies</a> assume that both operands belong to a
consistent collection of symbols (<a href="#Object">Object</a> values).
For example, two <a href="#Named">Named</a> types can be identical only if their
<a href="#Named.Obj">Named.Obj</a> methods return the same <a href="#TypeName">TypeName</a> symbol.
A collection of symbols is consistent if, for each logical
package whose path is P, the creation of those symbols
involved at most one call to <a href="#NewPackage">NewPackage</a>(P, ...).
To ensure consistency, use a single <a href="#Importer">Importer</a> for
all loaded packages and their dependencies.
For more information, see <a href="https://github.com/golang/go/issues/57497">https://github.com/golang/go/issues/57497</a>.

			
			

		
			
			
			<h2 id="IdenticalIgnoreTags">func <a href="/src/go/types/api_predicates.go?s=3442:3482#L85">IdenticalIgnoreTags</a>
				<a class="permalink" href="#IdenticalIgnoreTags">&#xb6;</a>
				
				<span title="Added in Go 1.8">1.8</span>
			</h2>
			<pre>func IdenticalIgnoreTags(x, y <a href="#Type">Type</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored.
Receivers of <a href="#Signature">Signature</a> types are ignored.

			
			

		
			
			
			<h2 id="Implements">func <a href="/src/go/types/api_predicates.go?s=1855:1897#L43">Implements</a>
				<a class="permalink" href="#Implements">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func Implements(V <a href="#Type">Type</a>, T *<a href="#Interface">Interface</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>Implements reports whether type V implements interface T.
<p>The behavior of Implements is unspecified if V is Typ[Invalid] or an uninstantiated
generic type.

			
			

		
			
			
			<h2 id="IsInterface">func <a href="/src/go/types/predicates.go?s=4333:4362#L100">IsInterface</a>
				<a class="permalink" href="#IsInterface">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func IsInterface(t <a href="#Type">Type</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>IsInterface reports whether t is an interface type.

			
			

		
			
			
			<h2 id="ObjectString">func <a href="/src/go/types/object.go?s=19302:19352#L601">ObjectString</a>
				<a class="permalink" href="#ObjectString">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func ObjectString(obj <a href="#Object">Object</a>, qf <a href="#Qualifier">Qualifier</a>) <a href="/pkg/builtin/#string">string</a></pre>
			<p>ObjectString returns the string form of obj.
The Qualifier controls the printing of
package-level objects, and may be nil.

			
			

		
			
			
			<h2 id="Satisfies">func <a href="/src/go/types/api_predicates.go?s=2379:2420#L60">Satisfies</a>
				<a class="permalink" href="#Satisfies">&#xb6;</a>
				
				<span title="Added in Go 1.20">1.20</span>
			</h2>
			<pre>func Satisfies(V <a href="#Type">Type</a>, T *<a href="#Interface">Interface</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>Satisfies reports whether type V satisfies the constraint T.
<p>The behavior of Satisfies is unspecified if V is Typ[Invalid] or an uninstantiated
generic type.

			
			

		
			
			
			<h2 id="SelectionString">func <a href="/src/go/types/selection.go?s=5521:5576#L149">SelectionString</a>
				<a class="permalink" href="#SelectionString">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func SelectionString(s *<a href="#Selection">Selection</a>, qf <a href="#Qualifier">Qualifier</a>) <a href="/pkg/builtin/#string">string</a></pre>
			<p>SelectionString returns the string form of s.
The Qualifier controls the printing of
package-level objects, and may be nil.
<p>Examples:
<pre>&quot;field (T) f int&quot;
&quot;method (T) f(X) Y&quot;
&quot;method expr (T) f(X) Y&quot;
</pre>

			
			

		
			
			
			<h2 id="TypeString">func <a href="/src/go/types/typestring.go?s=1449:1495#L40">TypeString</a>
				<a class="permalink" href="#TypeString">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func TypeString(typ <a href="#Type">Type</a>, qf <a href="#Qualifier">Qualifier</a>) <a href="/pkg/builtin/#string">string</a></pre>
			<p>TypeString returns the string representation of typ.
The <a href="#Qualifier">Qualifier</a> controls the printing of
package-level objects, and may be nil.

			
			

		
			
			
			<h2 id="WriteExpr">func <a href="/src/go/types/exprstring.go?s=763:808#L18">WriteExpr</a>
				<a class="permalink" href="#WriteExpr">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func WriteExpr(buf *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>, x <a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Expr">Expr</a>)</pre>
			<p>WriteExpr writes the (possibly shortened) string representation for x to buf.
Shortened representations are suitable for user interfaces but may not
necessarily follow Go syntax.

			
			

		
			
			
			<h2 id="WriteSignature">func <a href="/src/go/types/typestring.go?s=2006:2074#L56">WriteSignature</a>
				<a class="permalink" href="#WriteSignature">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func WriteSignature(buf *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>, sig *<a href="#Signature">Signature</a>, qf <a href="#Qualifier">Qualifier</a>)</pre>
			<p>WriteSignature writes the representation of the signature sig to buf,
without a leading &quot;func&quot; keyword. The <a href="#Qualifier">Qualifier</a> controls the printing
of package-level objects, and may be nil.

			
			

		
			
			
			<h2 id="WriteType">func <a href="/src/go/types/typestring.go?s=1717:1774#L49">WriteType</a>
				<a class="permalink" href="#WriteType">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func WriteType(buf *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>, typ <a href="#Type">Type</a>, qf <a href="#Qualifier">Qualifier</a>)</pre>
			<p>WriteType writes the string representation of typ to buf.
The <a href="#Qualifier">Qualifier</a> controls the printing of
package-level objects, and may be nil.

			
			

		
		
			
			
			<h2 id="Alias">type <a href="/src/go/types/alias.go?s=677:1059#L11">Alias</a>
				<a class="permalink" href="#Alias">&#xb6;</a>
				
				<span title="Added in Go 1.22">1.22</span>
			</h2>
			<p>An Alias represents an alias type.
Whether or not Alias types are created is controlled by the
gotypesalias setting with the GODEBUG environment variable.
For gotypesalias=1, alias declarations produce an Alias type.
Otherwise, the alias information is only in the type name,
which points directly to the actual (aliased) type.

			<pre>type Alias struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewAlias">func <a href="/src/go/types/alias.go?s=1156:1201#L22">NewAlias</a>
					<a class="permalink" href="#NewAlias">&#xb6;</a>
					
					<span title="Added in Go 1.22">1.22</span>
				</h3>
				<pre>func NewAlias(obj *<a href="#TypeName">TypeName</a>, rhs <a href="#Type">Type</a>) *<a href="#Alias">Alias</a></pre>
				<p>NewAlias creates a new Alias type with the given type name and rhs.
rhs must not be nil.

				
				
			

			
				
				<h3 id="Alias.Obj">func (*Alias) <a href="/src/go/types/alias.go?s=1482:1513#L31">Obj</a>
					<a class="permalink" href="#Alias.Obj">&#xb6;</a>
					
					<span title="Added in Go 1.22">1.22</span>
				</h3>
				<pre>func (a *<a href="#Alias">Alias</a>) Obj() *<a href="#TypeName">TypeName</a></pre>
				<p>Obj returns the type name for the declaration defining the alias type a.
For instantiated types, this is same as the type name of the origin type.

				
				
				
			
				
				<h3 id="Alias.Origin">func (*Alias) <a href="/src/go/types/alias.go?s=2052:2083#L44">Origin</a>
					<a class="permalink" href="#Alias.Origin">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (a *<a href="#Alias">Alias</a>) Origin() *<a href="#Alias">Alias</a></pre>
				<p>Origin returns the generic Alias type of which a is an instance.
If a is not an instance of a generic alias, Origin returns a.

				
				
				
			
				
				<h3 id="Alias.Rhs">func (*Alias) <a href="/src/go/types/alias.go?s=2847:2873#L63">Rhs</a>
					<a class="permalink" href="#Alias.Rhs">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (a *<a href="#Alias">Alias</a>) Rhs() <a href="#Type">Type</a></pre>
				<p>Rhs returns the type R on the right-hand side of an alias
declaration &quot;type A = R&quot;, which may be another alias.

				
				
				
			
				
				<h3 id="Alias.SetTypeParams">func (*Alias) <a href="/src/go/types/alias.go?s=2416:2467#L52">SetTypeParams</a>
					<a class="permalink" href="#Alias.SetTypeParams">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (a *<a href="#Alias">Alias</a>) SetTypeParams(tparams []*<a href="#TypeParam">TypeParam</a>)</pre>
				<p>SetTypeParams sets the type parameters of the alias type a.
The alias a must not have type arguments.

				
				
				
			
				
				<h3 id="Alias.String">func (*Alias) <a href="/src/go/types/alias.go?s=1537:1568#L33">String</a>
					<a class="permalink" href="#Alias.String">&#xb6;</a>
					
					<span title="Added in Go 1.22">1.22</span>
				</h3>
				<pre>func (a *<a href="#Alias">Alias</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Alias.TypeArgs">func (*Alias) <a href="/src/go/types/alias.go?s=2672:2708#L59">TypeArgs</a>
					<a class="permalink" href="#Alias.TypeArgs">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (a *<a href="#Alias">Alias</a>) TypeArgs() *<a href="#TypeList">TypeList</a></pre>
				<p>TypeArgs returns the type arguments used to instantiate the Alias type.
If a is not an instance of a generic alias, the result is nil.

				
				
				
			
				
				<h3 id="Alias.TypeParams">func (*Alias) <a href="/src/go/types/alias.go?s=2242:2285#L48">TypeParams</a>
					<a class="permalink" href="#Alias.TypeParams">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (a *<a href="#Alias">Alias</a>) TypeParams() *<a href="#TypeParamList">TypeParamList</a></pre>
				<p>TypeParams returns the type parameters of the alias type a, or nil.
A generic Alias and its instances have the same type parameters.

				
				
				
			
				
				<h3 id="Alias.Underlying">func (*Alias) <a href="/src/go/types/alias.go?s=1849:1882#L40">Underlying</a>
					<a class="permalink" href="#Alias.Underlying">&#xb6;</a>
					
					<span title="Added in Go 1.22">1.22</span>
				</h3>
				<pre>func (a *<a href="#Alias">Alias</a>) Underlying() <a href="#Type">Type</a></pre>
				<p>Underlying returns the <a href="https://go.dev/ref/spec#Underlying_types.">underlying type</a> of the alias type a, which is the
underlying type of the aliased type. Underlying types are never Named,
TypeParam, or Alias types.

				
				
				
			
		
			
			
			<h2 id="ArgumentError">type <a href="/src/go/types/api.go?s=2596:2649#L59">ArgumentError</a>
				<a class="permalink" href="#ArgumentError">&#xb6;</a>
				
				<span title="Added in Go 1.18">1.18</span>
			</h2>
			<p>An ArgumentError holds an error associated with an argument index.

			<pre>type ArgumentError struct {
<span id="ArgumentError.Index"></span>    Index <a href="/pkg/builtin/#int">int</a>
<span id="ArgumentError.Err"></span>    Err   <a href="/pkg/builtin/#error">error</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ArgumentError.Error">func (*ArgumentError) <a href="/src/go/types/api.go?s=2651:2689#L64">Error</a>
					<a class="permalink" href="#ArgumentError.Error">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (e *<a href="#ArgumentError">ArgumentError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="ArgumentError.Unwrap">func (*ArgumentError) <a href="/src/go/types/api.go?s=2715:2753#L65">Unwrap</a>
					<a class="permalink" href="#ArgumentError.Unwrap">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (e *<a href="#ArgumentError">ArgumentError</a>) Unwrap() <a href="/pkg/builtin/#error">error</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Array">type <a href="/src/go/types/array.go?s=338:382#L1">Array</a>
				<a class="permalink" href="#Array">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>An Array represents an array type.

			<pre>type Array struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewArray">func <a href="/src/go/types/array.go?s=510:552#L8">NewArray</a>
					<a class="permalink" href="#NewArray">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewArray(elem <a href="#Type">Type</a>, len <a href="/pkg/builtin/#int64">int64</a>) *<a href="#Array">Array</a></pre>
				<p>NewArray returns a new array type for the given element type and length.
A negative length indicates an unknown length.

				
				
			

			
				
				<h3 id="Array.Elem">func (*Array) <a href="/src/go/types/array.go?s=769:796#L15">Elem</a>
					<a class="permalink" href="#Array.Elem">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (a *<a href="#Array">Array</a>) Elem() <a href="#Type">Type</a></pre>
				<p>Elem returns element type of array a.

				
				
				
			
				
				<h3 id="Array.Len">func (*Array) <a href="/src/go/types/array.go?s=682:709#L12">Len</a>
					<a class="permalink" href="#Array.Len">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (a *<a href="#Array">Array</a>) Len() <a href="/pkg/builtin/#int64">int64</a></pre>
				<p>Len returns the length of array a.
A negative result indicates an unknown length.

				
				
				
			
				
				<h3 id="Array.String">func (*Array) <a href="/src/go/types/array.go?s=863:894#L18">String</a>
					<a class="permalink" href="#Array.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (a *<a href="#Array">Array</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Array.Underlying">func (*Array) <a href="/src/go/types/array.go?s=816:849#L17">Underlying</a>
					<a class="permalink" href="#Array.Underlying">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (a *<a href="#Array">Array</a>) Underlying() <a href="#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Basic">type <a href="/src/go/types/basic.go?s=1166:1232#L59">Basic</a>
				<a class="permalink" href="#Basic">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Basic represents a basic type.

			<pre>type Basic struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Basic.Info">func (*Basic) <a href="/src/go/types/basic.go?s=1390:1422#L69">Info</a>
					<a class="permalink" href="#Basic.Info">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (b *<a href="#Basic">Basic</a>) Info() <a href="#BasicInfo">BasicInfo</a></pre>
				<p>Info returns information about properties of basic type b.

				
				
				
			
				
				<h3 id="Basic.Kind">func (*Basic) <a href="/src/go/types/basic.go?s=1276:1308#L66">Kind</a>
					<a class="permalink" href="#Basic.Kind">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (b *<a href="#Basic">Basic</a>) Kind() <a href="#BasicKind">BasicKind</a></pre>
				<p>Kind returns the kind of basic type b.

				
				
				
			
				
				<h3 id="Basic.Name">func (*Basic) <a href="/src/go/types/basic.go?s=1484:1513#L72">Name</a>
					<a class="permalink" href="#Basic.Name">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (b *<a href="#Basic">Basic</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Name returns the name of basic type b.

				
				
				
			
				
				<h3 id="Basic.String">func (*Basic) <a href="/src/go/types/basic.go?s=1580:1611#L75">String</a>
					<a class="permalink" href="#Basic.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (b *<a href="#Basic">Basic</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Basic.Underlying">func (*Basic) <a href="/src/go/types/basic.go?s=1533:1566#L74">Underlying</a>
					<a class="permalink" href="#Basic.Underlying">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (b *<a href="#Basic">Basic</a>) Underlying() <a href="#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="BasicInfo">type <a href="/src/go/types/basic.go?s=830:848#L41">BasicInfo</a>
				<a class="permalink" href="#BasicInfo">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>BasicInfo is a set of flags describing properties of a basic type.

			<pre>type BasicInfo <a href="/pkg/builtin/#int">int</a></pre>

			
				<p>Properties of basic types.

				<pre>const (
    <span id="IsBoolean">IsBoolean</span> <a href="#BasicInfo">BasicInfo</a> = 1 &lt;&lt; <a href="/pkg/builtin/#iota">iota</a>
    <span id="IsInteger">IsInteger</span>
    <span id="IsUnsigned">IsUnsigned</span>
    <span id="IsFloat">IsFloat</span>
    <span id="IsComplex">IsComplex</span>
    <span id="IsString">IsString</span>
    <span id="IsUntyped">IsUntyped</span>

    <span id="IsOrdered">IsOrdered</span>   = <a href="#IsInteger">IsInteger</a> | <a href="#IsFloat">IsFloat</a> | <a href="#IsString">IsString</a>
    <span id="IsNumeric">IsNumeric</span>   = <a href="#IsInteger">IsInteger</a> | <a href="#IsFloat">IsFloat</a> | <a href="#IsComplex">IsComplex</a>
    <span id="IsConstType">IsConstType</span> = <a href="#IsBoolean">IsBoolean</a> | <a href="#IsNumeric">IsNumeric</a> | <a href="#IsString">IsString</a>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="BasicKind">type <a href="/src/go/types/basic.go?s=347:365#L1">BasicKind</a>
				<a class="permalink" href="#BasicKind">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>BasicKind describes the kind of basic type.

			<pre>type BasicKind <a href="/pkg/builtin/#int">int</a></pre>

			
				
				<pre>const (
    <span id="Invalid">Invalid</span> <a href="#BasicKind">BasicKind</a> = <a href="/pkg/builtin/#iota">iota</a> <span class="comment">// type is invalid</span>

    <span class="comment">// predeclared types</span>
    <span id="Bool">Bool</span>
    <span id="Int">Int</span>
    <span id="Int8">Int8</span>
    <span id="Int16">Int16</span>
    <span id="Int32">Int32</span>
    <span id="Int64">Int64</span>
    <span id="Uint">Uint</span>
    <span id="Uint8">Uint8</span>
    <span id="Uint16">Uint16</span>
    <span id="Uint32">Uint32</span>
    <span id="Uint64">Uint64</span>
    <span id="Uintptr">Uintptr</span>
    <span id="Float32">Float32</span>
    <span id="Float64">Float64</span>
    <span id="Complex64">Complex64</span>
    <span id="Complex128">Complex128</span>
    <span id="String">String</span>
    <span id="UnsafePointer">UnsafePointer</span>

    <span class="comment">// types for untyped values</span>
    <span id="UntypedBool">UntypedBool</span>
    <span id="UntypedInt">UntypedInt</span>
    <span id="UntypedRune">UntypedRune</span>
    <span id="UntypedFloat">UntypedFloat</span>
    <span id="UntypedComplex">UntypedComplex</span>
    <span id="UntypedString">UntypedString</span>
    <span id="UntypedNil">UntypedNil</span>

    <span class="comment">// aliases</span>
    <span id="Byte">Byte</span> = <a href="#Uint8">Uint8</a>
    <span id="Rune">Rune</span> = <a href="#Int32">Int32</a>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="Builtin">type <a href="/src/go/types/object.go?s=16511:16556#L466">Builtin</a>
				<a class="permalink" href="#Builtin">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Builtin represents a built-in function.
Builtins don&apos;t have a valid type.

			<pre>type Builtin struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Builtin.Exported">func (*Builtin) <a href="/src/go/types/object.go?s=4774:4808#L146">Exported</a>
					<a class="permalink" href="#Builtin.Exported">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Builtin">Builtin</a>) Exported() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Exported reports whether the object is exported (starts with a capital letter).
It doesn&apos;t take into account whether the object is in a local (function) scope
or not.

				
				
				
			
				
				<h3 id="Builtin.Id">func (*Builtin) <a href="/src/go/types/object.go?s=4892:4922#L149">Id</a>
					<a class="permalink" href="#Builtin.Id">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Builtin">Builtin</a>) Id() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Id is a wrapper for Id(obj.Pkg(), obj.Name()).

				
				
				
			
				
				<h3 id="Builtin.Name">func (*Builtin) <a href="/src/go/types/object.go?s=4458:4490#L138">Name</a>
					<a class="permalink" href="#Builtin.Name">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Builtin">Builtin</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Name returns the object&apos;s (package-local, unqualified) name.

				
				
				
			
				
				<h3 id="Builtin.Parent">func (*Builtin) <a href="/src/go/types/object.go?s=4036:4070#L128">Parent</a>
					<a class="permalink" href="#Builtin.Parent">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Builtin">Builtin</a>) Parent() *<a href="#Scope">Scope</a></pre>
				<p>Parent returns the scope in which the object is declared.
The result is nil for methods and struct fields.

				
				
				
			
				
				<h3 id="Builtin.Pkg">func (*Builtin) <a href="/src/go/types/object.go?s=4340:4373#L135">Pkg</a>
					<a class="permalink" href="#Builtin.Pkg">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Builtin">Builtin</a>) Pkg() *<a href="#Package">Package</a></pre>
				<p>Pkg returns the package to which the object belongs.
The result is nil for labels and objects in the Universe scope.

				
				
				
			
				
				<h3 id="Builtin.Pos">func (*Builtin) <a href="/src/go/types/object.go?s=4162:4196#L131">Pos</a>
					<a class="permalink" href="#Builtin.Pos">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Builtin">Builtin</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				<p>Pos returns the declaration position of the object&apos;s identifier.

				
				
				
			
				
				<h3 id="Builtin.String">func (*Builtin) <a href="/src/go/types/object.go?s=19855:19890#L613">String</a>
					<a class="permalink" href="#Builtin.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Builtin">Builtin</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Type">func (*Builtin) <a href="/src/go/types/object.go?s=4547:4577#L141">Type</a>
					<a class="permalink" href="#Builtin.Type">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Builtin">Builtin</a>) Type() <a href="#Type">Type</a></pre>
				<p>Type returns the object&apos;s type.

				
				
				
			
		
			
			
			<h2 id="Chan">type <a href="/src/go/types/chan.go?s=336:381#L1">Chan</a>
				<a class="permalink" href="#Chan">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Chan represents a channel type.

			<pre>type Chan struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewChan">func <a href="/src/go/types/chan.go?s=657:699#L17">NewChan</a>
					<a class="permalink" href="#NewChan">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewChan(dir <a href="#ChanDir">ChanDir</a>, elem <a href="#Type">Type</a>) *<a href="#Chan">Chan</a></pre>
				<p>NewChan returns a new channel type for the given direction and element type.

				
				
			

			
				
				<h3 id="Chan.Dir">func (*Chan) <a href="/src/go/types/chan.go?s=784:812#L22">Dir</a>
					<a class="permalink" href="#Chan.Dir">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (c *<a href="#Chan">Chan</a>) Dir() <a href="#ChanDir">ChanDir</a></pre>
				<p>Dir returns the direction of channel c.

				
				
				
			
				
				<h3 id="Chan.Elem">func (*Chan) <a href="/src/go/types/chan.go?s=878:904#L25">Elem</a>
					<a class="permalink" href="#Chan.Elem">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (c *<a href="#Chan">Chan</a>) Elem() <a href="#Type">Type</a></pre>
				<p>Elem returns the element type of channel c.

				
				
				
			
				
				<h3 id="Chan.String">func (*Chan) <a href="/src/go/types/chan.go?s=970:1000#L28">String</a>
					<a class="permalink" href="#Chan.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (c *<a href="#Chan">Chan</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Chan.Underlying">func (*Chan) <a href="/src/go/types/chan.go?s=924:956#L27">Underlying</a>
					<a class="permalink" href="#Chan.Underlying">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (c *<a href="#Chan">Chan</a>) Underlying() <a href="#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="ChanDir">type <a href="/src/go/types/chan.go?s=433:449#L7">ChanDir</a>
				<a class="permalink" href="#ChanDir">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A ChanDir value indicates a channel direction.

			<pre>type ChanDir <a href="/pkg/builtin/#int">int</a></pre>

			
				<p>The direction of a channel is indicated by one of these constants.

				<pre>const (
    <span id="SendRecv">SendRecv</span> <a href="#ChanDir">ChanDir</a> = <a href="/pkg/builtin/#iota">iota</a>
    <span id="SendOnly">SendOnly</span>
    <span id="RecvOnly">RecvOnly</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="Checker">type <a href="/src/go/types/check.go?s=4949:7812#L122">Checker</a>
				<a class="permalink" href="#Checker">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Checker maintains the state of the type checker.
It must be created with <a href="#NewChecker">NewChecker</a>.

			<pre>type Checker struct {
    *<a href="#Info">Info</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewChecker">func <a href="/src/go/types/check.go?s=10718:10803#L262">NewChecker</a>
					<a class="permalink" href="#NewChecker">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewChecker(conf *<a href="#Config">Config</a>, fset *<a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#FileSet">FileSet</a>, pkg *<a href="#Package">Package</a>, info *<a href="#Info">Info</a>) *<a href="#Checker">Checker</a></pre>
				<p>NewChecker returns a new <a href="#Checker">Checker</a> instance for a given package.
<a href="#Package">Package</a> files may be added incrementally via checker.Files.

				
				
			

			
				
				<h3 id="Checker.Files">func (*Checker) <a href="/src/go/types/check.go?s=15403:15461#L407">Files</a>
					<a class="permalink" href="#Checker.Files">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (check *<a href="#Checker">Checker</a>) Files(files []*<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#File">File</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Files checks the provided files as part of the checker&apos;s package.

				
				
				
			
		
			
			
			<h2 id="Config">type <a href="/src/go/types/api.go?s=4543:7664#L107">Config</a>
				<a class="permalink" href="#Config">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Config specifies the configuration for type checking.
The zero value for Config is a ready-to-use default configuration.

			<pre>type Config struct {
<span id="Config.Context"></span>    <span class="comment">// Context is the context used for resolving global identifiers. If nil, the</span>
    <span class="comment">// type checker will initialize this field with a newly created context.</span>
    Context *<a href="#Context">Context</a> <span class="comment">// Go 1.18</span>

<span id="Config.GoVersion"></span>    <span class="comment">// GoVersion describes the accepted Go language version. The string must</span>
    <span class="comment">// start with a prefix of the form &#34;go%d.%d&#34; (e.g. &#34;go1.20&#34;, &#34;go1.21rc1&#34;, or</span>
    <span class="comment">// &#34;go1.21.0&#34;) or it must be empty; an empty string disables Go language</span>
    <span class="comment">// version checks. If the format is invalid, invoking the type checker will</span>
    <span class="comment">// result in an error.</span>
    GoVersion <a href="/pkg/builtin/#string">string</a> <span class="comment">// Go 1.18</span>

    <span class="comment">// If IgnoreFuncBodies is set, function bodies are not</span>
    <span class="comment">// type-checked.</span>
<span id="Config.IgnoreFuncBodies"></span>    IgnoreFuncBodies <a href="/pkg/builtin/#bool">bool</a>

    <span class="comment">// If FakeImportC is set, `import &#34;C&#34;` (for packages requiring Cgo)</span>
    <span class="comment">// declares an empty &#34;C&#34; package and errors are omitted for qualified</span>
    <span class="comment">// identifiers referring to package C (which won&#39;t find an object).</span>
    <span class="comment">// This feature is intended for the standard library cmd/api tool.</span>
    <span class="comment">//</span>
    <span class="comment">// Caution: Effects may be unpredictable due to follow-on errors.</span>
    <span class="comment">//          Do not use casually!</span>
<span id="Config.FakeImportC"></span>    FakeImportC <a href="/pkg/builtin/#bool">bool</a>

    <span class="comment">// If Error != nil, it is called with each error found</span>
    <span class="comment">// during type checking; err has dynamic type Error.</span>
    <span class="comment">// Secondary errors (for instance, to enumerate all types</span>
    <span class="comment">// involved in an invalid recursive type declaration) have</span>
    <span class="comment">// error strings that start with a &#39;\t&#39; character.</span>
    <span class="comment">// If Error == nil, type-checking stops with the first</span>
    <span class="comment">// error found.</span>
<span id="Config.Error"></span>    Error func(err <a href="/pkg/builtin/#error">error</a>)

    <span class="comment">// An importer is used to import packages referred to from</span>
    <span class="comment">// import declarations.</span>
    <span class="comment">// If the installed importer implements ImporterFrom, the type</span>
    <span class="comment">// checker calls ImportFrom instead of Import.</span>
    <span class="comment">// The type checker reports an error if an importer is needed</span>
    <span class="comment">// but none was installed.</span>
<span id="Config.Importer"></span>    Importer <a href="#Importer">Importer</a>

    <span class="comment">// If Sizes != nil, it provides the sizing functions for package unsafe.</span>
    <span class="comment">// Otherwise SizesFor(&#34;gc&#34;, &#34;amd64&#34;) is used instead.</span>
<span id="Config.Sizes"></span>    Sizes <a href="#Sizes">Sizes</a>

    <span class="comment">// If DisableUnusedImportCheck is set, packages are not checked</span>
    <span class="comment">// for unused imports.</span>
<span id="Config.DisableUnusedImportCheck"></span>    DisableUnusedImportCheck <a href="/pkg/builtin/#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Config.Check">func (*Config) <a href="/src/go/types/api.go?s=17397:17505#L464">Check</a>
					<a class="permalink" href="#Config.Check">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (conf *<a href="#Config">Config</a>) Check(path <a href="/pkg/builtin/#string">string</a>, fset *<a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#FileSet">FileSet</a>, files []*<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#File">File</a>, info *<a href="#Info">Info</a>) (*<a href="#Package">Package</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Check type-checks a package and returns the resulting package object and
the first error if any. Additionally, if info != nil, Check populates each
of the non-nil maps in the <a href="#Info">Info</a> struct.
<p>The package is marked as complete if no errors occurred, otherwise it is
incomplete. See [Config.Error] for controlling behavior in the presence of
errors.
<p>The package is specified by a list of *ast.Files and corresponding
file set, and the package path the package is identified with.
The clean path must not be empty or dot (&quot;.&quot;).

				
				
				
			
		
			
			
			<h2 id="Const">type <a href="/src/go/types/object.go?s=7601:7650#L237">Const</a>
				<a class="permalink" href="#Const">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Const represents a declared constant.

			<pre>type Const struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewConst">func <a href="/src/go/types/object.go?s=7773:7865#L244">NewConst</a>
					<a class="permalink" href="#NewConst">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewConst(pos <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>, pkg *<a href="#Package">Package</a>, name <a href="/pkg/builtin/#string">string</a>, typ <a href="#Type">Type</a>, val <a href="/pkg/go/constant/">constant</a>.<a href="/pkg/go/constant/#Value">Value</a>) *<a href="#Const">Const</a></pre>
				<p>NewConst returns a new constant with value val.
The remaining arguments set the attributes found with all Objects.

				
				
			

			
				
				<h3 id="Const.Exported">func (*Const) <a href="/src/go/types/object.go?s=4774:4808#L146">Exported</a>
					<a class="permalink" href="#Const.Exported">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Const">Const</a>) Exported() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Exported reports whether the object is exported (starts with a capital letter).
It doesn&apos;t take into account whether the object is in a local (function) scope
or not.

				
				
				
			
				
				<h3 id="Const.Id">func (*Const) <a href="/src/go/types/object.go?s=4892:4922#L149">Id</a>
					<a class="permalink" href="#Const.Id">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Const">Const</a>) Id() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Id is a wrapper for Id(obj.Pkg(), obj.Name()).

				
				
				
			
				
				<h3 id="Const.Name">func (*Const) <a href="/src/go/types/object.go?s=4458:4490#L138">Name</a>
					<a class="permalink" href="#Const.Name">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Const">Const</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Name returns the object&apos;s (package-local, unqualified) name.

				
				
				
			
				
				<h3 id="Const.Parent">func (*Const) <a href="/src/go/types/object.go?s=4036:4070#L128">Parent</a>
					<a class="permalink" href="#Const.Parent">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Const">Const</a>) Parent() *<a href="#Scope">Scope</a></pre>
				<p>Parent returns the scope in which the object is declared.
The result is nil for methods and struct fields.

				
				
				
			
				
				<h3 id="Const.Pkg">func (*Const) <a href="/src/go/types/object.go?s=4340:4373#L135">Pkg</a>
					<a class="permalink" href="#Const.Pkg">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Const">Const</a>) Pkg() *<a href="#Package">Package</a></pre>
				<p>Pkg returns the package to which the object belongs.
The result is nil for labels and objects in the Universe scope.

				
				
				
			
				
				<h3 id="Const.Pos">func (*Const) <a href="/src/go/types/object.go?s=4162:4196#L131">Pos</a>
					<a class="permalink" href="#Const.Pos">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Const">Const</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				<p>Pos returns the declaration position of the object&apos;s identifier.

				
				
				
			
				
				<h3 id="Const.String">func (*Const) <a href="/src/go/types/object.go?s=19500:19533#L608">String</a>
					<a class="permalink" href="#Const.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Const">Const</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Type">func (*Const) <a href="/src/go/types/object.go?s=4547:4577#L141">Type</a>
					<a class="permalink" href="#Const.Type">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Const">Const</a>) Type() <a href="#Type">Type</a></pre>
				<p>Type returns the object&apos;s type.

				
				
				
			
				
				<h3 id="Const.Val">func (*Const) <a href="/src/go/types/object.go?s=7987:8025#L249">Val</a>
					<a class="permalink" href="#Const.Val">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Const">Const</a>) Val() <a href="/pkg/go/constant/">constant</a>.<a href="/pkg/go/constant/#Value">Value</a></pre>
				<p>Val returns the constant&apos;s value.

				
				
				
			
		
			
			
			<h2 id="Context">type <a href="/src/go/types/context.go?s=1606:1833#L34">Context</a>
				<a class="permalink" href="#Context">&#xb6;</a>
				
				<span title="Added in Go 1.18">1.18</span>
			</h2>
			<p>A Context is an opaque type checking context. It may be used to share
identical type instances across type-checked packages or calls to
Instantiate. Contexts are safe for concurrent use.
<p>The use of a shared context does not guarantee that identical instances are
deduplicated in all cases.

			<pre>type Context struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewContext">func <a href="/src/go/types/context.go?s=1963:1989#L48">NewContext</a>
					<a class="permalink" href="#NewContext">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func NewContext() *<a href="#Context">Context</a></pre>
				<p>NewContext creates a new Context.

				
				
			

			
		
			
			
			<h2 id="Error">type <a href="/src/go/types/api.go?s=1750:2332#L36">Error</a>
				<a class="permalink" href="#Error">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>An Error describes a type-checking error; it implements the error interface.
A &quot;soft&quot; error is an error that still permits a valid interpretation of a
package (such as &quot;unused variable&quot;); &quot;hard&quot; errors may lead to unpredictable
behavior if ignored.

			<pre>type Error struct {
<span id="Error.Fset"></span>    Fset *<a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#FileSet">FileSet</a> <span class="comment">// file set for interpretation of Pos</span>
<span id="Error.Pos"></span>    Pos  <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>      <span class="comment">// error position</span>
<span id="Error.Msg"></span>    Msg  <a href="/pkg/builtin/#string">string</a>         <span class="comment">// error message</span>
<span id="Error.Soft"></span>    Soft <a href="/pkg/builtin/#bool">bool</a>           <span class="comment">// if set, error is &#34;soft&#34;</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Error.Error">func (Error) <a href="/src/go/types/api.go?s=2422:2453#L54">Error</a>
					<a class="permalink" href="#Error.Error">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (err <a href="#Error">Error</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Error returns an error string formatted as follows:
filename:line:column: message

				
				
				
			
		
			
			
			<h2 id="Func">type <a href="/src/go/types/object.go?s=12503:12709#L361">Func</a>
				<a class="permalink" href="#Func">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Func represents a declared function, concrete method, or abstract
(interface) method. Its Type() is always a *Signature.
An abstract method may belong to many interfaces due to embedding.

			<pre>type Func struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="MissingMethod">func <a href="/src/go/types/lookup.go?s=11567:11651#L317">MissingMethod</a>
					<a class="permalink" href="#MissingMethod">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func MissingMethod(V <a href="#Type">Type</a>, T *<a href="#Interface">Interface</a>, static <a href="/pkg/builtin/#bool">bool</a>) (method *<a href="#Func">Func</a>, wrongType <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>MissingMethod returns (nil, false) if V implements T, otherwise it
returns a missing method required by T and whether it is missing or
just has the wrong type: either a pointer receiver or wrong signature.
<p>For non-interface types V, or if static is set, V implements T if all
methods of T are present in V. Otherwise (V is an interface and static
is not set), MissingMethod only checks that methods of T which are also
present in V have matching types (e.g., for a type assertion x.(T) where
x is of interface type V).

				
				
			
				
				<h3 id="NewFunc">func <a href="/src/go/types/object.go?s=12808:12884#L369">NewFunc</a>
					<a class="permalink" href="#NewFunc">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewFunc(pos <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>, pkg *<a href="#Package">Package</a>, name <a href="/pkg/builtin/#string">string</a>, sig *<a href="#Signature">Signature</a>) *<a href="#Func">Func</a></pre>
				<p>NewFunc returns a new function with the given signature, representing
the function&apos;s type.

				
				
			

			
				
				<h3 id="Func.Exported">func (*Func) <a href="/src/go/types/object.go?s=4774:4808#L146">Exported</a>
					<a class="permalink" href="#Func.Exported">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Func">Func</a>) Exported() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Exported reports whether the object is exported (starts with a capital letter).
It doesn&apos;t take into account whether the object is in a local (function) scope
or not.

				
				
				
			
				
				<h3 id="Func.FullName">func (*Func) <a href="/src/go/types/object.go?s=13925:13959#L400">FullName</a>
					<a class="permalink" href="#Func.FullName">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Func">Func</a>) FullName() <a href="/pkg/builtin/#string">string</a></pre>
				<p>FullName returns the package- or receiver-type-qualified name of
function or method obj.

				
				
				
			
				
				<h3 id="Func.Id">func (*Func) <a href="/src/go/types/object.go?s=4892:4922#L149">Id</a>
					<a class="permalink" href="#Func.Id">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Func">Func</a>) Id() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Id is a wrapper for Id(obj.Pkg(), obj.Name()).

				
				
				
			
				
				<h3 id="Func.Name">func (*Func) <a href="/src/go/types/object.go?s=4458:4490#L138">Name</a>
					<a class="permalink" href="#Func.Name">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Func">Func</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Name returns the object&apos;s (package-local, unqualified) name.

				
				
				
			
				
				<h3 id="Func.Origin">func (*Func) <a href="/src/go/types/object.go?s=14704:14735#L418">Origin</a>
					<a class="permalink" href="#Func.Origin">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (obj *<a href="#Func">Func</a>) Origin() *<a href="#Func">Func</a></pre>
				<p>Origin returns the canonical Func for its receiver, i.e. the Func object
recorded in Info.Defs.
<p>For synthetic functions created during instantiation (such as methods on an
instantiated Named type or interface methods that depend on type arguments),
this will be the corresponding Func on the generic (uninstantiated) type.
For all other Funcs Origin returns the receiver.

				
				
				
			
				
				<h3 id="Func.Parent">func (*Func) <a href="/src/go/types/object.go?s=4036:4070#L128">Parent</a>
					<a class="permalink" href="#Func.Parent">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Func">Func</a>) Parent() *<a href="#Scope">Scope</a></pre>
				<p>Parent returns the scope in which the object is declared.
The result is nil for methods and struct fields.

				
				
				
			
				
				<h3 id="Func.Pkg">func (*Func) <a href="/src/go/types/object.go?s=14985:15016#L429">Pkg</a>
					<a class="permalink" href="#Func.Pkg">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Func">Func</a>) Pkg() *<a href="#Package">Package</a></pre>
				<p>Pkg returns the package to which the function belongs.
<p>The result is nil for methods of types in the Universe scope,
like method Error of the error built-in interface type.

				
				
				
			
				
				<h3 id="Func.Pos">func (*Func) <a href="/src/go/types/object.go?s=4162:4196#L131">Pos</a>
					<a class="permalink" href="#Func.Pos">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Func">Func</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				<p>Pos returns the declaration position of the object&apos;s identifier.

				
				
				
			
				
				<h3 id="Func.Scope">func (*Func) <a href="/src/go/types/object.go?s=14240:14271#L409">Scope</a>
					<a class="permalink" href="#Func.Scope">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Func">Func</a>) Scope() *<a href="#Scope">Scope</a></pre>
				<p>Scope returns the scope of the function&apos;s body block.
The result is nil for imported or instantiated functions and methods
(but there is also no mechanism to get to an instantiated function).

				
				
				
			
				
				<h3 id="Func.Signature">func (*Func) <a href="/src/go/types/object.go?s=13332:13371#L383">Signature</a>
					<a class="permalink" href="#Func.Signature">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (obj *<a href="#Func">Func</a>) Signature() *<a href="#Signature">Signature</a></pre>
				<p>Signature returns the signature (type) of the function or method.

				
				
				
			
				
				<h3 id="Func.String">func (*Func) <a href="/src/go/types/object.go?s=19713:19745#L611">String</a>
					<a class="permalink" href="#Func.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Func">Func</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Func.Type">func (*Func) <a href="/src/go/types/object.go?s=4547:4577#L141">Type</a>
					<a class="permalink" href="#Func.Type">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Func">Func</a>) Type() <a href="#Type">Type</a></pre>
				<p>Type returns the object&apos;s type.

				
				
				
			
		
			
			
			<h2 id="ImportMode">type <a href="/src/go/types/api.go?s=3326:3345#L80">ImportMode</a>
				<a class="permalink" href="#ImportMode">&#xb6;</a>
				
				<span title="Added in Go 1.6">1.6</span>
			</h2>
			<p>ImportMode is reserved for future use.

			<pre>type ImportMode <a href="/pkg/builtin/#int">int</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Importer">type <a href="/src/go/types/api.go?s=3024:3282#L72">Importer</a>
				<a class="permalink" href="#Importer">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>An Importer resolves import paths to Packages.
<p>CAUTION: This interface does not support the import of locally
vendored packages. See <a href="https://golang.org/s/go15vendor">https://golang.org/s/go15vendor</a>.
If possible, external implementations should implement <a href="#ImporterFrom">ImporterFrom</a>.

			<pre>type Importer interface {
    <span class="comment">// Import returns the imported package for the given import path.</span>
    <span class="comment">// The semantics is like for ImporterFrom.ImportFrom except that</span>
    <span class="comment">// dir and mode are ignored (since they are not present).</span>
    Import(path <a href="/pkg/builtin/#string">string</a>) (*<a href="#Package">Package</a>, <a href="/pkg/builtin/#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ImporterFrom">type <a href="/src/go/types/api.go?s=3524:4412#L85">ImporterFrom</a>
				<a class="permalink" href="#ImporterFrom">&#xb6;</a>
				
				<span title="Added in Go 1.6">1.6</span>
			</h2>
			<p>An ImporterFrom resolves import paths to packages; it
supports vendoring per <a href="https://golang.org/s/go15vendor">https://golang.org/s/go15vendor</a>.
Use go/importer to obtain an ImporterFrom implementation.

			<pre>type ImporterFrom interface {
    <span class="comment">// Importer is present for backward-compatibility. Calling</span>
    <span class="comment">// Import(path) is the same as calling ImportFrom(path, &#34;&#34;, 0);</span>
    <span class="comment">// i.e., locally vendored packages may not be found.</span>
    <span class="comment">// The types package does not call Import if an ImporterFrom</span>
    <span class="comment">// is present.</span>
    <a href="#Importer">Importer</a>

    <span class="comment">// ImportFrom returns the imported package for the given import</span>
    <span class="comment">// path when imported by a package file located in dir.</span>
    <span class="comment">// If the import failed, besides returning an error, ImportFrom</span>
    <span class="comment">// is encouraged to cache and return a package anyway, if one</span>
    <span class="comment">// was created. This will reduce package inconsistencies and</span>
    <span class="comment">// follow-on type checker errors due to the missing package.</span>
    <span class="comment">// The mode value must be 0; it is reserved for future use.</span>
    <span class="comment">// Two calls to ImportFrom with the same path and dir must</span>
    <span class="comment">// return the same package.</span>
    ImportFrom(path, dir <a href="/pkg/builtin/#string">string</a>, mode <a href="#ImportMode">ImportMode</a>) (*<a href="#Package">Package</a>, <a href="/pkg/builtin/#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Info">type <a href="/src/go/types/api.go?s=8030:13009#L197">Info</a>
				<a class="permalink" href="#Info">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>Info holds result type information for a type-checked package.
Only the information for which a map is provided is collected.
If the package has type errors, the collected information may
be incomplete.

			<pre>type Info struct {
<span id="Info.Types"></span>    <span class="comment">// Types maps expressions to their types, and for constant</span>
    <span class="comment">// expressions, also their values. Invalid expressions are</span>
    <span class="comment">// omitted.</span>
    <span class="comment">//</span>
    <span class="comment">// For (possibly parenthesized) identifiers denoting built-in</span>
    <span class="comment">// functions, the recorded signatures are call-site specific:</span>
    <span class="comment">// if the call result is not a constant, the recorded type is</span>
    <span class="comment">// an argument-specific signature. Otherwise, the recorded type</span>
    <span class="comment">// is invalid.</span>
    <span class="comment">//</span>
    <span class="comment">// The Types map does not record the type of every identifier,</span>
    <span class="comment">// only those that appear where an arbitrary expression is</span>
    <span class="comment">// permitted. For instance, the identifier f in a selector</span>
    <span class="comment">// expression x.f is found only in the Selections map, the</span>
    <span class="comment">// identifier z in a variable declaration &#39;var z int&#39; is found</span>
    <span class="comment">// only in the Defs map, and identifiers denoting packages in</span>
    <span class="comment">// qualified identifiers are collected in the Uses map.</span>
    Types map[<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Expr">Expr</a>]<a href="#TypeAndValue">TypeAndValue</a>

<span id="Info.Instances"></span>    <span class="comment">// Instances maps identifiers denoting generic types or functions to their</span>
    <span class="comment">// type arguments and instantiated type.</span>
    <span class="comment">//</span>
    <span class="comment">// For example, Instances will map the identifier for &#39;T&#39; in the type</span>
    <span class="comment">// instantiation T[int, string] to the type arguments [int, string] and</span>
    <span class="comment">// resulting instantiated *Named type. Given a generic function</span>
    <span class="comment">// func F[A any](A), Instances will map the identifier for &#39;F&#39; in the call</span>
    <span class="comment">// expression F(int(1)) to the inferred type arguments [int], and resulting</span>
    <span class="comment">// instantiated *Signature.</span>
    <span class="comment">//</span>
    <span class="comment">// Invariant: Instantiating Uses[id].Type() with Instances[id].TypeArgs</span>
    <span class="comment">// results in an equivalent of Instances[id].Type.</span>
    Instances map[*<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Ident">Ident</a>]<a href="#Instance">Instance</a> <span class="comment">// Go 1.18</span>

<span id="Info.Defs"></span>    <span class="comment">// Defs maps identifiers to the objects they define (including</span>
    <span class="comment">// package names, dots &#34;.&#34; of dot-imports, and blank &#34;_&#34; identifiers).</span>
    <span class="comment">// For identifiers that do not denote objects (e.g., the package name</span>
    <span class="comment">// in package clauses, or symbolic variables t in t := x.(type) of</span>
    <span class="comment">// type switch headers), the corresponding objects are nil.</span>
    <span class="comment">//</span>
    <span class="comment">// For an embedded field, Defs returns the field *Var it defines.</span>
    <span class="comment">//</span>
    <span class="comment">// Invariant: Defs[id] == nil || Defs[id].Pos() == id.Pos()</span>
    Defs map[*<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Ident">Ident</a>]<a href="#Object">Object</a>

<span id="Info.Uses"></span>    <span class="comment">// Uses maps identifiers to the objects they denote.</span>
    <span class="comment">//</span>
    <span class="comment">// For an embedded field, Uses returns the *TypeName it denotes.</span>
    <span class="comment">//</span>
    <span class="comment">// Invariant: Uses[id].Pos() != id.Pos()</span>
    Uses map[*<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Ident">Ident</a>]<a href="#Object">Object</a>

<span id="Info.Implicits"></span>    <span class="comment">// Implicits maps nodes to their implicitly declared objects, if any.</span>
    <span class="comment">// The following node and object types may appear:</span>
    <span class="comment">//</span>
    <span class="comment">//     node               declared object</span>
    <span class="comment">//</span>
    <span class="comment">//     *ast.ImportSpec    *PkgName for imports without renames</span>
    <span class="comment">//     *ast.CaseClause    type-specific *Var for each type switch case clause (incl. default)</span>
    <span class="comment">//     *ast.Field         anonymous parameter *Var (incl. unnamed results)</span>
    <span class="comment">//</span>
    Implicits map[<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Node">Node</a>]<a href="#Object">Object</a>

<span id="Info.Selections"></span>    <span class="comment">// Selections maps selector expressions (excluding qualified identifiers)</span>
    <span class="comment">// to their corresponding selections.</span>
    Selections map[*<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#SelectorExpr">SelectorExpr</a>]*<a href="#Selection">Selection</a>

<span id="Info.Scopes"></span>    <span class="comment">// Scopes maps ast.Nodes to the scopes they define. Package scopes are not</span>
    <span class="comment">// associated with a specific node but with all files belonging to a package.</span>
    <span class="comment">// Thus, the package scope can be found in the type-checked Package object.</span>
    <span class="comment">// Scopes nest, with the Universe scope being the outermost scope, enclosing</span>
    <span class="comment">// the package scope, which contains (one or more) files scopes, which enclose</span>
    <span class="comment">// function scopes which in turn enclose statement and function literal scopes.</span>
    <span class="comment">// Note that even though package-level functions are declared in the package</span>
    <span class="comment">// scope, the function scopes are embedded in the file scope of the file</span>
    <span class="comment">// containing the function declaration.</span>
    <span class="comment">//</span>
    <span class="comment">// The Scope of a function contains the declarations of any</span>
    <span class="comment">// type parameters, parameters, and named results, plus any</span>
    <span class="comment">// local declarations in the body block.</span>
    <span class="comment">// It is coextensive with the complete extent of the</span>
    <span class="comment">// function&#39;s syntax ([*ast.FuncDecl] or [*ast.FuncLit]).</span>
    <span class="comment">// The Scopes mapping does not contain an entry for the</span>
    <span class="comment">// function body ([*ast.BlockStmt]); the function&#39;s scope is</span>
    <span class="comment">// associated with the [*ast.FuncType].</span>
    <span class="comment">//</span>
    <span class="comment">// The following node types may appear in Scopes:</span>
    <span class="comment">//</span>
    <span class="comment">//     *ast.File</span>
    <span class="comment">//     *ast.FuncType</span>
    <span class="comment">//     *ast.TypeSpec</span>
    <span class="comment">//     *ast.BlockStmt</span>
    <span class="comment">//     *ast.IfStmt</span>
    <span class="comment">//     *ast.SwitchStmt</span>
    <span class="comment">//     *ast.TypeSwitchStmt</span>
    <span class="comment">//     *ast.CaseClause</span>
    <span class="comment">//     *ast.CommClause</span>
    <span class="comment">//     *ast.ForStmt</span>
    <span class="comment">//     *ast.RangeStmt</span>
    <span class="comment">//</span>
    Scopes map[<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Node">Node</a>]*<a href="#Scope">Scope</a>

<span id="Info.InitOrder"></span>    <span class="comment">// InitOrder is the list of package-level initializers in the order in which</span>
    <span class="comment">// they must be executed. Initializers referring to variables related by an</span>
    <span class="comment">// initialization dependency appear in topological order, the others appear</span>
    <span class="comment">// in source order. Variables without an initialization expression do not</span>
    <span class="comment">// appear in this list.</span>
    InitOrder []*<a href="#Initializer">Initializer</a>

<span id="Info.FileVersions"></span>    <span class="comment">// FileVersions maps a file to its Go version string.</span>
    <span class="comment">// If the file doesn&#39;t specify a version, the reported</span>
    <span class="comment">// string is Config.GoVersion.</span>
    <span class="comment">// Version strings begin with “go”, like “go1.21”, and</span>
    <span class="comment">// are suitable for use with the [go/version] package.</span>
    FileVersions map[*<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#File">File</a>]<a href="/pkg/builtin/#string">string</a> <span class="comment">// Go 1.22</span>
}
</pre>

			

			

			<div id="example_Info" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		<p>ExampleInfo prints various facts recorded by the type checker in a
types.Info struct: definitions of and references to each named object,
and the type, value, and mode of every expression in the package.
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Parse a single source file.</span>
const input = `
package fib

type S string

var a, b, c = len(b), S(c), &#34;hello&#34;

func fib(x int) int {
    if x &lt; 2 {
        return x
    }
    return fib(x-1) - fib(x-2)
}`
<span class="comment">// We need a specific fileset in this test below for positions.</span>
<span class="comment">// Cannot use typecheck helper.</span>
fset := token.NewFileSet()
f := mustParse(fset, input)

<span class="comment">// Type-check the package.</span>
<span class="comment">// We create an empty map for each kind of input</span>
<span class="comment">// we&#39;re interested in, and Check populates them.</span>
info := types.Info{
    Types: make(map[ast.Expr]types.TypeAndValue),
    Defs:  make(map[*ast.Ident]types.Object),
    Uses:  make(map[*ast.Ident]types.Object),
}
var conf types.Config
pkg, err := conf.Check(&#34;fib&#34;, fset, []*ast.File{f}, &amp;info)
if err != nil {
    log.Fatal(err)
}

<span class="comment">// Print package-level variables in initialization order.</span>
fmt.Printf(&#34;InitOrder: %v\n\n&#34;, info.InitOrder)

<span class="comment">// For each named object, print the line and</span>
<span class="comment">// column of its definition and each of its uses.</span>
fmt.Println(&#34;Defs and Uses of each named object:&#34;)
usesByObj := make(map[types.Object][]string)
for id, obj := range info.Uses {
    posn := fset.Position(id.Pos())
    lineCol := fmt.Sprintf(&#34;%d:%d&#34;, posn.Line, posn.Column)
    usesByObj[obj] = append(usesByObj[obj], lineCol)
}
var items []string
for obj, uses := range usesByObj {
    slices.Sort(uses)
    item := fmt.Sprintf(&#34;%s:\n  defined at %s\n  used at %s&#34;,
        types.ObjectString(obj, types.RelativeTo(pkg)),
        fset.Position(obj.Pos()),
        strings.Join(uses, &#34;, &#34;))
    items = append(items, item)
}
slices.Sort(items) <span class="comment">// sort by line:col, in effect</span>
fmt.Println(strings.Join(items, &#34;\n&#34;))
fmt.Println()

fmt.Println(&#34;Types and Values of each expression:&#34;)
items = nil
for expr, tv := range info.Types {
    var buf strings.Builder
    posn := fset.Position(expr.Pos())
    tvstr := tv.Type.String()
    if tv.Value != nil {
        tvstr += &#34; = &#34; + tv.Value.String()
    }
    <span class="comment">// line:col | expr | mode : type = value</span>
    fmt.Fprintf(&amp;buf, &#34;%2d:%2d | %-19s | %-7s : %s&#34;,
        posn.Line, posn.Column, exprString(fset, expr),
        mode(tv), tvstr)
    items = append(items, buf.String())
}
slices.Sort(items)
fmt.Println(strings.Join(items, &#34;\n&#34;))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">InitOrder: [c = &#34;hello&#34; b = S(c) a = len(b)]

Defs and Uses of each named object:
builtin len:
  defined at -
  used at 6:15
func fib(x int) int:
  defined at fib:8:6
  used at 12:20, 12:9
type S string:
  defined at fib:4:6
  used at 6:23
type int:
  defined at -
  used at 8:12, 8:17
type string:
  defined at -
  used at 4:8
var b S:
  defined at fib:6:8
  used at 6:19
var c string:
  defined at fib:6:11
  used at 6:25
var x int:
  defined at fib:8:10
  used at 10:10, 12:13, 12:24, 9:5

Types and Values of each expression:
 4: 8 | string              | type    : string
 6:15 | len                 | builtin : func(fib.S) int
 6:15 | len(b)              | value   : int
 6:19 | b                   | var     : fib.S
 6:23 | S                   | type    : fib.S
 6:23 | S(c)                | value   : fib.S
 6:25 | c                   | var     : string
 6:29 | &#34;hello&#34;             | value   : string = &#34;hello&#34;
 8:12 | int                 | type    : int
 8:17 | int                 | type    : int
 9: 5 | x                   | var     : int
 9: 5 | x &lt; 2               | value   : untyped bool
 9: 9 | 2                   | value   : int = 2
10:10 | x                   | var     : int
12: 9 | fib                 | value   : func(x int) int
12: 9 | fib(x - 1)          | value   : int
12: 9 | fib(x-1) - fib(x-2) | value   : int
12:13 | x                   | var     : int
12:13 | x - 1               | value   : int
12:15 | 1                   | value   : int = 1
12:20 | fib                 | value   : func(x int) int
12:20 | fib(x - 2)          | value   : int
12:24 | x                   | var     : int
12:24 | x - 2               | value   : int
12:26 | 2                   | value   : int = 2
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="Info.ObjectOf">func (*Info) <a href="/src/go/types/api.go?s=13707:13755#L339">ObjectOf</a>
					<a class="permalink" href="#Info.ObjectOf">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (info *<a href="#Info">Info</a>) ObjectOf(id *<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Ident">Ident</a>) <a href="#Object">Object</a></pre>
				<p>ObjectOf returns the object denoted by the specified id,
or nil if not found.
<p>If id is an embedded struct field, <a href="#Info.ObjectOf">Info.ObjectOf</a> returns the field (*<a href="#Var">Var</a>)
it defines, not the type (*<a href="#TypeName">TypeName</a>) it uses.
<p>Precondition: the Uses and Defs maps are populated.

				
				
				
			
				
				<h3 id="Info.PkgNameOf">func (*Info) <a href="/src/go/types/api.go?s=14039:14096#L352">PkgNameOf</a>
					<a class="permalink" href="#Info.PkgNameOf">&#xb6;</a>
					
					<span title="Added in Go 1.22">1.22</span>
				</h3>
				<pre>func (info *<a href="#Info">Info</a>) PkgNameOf(imp *<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#ImportSpec">ImportSpec</a>) *<a href="#PkgName">PkgName</a></pre>
				<p>PkgNameOf returns the local package name defined by the import,
or nil if not found.
<p>For dot-imports, the package name is &quot;.&quot;.
<p>Precondition: the Defs and Implicts maps are populated.

				
				
				
			
				
				<h3 id="Info.TypeOf">func (*Info) <a href="/src/go/types/api.go?s=13206:13247#L320">TypeOf</a>
					<a class="permalink" href="#Info.TypeOf">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (info *<a href="#Info">Info</a>) TypeOf(e <a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Expr">Expr</a>) <a href="#Type">Type</a></pre>
				<p>TypeOf returns the type of expression e, or nil if not found.
Precondition: the Types, Uses and Defs maps are populated.

				
				
				
			
		
			
			
			<h2 id="Initializer">type <a href="/src/go/types/api.go?s=16522:16592#L435">Initializer</a>
				<a class="permalink" href="#Initializer">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>An Initializer describes a package-level variable, or a list of variables in case
of a multi-valued initialization expression, and the corresponding initialization
expression.

			<pre>type Initializer struct {
<span id="Initializer.Lhs"></span>    Lhs []*<a href="#Var">Var</a> <span class="comment">// var Lhs = Rhs</span>
<span id="Initializer.Rhs"></span>    Rhs <a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Expr">Expr</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Initializer.String">func (*Initializer) <a href="/src/go/types/api.go?s=16594:16634#L440">String</a>
					<a class="permalink" href="#Initializer.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (init *<a href="#Initializer">Initializer</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Instance">type <a href="/src/go/types/api.go?s=16276:16335#L427">Instance</a>
				<a class="permalink" href="#Instance">&#xb6;</a>
				
				<span title="Added in Go 1.18">1.18</span>
			</h2>
			<p>Instance reports the type arguments and instantiated type for type and
function instantiations. For type instantiations, <a href="#Type">Type</a> will be of dynamic
type *<a href="#Named">Named</a>. For function instantiations, <a href="#Type">Type</a> will be of dynamic type
*Signature.

			<pre>type Instance struct {
<span id="Instance.TypeArgs"></span>    TypeArgs *<a href="#TypeList">TypeList</a>
<span id="Instance.Type"></span>    Type     <a href="#Type">Type</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Interface">type <a href="/src/go/types/interface.go?s=370:1011#L7">Interface</a>
				<a class="permalink" href="#Interface">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>An Interface represents an interface type.

			<pre>type Interface struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewInterface">func <a href="/src/go/types/interface.go?s=1569:1634#L29">NewInterface</a>
					<a class="permalink" href="#NewInterface">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewInterface(methods []*<a href="#Func">Func</a>, embeddeds []*<a href="#Named">Named</a>) *<a href="#Interface">Interface</a></pre>
				<p>NewInterface returns a new interface for the given methods and embedded types.
NewInterface takes ownership of the provided methods and may modify their types
by setting missing receivers.
<p>Deprecated: Use NewInterfaceType instead which allows arbitrary embedded types.

				
				
			
				
				<h3 id="NewInterfaceType">func <a href="/src/go/types/interface.go?s=2129:2196#L43">NewInterfaceType</a>
					<a class="permalink" href="#NewInterfaceType">&#xb6;</a>
					
					<span title="Added in Go 1.11">1.11</span>
				</h3>
				<pre>func NewInterfaceType(methods []*<a href="#Func">Func</a>, embeddeds []<a href="#Type">Type</a>) *<a href="#Interface">Interface</a></pre>
				<p>NewInterfaceType returns a new interface for the given methods and embedded
types. NewInterfaceType takes ownership of the provided methods and may
modify their types by setting missing receivers.
<p>To avoid race conditions, the interface&apos;s type set should be computed before
concurrent use of the interface, by explicitly calling Complete.

				
				
			

			
				
				<h3 id="Interface.Complete">func (*Interface) <a href="/src/go/types/interface.go?s=5520:5561#L129">Complete</a>
					<a class="permalink" href="#Interface.Complete">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Interface">Interface</a>) Complete() *<a href="#Interface">Interface</a></pre>
				<p>Complete computes the interface&apos;s type set. It must be called by users of
<a href="#NewInterfaceType">NewInterfaceType</a> and <a href="#NewInterface">NewInterface</a> after the interface&apos;s embedded types are
fully defined and before using the interface type in any way other than to
form other types. The interface must not contain duplicate methods or a
panic occurs. Complete returns the receiver.
<p>Interface types that have been completed are safe for concurrent use.

				
				
				
			
				
				<h3 id="Interface.Embedded">func (*Interface) <a href="/src/go/types/interface.go?s=3911:3953#L97">Embedded</a>
					<a class="permalink" href="#Interface.Embedded">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Interface">Interface</a>) Embedded(i <a href="/pkg/builtin/#int">int</a>) *<a href="#Named">Named</a></pre>
				<p>Embedded returns the i&apos;th embedded defined (*<a href="#Named">Named</a>) type of interface t for 0 &lt;= i &lt; t.NumEmbeddeds().
The result is nil if the i&apos;th embedded type is not a defined type.
<p>Deprecated: Use <a href="#Interface.EmbeddedType">Interface.EmbeddedType</a> which is not restricted to defined (*<a href="#Named">Named</a>) types.

				
				
				
			
				
				<h3 id="Interface.EmbeddedType">func (*Interface) <a href="/src/go/types/interface.go?s=4083:4127#L100">EmbeddedType</a>
					<a class="permalink" href="#Interface.EmbeddedType">&#xb6;</a>
					
					<span title="Added in Go 1.11">1.11</span>
				</h3>
				<pre>func (t *<a href="#Interface">Interface</a>) EmbeddedType(i <a href="/pkg/builtin/#int">int</a>) <a href="#Type">Type</a></pre>
				<p>EmbeddedType returns the i&apos;th embedded type of interface t for 0 &lt;= i &lt; t.NumEmbeddeds().

				
				
				
			
				
				<h3 id="Interface.Empty">func (*Interface) <a href="/src/go/types/interface.go?s=4545:4577#L110">Empty</a>
					<a class="permalink" href="#Interface.Empty">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Interface">Interface</a>) Empty() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Empty reports whether t is the empty interface.

				
				
				
			
				
				<h3 id="Interface.ExplicitMethod">func (*Interface) <a href="/src/go/types/interface.go?s=3423:3470#L88">ExplicitMethod</a>
					<a class="permalink" href="#Interface.ExplicitMethod">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Interface">Interface</a>) ExplicitMethod(i <a href="/pkg/builtin/#int">int</a>) *<a href="#Func">Func</a></pre>
				<p>ExplicitMethod returns the i&apos;th explicitly declared method of interface t for 0 &lt;= i &lt; t.NumExplicitMethods().
The methods are ordered by their unique <a href="#Id">Id</a>.

				
				
				
			
				
				<h3 id="Interface.IsComparable">func (*Interface) <a href="/src/go/types/interface.go?s=4693:4732#L113">IsComparable</a>
					<a class="permalink" href="#Interface.IsComparable">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#Interface">Interface</a>) IsComparable() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsComparable reports whether each type in interface t&apos;s type set is comparable.

				
				
				
			
				
				<h3 id="Interface.IsImplicit">func (*Interface) <a href="/src/go/types/interface.go?s=5023:5060#L120">IsImplicit</a>
					<a class="permalink" href="#Interface.IsImplicit">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#Interface">Interface</a>) IsImplicit() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsImplicit reports whether the interface t is a wrapper for a type set literal.

				
				
				
			
				
				<h3 id="Interface.IsMethodSet">func (*Interface) <a href="/src/go/types/interface.go?s=4863:4901#L117">IsMethodSet</a>
					<a class="permalink" href="#Interface.IsMethodSet">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#Interface">Interface</a>) IsMethodSet() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsMethodSet reports whether the interface t is fully described by its method
set.

				
				
				
			
				
				<h3 id="Interface.MarkImplicit">func (*Interface) <a href="/src/go/types/interface.go?s=3041:3075#L79">MarkImplicit</a>
					<a class="permalink" href="#Interface.MarkImplicit">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#Interface">Interface</a>) MarkImplicit()</pre>
				<p>MarkImplicit marks the interface t as implicit, meaning this interface
corresponds to a constraint literal such as ~T or A|B without explicit
interface embedding. MarkImplicit should be called before any concurrent use
of implicit interfaces.

				
				
				
			
				
				<h3 id="Interface.Method">func (*Interface) <a href="/src/go/types/interface.go?s=4420:4459#L107">Method</a>
					<a class="permalink" href="#Interface.Method">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Interface">Interface</a>) Method(i <a href="/pkg/builtin/#int">int</a>) *<a href="#Func">Func</a></pre>
				<p>Method returns the i&apos;th method of interface t for 0 &lt;= i &lt; t.NumMethods().
The methods are ordered by their unique Id.

				
				
				
			
				
				<h3 id="Interface.NumEmbeddeds">func (*Interface) <a href="/src/go/types/interface.go?s=3565:3603#L91">NumEmbeddeds</a>
					<a class="permalink" href="#Interface.NumEmbeddeds">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Interface">Interface</a>) NumEmbeddeds() <a href="/pkg/builtin/#int">int</a></pre>
				<p>NumEmbeddeds returns the number of embedded types in interface t.

				
				
				
			
				
				<h3 id="Interface.NumExplicitMethods">func (*Interface) <a href="/src/go/types/interface.go?s=3188:3232#L84">NumExplicitMethods</a>
					<a class="permalink" href="#Interface.NumExplicitMethods">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Interface">Interface</a>) NumExplicitMethods() <a href="/pkg/builtin/#int">int</a></pre>
				<p>NumExplicitMethods returns the number of explicitly declared methods of interface t.

				
				
				
			
				
				<h3 id="Interface.NumMethods">func (*Interface) <a href="/src/go/types/interface.go?s=4221:4257#L103">NumMethods</a>
					<a class="permalink" href="#Interface.NumMethods">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Interface">Interface</a>) NumMethods() <a href="/pkg/builtin/#int">int</a></pre>
				<p>NumMethods returns the total number of methods of interface t.

				
				
				
			
				
				<h3 id="Interface.String">func (*Interface) <a href="/src/go/types/interface.go?s=5717:5752#L138">String</a>
					<a class="permalink" href="#Interface.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Interface">Interface</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Interface.Underlying">func (*Interface) <a href="/src/go/types/interface.go?s=5666:5703#L137">Underlying</a>
					<a class="permalink" href="#Interface.Underlying">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Interface">Interface</a>) Underlying() <a href="#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Label">type <a href="/src/go/types/object.go?s=16161:16230#L454">Label</a>
				<a class="permalink" href="#Label">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Label represents a declared label.
Labels don&apos;t have a type.

			<pre>type Label struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewLabel">func <a href="/src/go/types/object.go?s=16265:16327#L460">NewLabel</a>
					<a class="permalink" href="#NewLabel">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewLabel(pos <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>, pkg *<a href="#Package">Package</a>, name <a href="/pkg/builtin/#string">string</a>) *<a href="#Label">Label</a></pre>
				<p>NewLabel returns a new label.

				
				
			

			
				
				<h3 id="Label.Exported">func (*Label) <a href="/src/go/types/object.go?s=4774:4808#L146">Exported</a>
					<a class="permalink" href="#Label.Exported">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Label">Label</a>) Exported() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Exported reports whether the object is exported (starts with a capital letter).
It doesn&apos;t take into account whether the object is in a local (function) scope
or not.

				
				
				
			
				
				<h3 id="Label.Id">func (*Label) <a href="/src/go/types/object.go?s=4892:4922#L149">Id</a>
					<a class="permalink" href="#Label.Id">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Label">Label</a>) Id() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Id is a wrapper for Id(obj.Pkg(), obj.Name()).

				
				
				
			
				
				<h3 id="Label.Name">func (*Label) <a href="/src/go/types/object.go?s=4458:4490#L138">Name</a>
					<a class="permalink" href="#Label.Name">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Label">Label</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Name returns the object&apos;s (package-local, unqualified) name.

				
				
				
			
				
				<h3 id="Label.Parent">func (*Label) <a href="/src/go/types/object.go?s=4036:4070#L128">Parent</a>
					<a class="permalink" href="#Label.Parent">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Label">Label</a>) Parent() *<a href="#Scope">Scope</a></pre>
				<p>Parent returns the scope in which the object is declared.
The result is nil for methods and struct fields.

				
				
				
			
				
				<h3 id="Label.Pkg">func (*Label) <a href="/src/go/types/object.go?s=4340:4373#L135">Pkg</a>
					<a class="permalink" href="#Label.Pkg">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Label">Label</a>) Pkg() *<a href="#Package">Package</a></pre>
				<p>Pkg returns the package to which the object belongs.
The result is nil for labels and objects in the Universe scope.

				
				
				
			
				
				<h3 id="Label.Pos">func (*Label) <a href="/src/go/types/object.go?s=4162:4196#L131">Pos</a>
					<a class="permalink" href="#Label.Pos">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Label">Label</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				<p>Pos returns the declaration position of the object&apos;s identifier.

				
				
				
			
				
				<h3 id="Label.String">func (*Label) <a href="/src/go/types/object.go?s=19784:19817#L612">String</a>
					<a class="permalink" href="#Label.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Label">Label</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Label.Type">func (*Label) <a href="/src/go/types/object.go?s=4547:4577#L141">Type</a>
					<a class="permalink" href="#Label.Type">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Label">Label</a>) Type() <a href="#Type">Type</a></pre>
				<p>Type returns the object&apos;s type.

				
				
				
			
		
			
			
			<h2 id="Map">type <a href="/src/go/types/map.go?s=330:365#L1">Map</a>
				<a class="permalink" href="#Map">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Map represents a map type.

			<pre>type Map struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewMap">func <a href="/src/go/types/map.go?s=432:464#L6">NewMap</a>
					<a class="permalink" href="#NewMap">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewMap(key, elem <a href="#Type">Type</a>) *<a href="#Map">Map</a></pre>
				<p>NewMap returns a new map for the given key and element types.

				
				
			

			
				
				<h3 id="Map.Elem">func (*Map) <a href="/src/go/types/map.go?s=629:654#L14">Elem</a>
					<a class="permalink" href="#Map.Elem">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (m *<a href="#Map">Map</a>) Elem() <a href="#Type">Type</a></pre>
				<p>Elem returns the element type of map m.

				
				
				
			
				
				<h3 id="Map.Key">func (*Map) <a href="/src/go/types/map.go?s=543:567#L11">Key</a>
					<a class="permalink" href="#Map.Key">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (m *<a href="#Map">Map</a>) Key() <a href="#Type">Type</a></pre>
				<p>Key returns the key type of map m.

				
				
				
			
				
				<h3 id="Map.String">func (*Map) <a href="/src/go/types/map.go?s=719:748#L17">String</a>
					<a class="permalink" href="#Map.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Map">Map</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Map.Underlying">func (*Map) <a href="/src/go/types/map.go?s=674:705#L16">Underlying</a>
					<a class="permalink" href="#Map.Underlying">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Map">Map</a>) Underlying() <a href="#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="MethodSet">type <a href="/src/go/types/methodset.go?s=487:531#L8">MethodSet</a>
				<a class="permalink" href="#MethodSet">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A MethodSet is an ordered set of concrete or abstract (interface) methods;
a method is a <a href="#MethodVal">MethodVal</a> selection, and they are ordered by ascending m.Obj().Id().
The zero value for a MethodSet is a ready-to-use empty method set.

			<pre>type MethodSet struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_MethodSet" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		<p>ExampleMethodSet prints the method sets of various types.
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Parse a single source file.</span>
const input = `
package temperature
import &#34;fmt&#34;
type Celsius float64
func (c Celsius) String() string  { return fmt.Sprintf(&#34;%g°C&#34;, c) }
func (c *Celsius) SetF(f float64) { *c = Celsius(f - 32 / 9 * 5) }

type S struct { I; m int }
type I interface { m() byte }
`
fset := token.NewFileSet()
f, err := parser.ParseFile(fset, &#34;celsius.go&#34;, input, 0)
if err != nil {
    log.Fatal(err)
}

<span class="comment">// Type-check a package consisting of this file.</span>
<span class="comment">// Type information for the imported packages</span>
<span class="comment">// comes from $GOROOT/pkg/$GOOS_$GOOARCH/fmt.a.</span>
conf := types.Config{Importer: importer.Default()}
pkg, err := conf.Check(&#34;temperature&#34;, fset, []*ast.File{f}, nil)
if err != nil {
    log.Fatal(err)
}

<span class="comment">// Print the method sets of Celsius and *Celsius.</span>
celsius := pkg.Scope().Lookup(&#34;Celsius&#34;).Type()
for _, t := range []types.Type{celsius, types.NewPointer(celsius)} {
    fmt.Printf(&#34;Method set of %s:\n&#34;, t)
    mset := types.NewMethodSet(t)
    for i := 0; i &lt; mset.Len(); i++ {
        fmt.Println(mset.At(i))
    }
    fmt.Println()
}

<span class="comment">// Print the method set of S.</span>
styp := pkg.Scope().Lookup(&#34;S&#34;).Type()
fmt.Printf(&#34;Method set of %s:\n&#34;, styp)
fmt.Println(types.NewMethodSet(styp))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Method set of temperature.Celsius:
method (temperature.Celsius) String() string

Method set of *temperature.Celsius:
method (*temperature.Celsius) SetF(f float64)
method (*temperature.Celsius) String() string

Method set of temperature.S:
MethodSet {}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewMethodSet">func <a href="/src/go/types/methodset.go?s=1811:1847#L62">NewMethodSet</a>
					<a class="permalink" href="#NewMethodSet">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewMethodSet(T <a href="#Type">Type</a>) *<a href="#MethodSet">MethodSet</a></pre>
				<p>NewMethodSet returns the method set for the given type T.
It always returns a non-nil method set, even if it is empty.

				
				
			

			
				
				<h3 id="MethodSet.At">func (*MethodSet) <a href="/src/go/types/methodset.go?s=945:985#L30">At</a>
					<a class="permalink" href="#MethodSet.At">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#MethodSet">MethodSet</a>) At(i <a href="/pkg/builtin/#int">int</a>) *<a href="#Selection">Selection</a></pre>
				<p>At returns the i&apos;th method in s for 0 &lt;= i &lt; s.Len().

				
				
				
			
				
				<h3 id="MethodSet.Len">func (*MethodSet) <a href="/src/go/types/methodset.go?s=834:863#L27">Len</a>
					<a class="permalink" href="#MethodSet.Len">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#MethodSet">MethodSet</a>) Len() <a href="/pkg/builtin/#int">int</a></pre>
				<p>Len returns the number of methods in s.

				
				
				
			
				
				<h3 id="MethodSet.Lookup">func (*MethodSet) <a href="/src/go/types/methodset.go?s=1090:1154#L33">Lookup</a>
					<a class="permalink" href="#MethodSet.Lookup">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#MethodSet">MethodSet</a>) Lookup(pkg *<a href="#Package">Package</a>, name <a href="/pkg/builtin/#string">string</a>) *<a href="#Selection">Selection</a></pre>
				<p>Lookup returns the method with matching package and name, or nil if not found.

				
				
				
			
				
				<h3 id="MethodSet.String">func (*MethodSet) <a href="/src/go/types/methodset.go?s=533:568#L12">String</a>
					<a class="permalink" href="#MethodSet.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#MethodSet">MethodSet</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Named">type <a href="/src/go/types/named.go?s=5101:6332#L88">Named</a>
				<a class="permalink" href="#Named">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Named represents a named (defined) type.

			<pre>type Named struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewNamed">func <a href="/src/go/types/named.go?s=7316:7385#L137">NewNamed</a>
					<a class="permalink" href="#NewNamed">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewNamed(obj *<a href="#TypeName">TypeName</a>, underlying <a href="#Type">Type</a>, methods []*<a href="#Func">Func</a>) *<a href="#Named">Named</a></pre>
				<p>NewNamed returns a new named type for the given type name, underlying type, and associated methods.
If the given type name obj doesn&apos;t have a type yet, its type is set to the returned named type.
The underlying type must not be a *Named.

				
				
			

			
				
				<h3 id="Named.AddMethod">func (*Named) <a href="/src/go/types/named.go?s=17309:17343#L449">AddMethod</a>
					<a class="permalink" href="#Named.AddMethod">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Named">Named</a>) AddMethod(m *<a href="#Func">Func</a>)</pre>
				<p>AddMethod adds method m unless it is already in the method list.
The method must be in the same package as t, and t must not have
type arguments.

				
				
				
			
				
				<h3 id="Named.Method">func (*Named) <a href="/src/go/types/named.go?s=14188:14223#L337">Method</a>
					<a class="permalink" href="#Named.Method">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Named">Named</a>) Method(i <a href="/pkg/builtin/#int">int</a>) *<a href="#Func">Func</a></pre>
				<p>Method returns the i&apos;th method of named type t for 0 &lt;= i &lt; t.NumMethods().
<p>For an ordinary or instantiated type t, the receiver base type of this
method is the named type t. For an uninstantiated generic type t, each
method receiver is instantiated with its receiver type parameters.
<p>Methods are numbered deterministically: given the same list of source files
presented to the type checker, or the same sequence of NewMethod and AddMethod
calls, the mapping from method index to corresponding method remains the same.
But the specific ordering is not specified and must not be relied on as it may
change in the future.

				
				
				
			
				
				<h3 id="Named.NumMethods">func (*Named) <a href="/src/go/types/named.go?s=13455:13487#L322">NumMethods</a>
					<a class="permalink" href="#Named.NumMethods">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Named">Named</a>) NumMethods() <a href="/pkg/builtin/#int">int</a></pre>
				<p>NumMethods returns the number of explicit methods defined for t.

				
				
				
			
				
				<h3 id="Named.Obj">func (*Named) <a href="/src/go/types/named.go?s=12432:12463#L286">Obj</a>
					<a class="permalink" href="#Named.Obj">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Named">Named</a>) Obj() *<a href="#TypeName">TypeName</a></pre>
				<p>Obj returns the type name for the declaration defining the named type t. For
instantiated types, this is same as the type name of the origin type.

				
				
				
			
				
				<h3 id="Named.Origin">func (*Named) <a href="/src/go/types/named.go?s=12665:12696#L295">Origin</a>
					<a class="permalink" href="#Named.Origin">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#Named">Named</a>) Origin() *<a href="#Named">Named</a></pre>
				<p>Origin returns the generic type from which the named type t is
instantiated. If t is not an instantiated type, the result is t.

				
				
				
			
				
				<h3 id="Named.SetTypeParams">func (*Named) <a href="/src/go/types/named.go?s=13087:13138#L308">SetTypeParams</a>
					<a class="permalink" href="#Named.SetTypeParams">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#Named">Named</a>) SetTypeParams(tparams []*<a href="#TypeParam">TypeParam</a>)</pre>
				<p>SetTypeParams sets the type parameters of the named type t.
t must not have type arguments.

				
				
				
			
				
				<h3 id="Named.SetUnderlying">func (*Named) <a href="/src/go/types/named.go?s=16816:16862#L432">SetUnderlying</a>
					<a class="permalink" href="#Named.SetUnderlying">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Named">Named</a>) SetUnderlying(underlying <a href="#Type">Type</a>)</pre>
				<p>SetUnderlying sets the underlying type and marks t as complete.
t must not have type arguments.

				
				
				
			
				
				<h3 id="Named.String">func (*Named) <a href="/src/go/types/named.go?s=18382:18413#L491">String</a>
					<a class="permalink" href="#Named.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Named">Named</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Named.TypeArgs">func (*Named) <a href="/src/go/types/named.go?s=13288:13324#L314">TypeArgs</a>
					<a class="permalink" href="#Named.TypeArgs">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#Named">Named</a>) TypeArgs() *<a href="#TypeList">TypeList</a></pre>
				<p>TypeArgs returns the type arguments used to instantiate the named type t.

				
				
				
			
				
				<h3 id="Named.TypeParams">func (*Named) <a href="/src/go/types/named.go?s=12913:12956#L304">TypeParams</a>
					<a class="permalink" href="#Named.TypeParams">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#Named">Named</a>) TypeParams() *<a href="#TypeParamList">TypeParamList</a></pre>
				<p>TypeParams returns the type parameters of the named type t, or nil.
The result is non-nil for an (originally) generic type even if it is instantiated.

				
				
				
			
				
				<h3 id="Named.Underlying">func (*Named) <a href="/src/go/types/named.go?s=18225:18258#L486">Underlying</a>
					<a class="permalink" href="#Named.Underlying">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Named">Named</a>) Underlying() <a href="#Type">Type</a></pre>
				<p>Underlying returns the <a href="https://go.dev/ref/spec#Underlying_types.">underlying type</a> of the named type t, resolving all
forwarding declarations. Underlying types are never Named, TypeParam, or
Alias types.

				
				
				
			
		
			
			
			<h2 id="Nil">type <a href="/src/go/types/object.go?s=16743:16770#L476">Nil</a>
				<a class="permalink" href="#Nil">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>Nil represents the predeclared value nil.

			<pre>type Nil struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Nil.Exported">func (*Nil) <a href="/src/go/types/object.go?s=4774:4808#L146">Exported</a>
					<a class="permalink" href="#Nil.Exported">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Nil">Nil</a>) Exported() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Exported reports whether the object is exported (starts with a capital letter).
It doesn&apos;t take into account whether the object is in a local (function) scope
or not.

				
				
				
			
				
				<h3 id="Nil.Id">func (*Nil) <a href="/src/go/types/object.go?s=4892:4922#L149">Id</a>
					<a class="permalink" href="#Nil.Id">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Nil">Nil</a>) Id() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Id is a wrapper for Id(obj.Pkg(), obj.Name()).

				
				
				
			
				
				<h3 id="Nil.Name">func (*Nil) <a href="/src/go/types/object.go?s=4458:4490#L138">Name</a>
					<a class="permalink" href="#Nil.Name">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Nil">Nil</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Name returns the object&apos;s (package-local, unqualified) name.

				
				
				
			
				
				<h3 id="Nil.Parent">func (*Nil) <a href="/src/go/types/object.go?s=4036:4070#L128">Parent</a>
					<a class="permalink" href="#Nil.Parent">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Nil">Nil</a>) Parent() *<a href="#Scope">Scope</a></pre>
				<p>Parent returns the scope in which the object is declared.
The result is nil for methods and struct fields.

				
				
				
			
				
				<h3 id="Nil.Pkg">func (*Nil) <a href="/src/go/types/object.go?s=4340:4373#L135">Pkg</a>
					<a class="permalink" href="#Nil.Pkg">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Nil">Nil</a>) Pkg() *<a href="#Package">Package</a></pre>
				<p>Pkg returns the package to which the object belongs.
The result is nil for labels and objects in the Universe scope.

				
				
				
			
				
				<h3 id="Nil.Pos">func (*Nil) <a href="/src/go/types/object.go?s=4162:4196#L131">Pos</a>
					<a class="permalink" href="#Nil.Pos">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Nil">Nil</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				<p>Pos returns the declaration position of the object&apos;s identifier.

				
				
				
			
				
				<h3 id="Nil.String">func (*Nil) <a href="/src/go/types/object.go?s=19926:19957#L614">String</a>
					<a class="permalink" href="#Nil.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Nil">Nil</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Nil.Type">func (*Nil) <a href="/src/go/types/object.go?s=4547:4577#L141">Type</a>
					<a class="permalink" href="#Nil.Type">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Nil">Nil</a>) Type() <a href="#Type">Type</a></pre>
				<p>Type returns the object&apos;s type.

				
				
				
			
		
			
			
			<h2 id="Object">type <a href="/src/go/types/object.go?s=572:2312#L13">Object</a>
				<a class="permalink" href="#Object">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>An Object describes a named language entity such as a package,
constant, type, variable, function (incl. methods), or label.
All objects implement the Object interface.

			<pre>type Object interface {
    Parent() *<a href="#Scope">Scope</a> <span class="comment">// scope in which this object is declared; nil for methods and struct fields</span>
    Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a> <span class="comment">// position of object identifier in declaration</span>
    Pkg() *<a href="#Package">Package</a>  <span class="comment">// package to which this object belongs; nil for labels and objects in the Universe scope</span>
    Name() <a href="/pkg/builtin/#string">string</a>   <span class="comment">// package local object name</span>
    Type() <a href="#Type">Type</a>     <span class="comment">// object type</span>
    Exported() <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// reports whether the name starts with a capital letter</span>
    Id() <a href="/pkg/builtin/#string">string</a>     <span class="comment">// object name if exported, qualified name if not exported (see func Id)</span>

    <span class="comment">// String returns a human-readable string of the object.</span>
    String() <a href="/pkg/builtin/#string">string</a>
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="LookupFieldOrMethod">func <a href="/src/go/types/lookup.go?s=1982:2100#L37">LookupFieldOrMethod</a>
					<a class="permalink" href="#LookupFieldOrMethod">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func LookupFieldOrMethod(T <a href="#Type">Type</a>, addressable <a href="/pkg/builtin/#bool">bool</a>, pkg *<a href="#Package">Package</a>, name <a href="/pkg/builtin/#string">string</a>) (obj <a href="#Object">Object</a>, index []<a href="/pkg/builtin/#int">int</a>, indirect <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>LookupFieldOrMethod looks up a field or method with given package and name
in T and returns the corresponding *Var or *Func, an index sequence, and a
bool indicating if there were any pointer indirections on the path to the
field or method. If addressable is set, T is the type of an addressable
variable (only matters for method lookups). T must not be nil.
<p>The last index entry is the field or method index in the (possibly embedded)
type where the entry was found, either:
<ol>
<li>the list of declared methods of a named type; or
<li>the list of all methods (method set) of an interface type; or
<li>the list of fields of a struct type.
</ol>
<p>The earlier index entries are the indices of the embedded struct fields
traversed to get to the found entry, starting at depth 0.
<p>If no entry is found, a nil object is returned. In this case, the returned
index and indirect values have the following meaning:
<ul>
<li><p>If index != nil, the index sequence points to an ambiguous entry
(the same name appeared more than once at the same embedding level).
<li><p>If indirect is set, a method with a pointer receiver type was found
but there was no pointer on the path from the actual receiver type to
the method&apos;s formal receiver base type, nor was the receiver addressable.
</ul>

				
				
			

			
		
			
			
			<h2 id="Package">type <a href="/src/go/types/package.go?s=358:787#L5">Package</a>
				<a class="permalink" href="#Package">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Package describes a Go package.

			<pre>type Package struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			
				<p>The Unsafe package is the package returned by an importer
for the import path &quot;unsafe&quot;.

				<pre>var <span id="Unsafe">Unsafe</span> *<a href="#Package">Package</a></pre>
			

			
			
			

			
				
				<h3 id="NewPackage">func <a href="/src/go/types/package.go?s=927:970#L18">NewPackage</a>
					<a class="permalink" href="#NewPackage">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewPackage(path, name <a href="/pkg/builtin/#string">string</a>) *<a href="#Package">Package</a></pre>
				<p>NewPackage returns a new Package for the given package path and name.
The package is not complete and contains no explicit imports.

				
				
			

			
				
				<h3 id="Package.Complete">func (*Package) <a href="/src/go/types/package.go?s=2132:2167#L51">Complete</a>
					<a class="permalink" href="#Package.Complete">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (pkg *<a href="#Package">Package</a>) Complete() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>A package is complete if its scope contains (at least) all
exported objects; otherwise it is incomplete.

				
				
				
			
				
				<h3 id="Package.GoVersion">func (*Package) <a href="/src/go/types/package.go?s=1649:1687#L36">GoVersion</a>
					<a class="permalink" href="#Package.GoVersion">&#xb6;</a>
					
					<span title="Added in Go 1.21">1.21</span>
				</h3>
				<pre>func (pkg *<a href="#Package">Package</a>) GoVersion() <a href="/pkg/builtin/#string">string</a></pre>
				<p>GoVersion returns the minimum Go version required by this package.
If the minimum version is unknown, GoVersion returns the empty string.
Individual source files may specify a different minimum Go version,
as reported in the <a href="/go/ast#File.GoVersion">go/ast.File.GoVersion</a> field.

				
				
				
			
				
				<h3 id="Package.Imports">func (*Package) <a href="/src/go/types/package.go?s=2742:2782#L65">Imports</a>
					<a class="permalink" href="#Package.Imports">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (pkg *<a href="#Package">Package</a>) Imports() []*<a href="#Package">Package</a></pre>
				<p>Imports returns the list of packages directly imported by
pkg; the list is in source order.
<p>If pkg was loaded from export data, Imports includes packages that
provide package-level objects referenced by pkg. This may be more or
less than the set of packages directly imported by pkg&apos;s source code.
<p>If pkg uses cgo and the FakeImportC configuration option
was enabled, the imports list may contain a fake &quot;C&quot; package.

				
				
				
			
				
				<h3 id="Package.MarkComplete">func (*Package) <a href="/src/go/types/package.go?s=2238:2272#L54">MarkComplete</a>
					<a class="permalink" href="#Package.MarkComplete">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (pkg *<a href="#Package">Package</a>) MarkComplete()</pre>
				<p>MarkComplete marks a package as complete.

				
				
				
			
				
				<h3 id="Package.Name">func (*Package) <a href="/src/go/types/package.go?s=1230:1263#L27">Name</a>
					<a class="permalink" href="#Package.Name">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (pkg *<a href="#Package">Package</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Name returns the package name.

				
				
				
			
				
				<h3 id="Package.Path">func (*Package) <a href="/src/go/types/package.go?s=1141:1174#L24">Path</a>
					<a class="permalink" href="#Package.Path">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (pkg *<a href="#Package">Package</a>) Path() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Path returns the package path.

				
				
				
			
				
				<h3 id="Package.Scope">func (*Package) <a href="/src/go/types/package.go?s=1925:1959#L42">Scope</a>
					<a class="permalink" href="#Package.Scope">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (pkg *<a href="#Package">Package</a>) Scope() *<a href="#Scope">Scope</a></pre>
				<p>Scope returns the (complete or incomplete) package scope
holding the objects declared at package level (TypeNames,
Consts, Vars, and Funcs).
For a nil pkg receiver, Scope returns the Universe scope.

				
				
				
			
				
				<h3 id="Package.SetImports">func (*Package) <a href="/src/go/types/package.go?s=2952:2999#L69">SetImports</a>
					<a class="permalink" href="#Package.SetImports">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (pkg *<a href="#Package">Package</a>) SetImports(list []*<a href="#Package">Package</a>)</pre>
				<p>SetImports sets the list of explicitly imported packages to list.
It is the caller&apos;s responsibility to make sure list elements are unique.

				
				
				
			
				
				<h3 id="Package.SetName">func (*Package) <a href="/src/go/types/package.go?s=1319:1359#L30">SetName</a>
					<a class="permalink" href="#Package.SetName">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func (pkg *<a href="#Package">Package</a>) SetName(name <a href="/pkg/builtin/#string">string</a>)</pre>
				<p>SetName sets the package name.

				
				
				
			
				
				<h3 id="Package.String">func (*Package) <a href="/src/go/types/package.go?s=3024:3059#L71">String</a>
					<a class="permalink" href="#Package.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (pkg *<a href="#Package">Package</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="PkgName">type <a href="/src/go/types/object.go?s=6928:7024#L220">PkgName</a>
				<a class="permalink" href="#PkgName">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A PkgName represents an imported Go package.
PkgNames don&apos;t have a type.

			<pre>type PkgName struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewPkgName">func <a href="/src/go/types/object.go?s=7173:7258#L228">NewPkgName</a>
					<a class="permalink" href="#NewPkgName">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewPkgName(pos <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>, pkg *<a href="#Package">Package</a>, name <a href="/pkg/builtin/#string">string</a>, imported *<a href="#Package">Package</a>) *<a href="#PkgName">PkgName</a></pre>
				<p>NewPkgName returns a new PkgName object representing an imported package.
The remaining arguments set the attributes found with all Objects.

				
				
			

			
				
				<h3 id="PkgName.Exported">func (*PkgName) <a href="/src/go/types/object.go?s=4774:4808#L146">Exported</a>
					<a class="permalink" href="#PkgName.Exported">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#PkgName">PkgName</a>) Exported() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Exported reports whether the object is exported (starts with a capital letter).
It doesn&apos;t take into account whether the object is in a local (function) scope
or not.

				
				
				
			
				
				<h3 id="PkgName.Id">func (*PkgName) <a href="/src/go/types/object.go?s=4892:4922#L149">Id</a>
					<a class="permalink" href="#PkgName.Id">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#PkgName">PkgName</a>) Id() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Id is a wrapper for Id(obj.Pkg(), obj.Name()).

				
				
				
			
				
				<h3 id="PkgName.Imported">func (*PkgName) <a href="/src/go/types/object.go?s=7493:7532#L234">Imported</a>
					<a class="permalink" href="#PkgName.Imported">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#PkgName">PkgName</a>) Imported() *<a href="#Package">Package</a></pre>
				<p>Imported returns the package that was imported.
It is distinct from Pkg(), which is the package containing the import statement.

				
				
				
			
				
				<h3 id="PkgName.Name">func (*PkgName) <a href="/src/go/types/object.go?s=4458:4490#L138">Name</a>
					<a class="permalink" href="#PkgName.Name">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#PkgName">PkgName</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Name returns the object&apos;s (package-local, unqualified) name.

				
				
				
			
				
				<h3 id="PkgName.Parent">func (*PkgName) <a href="/src/go/types/object.go?s=4036:4070#L128">Parent</a>
					<a class="permalink" href="#PkgName.Parent">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#PkgName">PkgName</a>) Parent() *<a href="#Scope">Scope</a></pre>
				<p>Parent returns the scope in which the object is declared.
The result is nil for methods and struct fields.

				
				
				
			
				
				<h3 id="PkgName.Pkg">func (*PkgName) <a href="/src/go/types/object.go?s=4340:4373#L135">Pkg</a>
					<a class="permalink" href="#PkgName.Pkg">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#PkgName">PkgName</a>) Pkg() *<a href="#Package">Package</a></pre>
				<p>Pkg returns the package to which the object belongs.
The result is nil for labels and objects in the Universe scope.

				
				
				
			
				
				<h3 id="PkgName.Pos">func (*PkgName) <a href="/src/go/types/object.go?s=4162:4196#L131">Pos</a>
					<a class="permalink" href="#PkgName.Pos">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#PkgName">PkgName</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				<p>Pos returns the declaration position of the object&apos;s identifier.

				
				
				
			
				
				<h3 id="PkgName.String">func (*PkgName) <a href="/src/go/types/object.go?s=19429:19464#L607">String</a>
					<a class="permalink" href="#PkgName.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#PkgName">PkgName</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="PkgName.Type">func (*PkgName) <a href="/src/go/types/object.go?s=4547:4577#L141">Type</a>
					<a class="permalink" href="#PkgName.Type">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#PkgName">PkgName</a>) Type() <a href="#Type">Type</a></pre>
				<p>Type returns the object&apos;s type.

				
				
				
			
		
			
			
			<h2 id="Pointer">type <a href="/src/go/types/pointer.go?s=342:392#L1">Pointer</a>
				<a class="permalink" href="#Pointer">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Pointer represents a pointer type.

			<pre>type Pointer struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewPointer">func <a href="/src/go/types/pointer.go?s=470:505#L6">NewPointer</a>
					<a class="permalink" href="#NewPointer">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewPointer(elem <a href="#Type">Type</a>) *<a href="#Pointer">Pointer</a></pre>
				<p>NewPointer returns a new pointer type for the given element (base) type.

				
				
			

			
				
				<h3 id="Pointer.Elem">func (*Pointer) <a href="/src/go/types/pointer.go?s=597:626#L9">Elem</a>
					<a class="permalink" href="#Pointer.Elem">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (p *<a href="#Pointer">Pointer</a>) Elem() <a href="#Type">Type</a></pre>
				<p>Elem returns the element type for the given pointer p.

				
				
				
			
				
				<h3 id="Pointer.String">func (*Pointer) <a href="/src/go/types/pointer.go?s=695:728#L12">String</a>
					<a class="permalink" href="#Pointer.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (p *<a href="#Pointer">Pointer</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Pointer.Underlying">func (*Pointer) <a href="/src/go/types/pointer.go?s=646:681#L11">Underlying</a>
					<a class="permalink" href="#Pointer.Underlying">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (p *<a href="#Pointer">Pointer</a>) Underlying() <a href="#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Qualifier">type <a href="/src/go/types/typestring.go?s=962:998#L21">Qualifier</a>
				<a class="permalink" href="#Qualifier">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Qualifier controls how named package-level objects are printed in
calls to <a href="#TypeString">TypeString</a>, <a href="#ObjectString">ObjectString</a>, and <a href="#SelectionString">SelectionString</a>.
<p>These three formatting routines call the Qualifier for each
package-level object O, and if the Qualifier returns a non-empty
string p, the object is printed in the form p.O.
If it returns an empty string, only the object name O is printed.
<p>Using a nil Qualifier is equivalent to using (*<a href="#Package">Package</a>).Path: the
object is qualified by the import path, e.g., &quot;encoding/json.Marshal&quot;.

			<pre>type Qualifier func(*<a href="#Package">Package</a>) <a href="/pkg/builtin/#string">string</a></pre>

			

			

			
			
			

			
				
				<h3 id="RelativeTo">func <a href="/src/go/types/typestring.go?s=1100:1139#L25">RelativeTo</a>
					<a class="permalink" href="#RelativeTo">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func RelativeTo(pkg *<a href="#Package">Package</a>) <a href="#Qualifier">Qualifier</a></pre>
				<p>RelativeTo returns a <a href="#Qualifier">Qualifier</a> that fully qualifies members of
all packages other than pkg.

				
				
			

			
		
			
			
			<h2 id="Scope">type <a href="/src/go/types/scope.go?s=617:1011#L15">Scope</a>
				<a class="permalink" href="#Scope">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Scope maintains a set of objects and links to its containing
(parent) and contained (children) scopes. Objects may be inserted
and looked up by name. The zero value for Scope is a ready-to-use
empty scope.

			<pre>type Scope struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			
				<p>The Universe scope contains all predeclared objects of Go.
It is the outermost scope of any chain of nested scopes.

				<pre>var <span id="Universe">Universe</span> *<a href="#Scope">Scope</a></pre>
			

			<div id="example_Scope" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		<p>ExampleScope prints the tree of Scopes of a package created from a
set of parsed files.
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Parse the source files for a package.</span>
fset := token.NewFileSet()
var files []*ast.File
for _, src := range []string{
    `package main
import &#34;fmt&#34;
func main() {
    freezing := FToC(-18)
    fmt.Println(freezing, Boiling) }
`,
    `package main
import &#34;fmt&#34;
type Celsius float64
func (c Celsius) String() string { return fmt.Sprintf(&#34;%g°C&#34;, c) }
func FToC(f float64) Celsius { return Celsius(f - 32 / 9 * 5) }
const Boiling Celsius = 100
func Unused() { {}; {{ var x int; _ = x }} } // make sure empty block scopes get printed
`,
} {
    files = append(files, mustParse(fset, src))
}

<span class="comment">// Type-check a package consisting of these files.</span>
<span class="comment">// Type information for the imported &#34;fmt&#34; package</span>
<span class="comment">// comes from $GOROOT/pkg/$GOOS_$GOOARCH/fmt.a.</span>
conf := types.Config{Importer: importer.Default()}
pkg, err := conf.Check(&#34;temperature&#34;, fset, files, nil)
if err != nil {
    log.Fatal(err)
}

<span class="comment">// Print the tree of scopes.</span>
<span class="comment">// For determinism, we redact addresses.</span>
var buf strings.Builder
pkg.Scope().WriteTo(&amp;buf, 0, true)
rx := regexp.MustCompile(` 0x[a-fA-F\d]*`)
fmt.Println(rx.ReplaceAllString(buf.String(), &#34;&#34;))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">package &#34;temperature&#34; scope {
.  const temperature.Boiling temperature.Celsius
.  type temperature.Celsius float64
.  func temperature.FToC(f float64) temperature.Celsius
.  func temperature.Unused()
.  func temperature.main()
.  main scope {
.  .  package fmt
.  .  function scope {
.  .  .  var freezing temperature.Celsius
.  .  }
.  }
.  main scope {
.  .  package fmt
.  .  function scope {
.  .  .  var c temperature.Celsius
.  .  }
.  .  function scope {
.  .  .  var f float64
.  .  }
.  .  function scope {
.  .  .  block scope {
.  .  .  }
.  .  .  block scope {
.  .  .  .  block scope {
.  .  .  .  .  var x int
.  .  .  .  }
.  .  .  }
.  .  }
.  }
}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewScope">func <a href="/src/go/types/scope.go?s=1135:1206#L27">NewScope</a>
					<a class="permalink" href="#NewScope">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewScope(parent *<a href="#Scope">Scope</a>, pos, end <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>, comment <a href="/pkg/builtin/#string">string</a>) *<a href="#Scope">Scope</a></pre>
				<p>NewScope returns a new, empty scope contained in the given parent
scope, if any. The comment is for debugging only.

				
				
			

			
				
				<h3 id="Scope.Child">func (*Scope) <a href="/src/go/types/scope.go?s=2077:2112#L59">Child</a>
					<a class="permalink" href="#Scope.Child">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Scope">Scope</a>) Child(i <a href="/pkg/builtin/#int">int</a>) *<a href="#Scope">Scope</a></pre>
				<p>Child returns the i&apos;th child scope for 0 &lt;= i &lt; NumChildren().

				
				
				
			
				
				<h3 id="Scope.Contains">func (*Scope) <a href="/src/go/types/scope.go?s=6302:6346#L182">Contains</a>
					<a class="permalink" href="#Scope.Contains">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Scope">Scope</a>) Contains(pos <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Contains reports whether pos is within the scope&apos;s extent.
The result is guaranteed to be valid only if the type-checked
AST has complete position information.

				
				
				
			
				
				<h3 id="Scope.End">func (*Scope) <a href="/src/go/types/scope.go?s=6083:6114#L177">End</a>
					<a class="permalink" href="#Scope.End">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Scope">Scope</a>) End() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Scope.Innermost">func (*Scope) <a href="/src/go/types/scope.go?s=6686:6733#L191">Innermost</a>
					<a class="permalink" href="#Scope.Innermost">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Scope">Scope</a>) Innermost(pos <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>) *<a href="#Scope">Scope</a></pre>
				<p>Innermost returns the innermost (child) scope containing
pos. If pos is not within any scope, the result is nil.
The result is also nil for the Universe scope.
The result is guaranteed to be valid only if the type-checked
AST has complete position information.

				
				
				
			
				
				<h3 id="Scope.Insert">func (*Scope) <a href="/src/go/types/scope.go?s=3989:4030#L103">Insert</a>
					<a class="permalink" href="#Scope.Insert">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Scope">Scope</a>) Insert(obj <a href="#Object">Object</a>) <a href="#Object">Object</a></pre>
				<p>Insert attempts to insert an object obj into scope s.
If s already contains an alternative object alt with
the same name, Insert leaves s unchanged and returns alt.
Otherwise it inserts obj, sets the object&apos;s parent scope
if not already set, and returns nil.

				
				
				
			
				
				<h3 id="Scope.Len">func (*Scope) <a href="/src/go/types/scope.go?s=1605:1630#L41">Len</a>
					<a class="permalink" href="#Scope.Len">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Scope">Scope</a>) Len() <a href="/pkg/builtin/#int">int</a></pre>
				<p>Len returns the number of scope elements.

				
				
				
			
				
				<h3 id="Scope.Lookup">func (*Scope) <a href="/src/go/types/scope.go?s=2257:2299#L63">Lookup</a>
					<a class="permalink" href="#Scope.Lookup">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Scope">Scope</a>) Lookup(name <a href="/pkg/builtin/#string">string</a>) <a href="#Object">Object</a></pre>
				<p>Lookup returns the object in scope s with the given name if such an
object exists; otherwise the result is nil.

				
				
				
			
				
				<h3 id="Scope.LookupParent">func (*Scope) <a href="/src/go/types/scope.go?s=3466:3539#L89">LookupParent</a>
					<a class="permalink" href="#Scope.LookupParent">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Scope">Scope</a>) LookupParent(name <a href="/pkg/builtin/#string">string</a>, pos <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>) (*<a href="#Scope">Scope</a>, <a href="#Object">Object</a>)</pre>
				<p>LookupParent follows the parent chain of scopes starting with s until
it finds a scope where Lookup(name) returns a non-nil object, and then
returns that scope and object. If a valid position pos is provided,
only objects that were declared at or before pos are considered.
If no such scope and object exists, the result is (nil, nil).
<p>Note that obj.Parent() may be different from the returned scope if the
object was inserted into the scope and already had a parent at that
time (see Insert). This can only happen for dot-imported objects
whose scope is the scope of the package that exported them.

				
				
				
			
				
				<h3 id="Scope.Names">func (*Scope) <a href="/src/go/types/scope.go?s=1716:1748#L44">Names</a>
					<a class="permalink" href="#Scope.Names">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Scope">Scope</a>) Names() []<a href="/pkg/builtin/#string">string</a></pre>
				<p>Names returns the scope&apos;s element names in sorted order.

				
				
				
			
				
				<h3 id="Scope.NumChildren">func (*Scope) <a href="/src/go/types/scope.go?s=1949:1982#L56">NumChildren</a>
					<a class="permalink" href="#Scope.NumChildren">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Scope">Scope</a>) NumChildren() <a href="/pkg/builtin/#int">int</a></pre>
				<p>NumChildren returns the number of scopes nested in s.

				
				
				
			
				
				<h3 id="Scope.Parent">func (*Scope) <a href="/src/go/types/scope.go?s=1507:1538#L38">Parent</a>
					<a class="permalink" href="#Scope.Parent">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Scope">Scope</a>) Parent() *<a href="#Scope">Scope</a></pre>
				<p>Parent returns the scope&apos;s containing (parent) scope.

				
				
				
			
				
				<h3 id="Scope.Pos">func (*Scope) <a href="/src/go/types/scope.go?s=6034:6065#L176">Pos</a>
					<a class="permalink" href="#Scope.Pos">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Scope">Scope</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				<p>Pos and End describe the scope&apos;s source code extent [pos, end).
The results are guaranteed to be valid only if the type-checked
AST has complete position information. The extent is undefined
for Universe and package scopes.

				
				
				
			
				
				<h3 id="Scope.String">func (*Scope) <a href="/src/go/types/scope.go?s=7856:7887#L239">String</a>
					<a class="permalink" href="#Scope.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Scope">Scope</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>String returns a string representation of the scope, for debugging.

				
				
				
			
				
				<h3 id="Scope.WriteTo">func (*Scope) <a href="/src/go/types/scope.go?s=7387:7444#L218">WriteTo</a>
					<a class="permalink" href="#Scope.WriteTo">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Scope">Scope</a>) WriteTo(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>, n <a href="/pkg/builtin/#int">int</a>, recurse <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>WriteTo writes a string representation of the scope to w,
with the scope elements sorted by name.
The level of indentation is controlled by n &gt;= 0, with
n == 0 for no indentation.
If recurse is set, it also writes nested (children) scopes.

				
				
				
			
		
			
			
			<h2 id="Selection">type <a href="/src/go/types/selection.go?s=2792:3025#L65">Selection</a>
				<a class="permalink" href="#Selection">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Selection describes a selector expression x.f.
For the declarations:
<pre>type T struct{ x int; E }
type E struct{}
func (e E) m() {}
var p *T
</pre>
<p>the following relations exist:
<pre>Selector    Kind          Recv    Obj    Type       Index     Indirect

p.x         FieldVal      T       x      int        {0}       true
p.m         MethodVal     *T      m      func()     {1, 0}    true
T.m         MethodExpr    T       m      func(T)    {1, 0}    false
</pre>

			<pre>type Selection struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Selection.Index">func (*Selection) <a href="/src/go/types/selection.go?s=4792:4825#L127">Index</a>
					<a class="permalink" href="#Selection.Index">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Selection">Selection</a>) Index() []<a href="/pkg/builtin/#int">int</a></pre>
				<p>Index describes the path from x to f in x.f.
The last index entry is the field or method index of the type declaring f;
either:
<ol>
<li>the list of declared methods of a named type; or
<li>the list of methods of an interface type; or
<li>the list of fields of a struct type.
</ol>
<p>The earlier index entries are the indices of the embedded fields implicitly
traversed to get from (the type of) x to f, starting at embedding depth 0.

				
				
				
			
				
				<h3 id="Selection.Indirect">func (*Selection) <a href="/src/go/types/selection.go?s=5166:5201#L136">Indirect</a>
					<a class="permalink" href="#Selection.Indirect">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Selection">Selection</a>) Indirect() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Indirect reports whether any pointer indirection was required to get from
x to f in x.f.
<p>Beware: Indirect spuriously returns true (Go issue #8353) for a
MethodVal selection in which the receiver argument and parameter
both have type *T so there is no indirection.
Unfortunately, a fix is too risky.

				
				
				
			
				
				<h3 id="Selection.Kind">func (*Selection) <a href="/src/go/types/selection.go?s=3063:3103#L74">Kind</a>
					<a class="permalink" href="#Selection.Kind">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Selection">Selection</a>) Kind() <a href="#SelectionKind">SelectionKind</a></pre>
				<p>Kind returns the selection kind.

				
				
				
			
				
				<h3 id="Selection.Obj">func (*Selection) <a href="/src/go/types/selection.go?s=3319:3351#L81">Obj</a>
					<a class="permalink" href="#Selection.Obj">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Selection">Selection</a>) Obj() <a href="#Object">Object</a></pre>
				<p>Obj returns the object denoted by x.f; a *Var for
a field selection, and a *Func in all other cases.

				
				
				
			
				
				<h3 id="Selection.Recv">func (*Selection) <a href="/src/go/types/selection.go?s=3161:3192#L77">Recv</a>
					<a class="permalink" href="#Selection.Recv">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Selection">Selection</a>) Recv() <a href="#Type">Type</a></pre>
				<p>Recv returns the type of x in x.f.

				
				
				
			
				
				<h3 id="Selection.String">func (*Selection) <a href="/src/go/types/selection.go?s=5225:5260#L138">String</a>
					<a class="permalink" href="#Selection.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Selection">Selection</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Selection.Type">func (*Selection) <a href="/src/go/types/selection.go?s=3485:3516#L85">Type</a>
					<a class="permalink" href="#Selection.Type">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Selection">Selection</a>) Type() <a href="#Type">Type</a></pre>
				<p>Type returns the type of x.f, which may be different from the type of f.
See Selection for more information.

				
				
				
			
		
			
			
			<h2 id="SelectionKind">type <a href="/src/go/types/selection.go?s=2077:2099#L42">SelectionKind</a>
				<a class="permalink" href="#SelectionKind">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>SelectionKind describes the kind of a selector expression x.f
(excluding qualified identifiers).
<p>If x is a struct or *struct, a selector expression x.f may denote a
sequence of selection operations x.a.b.c.f. The SelectionKind
describes the kind of the final (explicit) operation; all the
previous (implicit) operations are always field selections.
Each element of Indices specifies an implicit field (a, b, c)
by its index in the struct type of the field selection operand.
<p>For a FieldVal operation, the final selection refers to the field
specified by Selection.Obj.
<p>For a MethodVal operation, the final selection refers to a method.
If the &quot;pointerness&quot; of the method&apos;s declared receiver does not
match that of the effective receiver after implicit field
selection, then an &amp; or * operation is implicitly applied to the
receiver variable or value.
So, x.f denotes (&amp;x.a.b.c).f when f requires a pointer receiver but
x.a.b.c is a non-pointer variable; and it denotes (*x.a.b.c).f when
f requires a non-pointer receiver but x.a.b.c is a pointer value.
<p>All pointer indirections, whether due to implicit or explicit field
selections or * operations inserted for &quot;pointerness&quot;, panic if
applied to a nil pointer, so a method call x.f() may panic even
before the function call.
<p>By contrast, a MethodExpr operation T.f is essentially equivalent
to a function literal of the form:
<pre>func(x T, args) (results) { return x.f(args) }
</pre>
<p>Consequently, any implicit field selections and * operations
inserted for &quot;pointerness&quot; are not evaluated until the function is
called, so a T.f or (*T).f expression never panics.

			<pre>type SelectionKind <a href="/pkg/builtin/#int">int</a></pre>

			
				
				<pre>const (
    <span id="FieldVal">FieldVal</span>   <a href="#SelectionKind">SelectionKind</a> = <a href="/pkg/builtin/#iota">iota</a> <span class="comment">// x.f is a struct field selector</span>
    <span id="MethodVal">MethodVal</span>                       <span class="comment">// x.f is a method selector</span>
    <span id="MethodExpr">MethodExpr</span>                      <span class="comment">// x.f is a method expression</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="Signature">type <a href="/src/go/types/signature.go?s=465:1366#L9">Signature</a>
				<a class="permalink" href="#Signature">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Signature represents a (non-builtin) function or method type.
The receiver is ignored when comparing signatures for identity.

			<pre>type Signature struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewSignature">func <a href="/src/go/types/signature.go?s=1718:1796#L29">NewSignature</a>
					<a class="permalink" href="#NewSignature">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewSignature(recv *<a href="#Var">Var</a>, params, results *<a href="#Tuple">Tuple</a>, variadic <a href="/pkg/builtin/#bool">bool</a>) *<a href="#Signature">Signature</a></pre>
				<p>NewSignature returns a new function type for the given receiver, parameters,
and results, either of which may be nil. If variadic is set, the function
is variadic, it must have at least one parameter, and the last parameter
must be of unnamed slice type.
<p>Deprecated: Use <a href="#NewSignatureType">NewSignatureType</a> instead which allows for type parameters.

				
				
			
				
				<h3 id="NewSignatureType">func <a href="/src/go/types/signature.go?s=2265:2388#L39">NewSignatureType</a>
					<a class="permalink" href="#NewSignatureType">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func NewSignatureType(recv *<a href="#Var">Var</a>, recvTypeParams, typeParams []*<a href="#TypeParam">TypeParam</a>, params, results *<a href="#Tuple">Tuple</a>, variadic <a href="/pkg/builtin/#bool">bool</a>) *<a href="#Signature">Signature</a></pre>
				<p>NewSignatureType creates a new function type for the given receiver,
receiver type parameters, type parameters, parameters, and results. If
variadic is set, params must hold at least one parameter and the last
parameter&apos;s core type must be of unnamed slice or bytestring type.
If recv is non-nil, typeParams must be empty. If recvTypeParams is
non-empty, recv must be non-nil.

				
				
			

			
				
				<h3 id="Signature.Params">func (*Signature) <a href="/src/go/types/signature.go?s=3907:3942#L81">Params</a>
					<a class="permalink" href="#Signature.Params">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Signature">Signature</a>) Params() *<a href="#Tuple">Tuple</a></pre>
				<p>Params returns the parameters of signature s, or nil.

				
				
				
			
				
				<h3 id="Signature.Recv">func (*Signature) <a href="/src/go/types/signature.go?s=3510:3541#L72">Recv</a>
					<a class="permalink" href="#Signature.Recv">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Signature">Signature</a>) Recv() *<a href="#Var">Var</a></pre>
				<p>Recv returns the receiver of signature s (if a method), or nil if a
function. It is ignored when comparing signatures for identity.
<p>For an abstract method, Recv returns the enclosing interface either
as a *<a href="#Named">Named</a> or an *<a href="#Interface">Interface</a>. Due to embedding, an interface may
contain methods whose receiver type is a different interface.

				
				
				
			
				
				<h3 id="Signature.RecvTypeParams">func (*Signature) <a href="/src/go/types/signature.go?s=3776:3827#L78">RecvTypeParams</a>
					<a class="permalink" href="#Signature.RecvTypeParams">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (s *<a href="#Signature">Signature</a>) RecvTypeParams() *<a href="#TypeParamList">TypeParamList</a></pre>
				<p>RecvTypeParams returns the receiver type parameters of signature s, or nil.

				
				
				
			
				
				<h3 id="Signature.Results">func (*Signature) <a href="/src/go/types/signature.go?s=4019:4055#L84">Results</a>
					<a class="permalink" href="#Signature.Results">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Signature">Signature</a>) Results() *<a href="#Tuple">Tuple</a></pre>
				<p>Results returns the results of signature s, or nil.

				
				
				
			
				
				<h3 id="Signature.String">func (*Signature) <a href="/src/go/types/signature.go?s=4245:4280#L90">String</a>
					<a class="permalink" href="#Signature.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Signature">Signature</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Signature.TypeParams">func (*Signature) <a href="/src/go/types/signature.go?s=3627:3674#L75">TypeParams</a>
					<a class="permalink" href="#Signature.TypeParams">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (s *<a href="#Signature">Signature</a>) TypeParams() *<a href="#TypeParamList">TypeParamList</a></pre>
				<p>TypeParams returns the type parameters of signature s, or nil.

				
				
				
			
				
				<h3 id="Signature.Underlying">func (*Signature) <a href="/src/go/types/signature.go?s=4194:4231#L89">Underlying</a>
					<a class="permalink" href="#Signature.Underlying">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Signature">Signature</a>) Underlying() <a href="#Type">Type</a></pre>
				
				
				
				
			
				
				<h3 id="Signature.Variadic">func (*Signature) <a href="/src/go/types/signature.go?s=4135:4170#L87">Variadic</a>
					<a class="permalink" href="#Signature.Variadic">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Signature">Signature</a>) Variadic() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Variadic reports whether the signature s is variadic.

				
				
				
			
		
			
			
			<h2 id="Sizes">type <a href="/src/go/types/sizes.go?s=390:1051#L3">Sizes</a>
				<a class="permalink" href="#Sizes">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>Sizes defines the sizing functions for package unsafe.

			<pre>type Sizes interface {
    <span class="comment">// Alignof returns the alignment of a variable of type T.</span>
    <span class="comment">// Alignof must implement the alignment guarantees required by the spec.</span>
    <span class="comment">// The result must be &gt;= 1.</span>
    Alignof(T <a href="#Type">Type</a>) <a href="/pkg/builtin/#int64">int64</a>

    <span class="comment">// Offsetsof returns the offsets of the given struct fields, in bytes.</span>
    <span class="comment">// Offsetsof must implement the offset guarantees required by the spec.</span>
    <span class="comment">// A negative entry in the result indicates that the struct is too large.</span>
    Offsetsof(fields []*<a href="#Var">Var</a>) []<a href="/pkg/builtin/#int64">int64</a>

    <span class="comment">// Sizeof returns the size of a variable of type T.</span>
    <span class="comment">// Sizeof must implement the size guarantees required by the spec.</span>
    <span class="comment">// A negative result indicates that T is too large.</span>
    Sizeof(T <a href="#Type">Type</a>) <a href="/pkg/builtin/#int64">int64</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="SizesFor">func <a href="/src/go/types/sizes.go?s=7197:7239#L250">SizesFor</a>
					<a class="permalink" href="#SizesFor">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func SizesFor(compiler, arch <a href="/pkg/builtin/#string">string</a>) <a href="#Sizes">Sizes</a></pre>
				<p>SizesFor returns the Sizes used by a compiler for an architecture.
The result is nil if a compiler/architecture pair is not known.
<p>Supported architectures for compiler &quot;gc&quot;:
&quot;386&quot;, &quot;amd64&quot;, &quot;amd64p32&quot;, &quot;arm&quot;, &quot;arm64&quot;, &quot;loong64&quot;, &quot;mips&quot;, &quot;mipsle&quot;,
&quot;mips64&quot;, &quot;mips64le&quot;, &quot;ppc64&quot;, &quot;ppc64le&quot;, &quot;riscv64&quot;, &quot;s390x&quot;, &quot;sparc64&quot;, &quot;wasm&quot;.

				
				
			

			
		
			
			
			<h2 id="Slice">type <a href="/src/go/types/slice.go?s=336:368#L1">Slice</a>
				<a class="permalink" href="#Slice">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Slice represents a slice type.

			<pre>type Slice struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewSlice">func <a href="/src/go/types/slice.go?s=435:466#L6">NewSlice</a>
					<a class="permalink" href="#NewSlice">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewSlice(elem <a href="#Type">Type</a>) *<a href="#Slice">Slice</a></pre>
				<p>NewSlice returns a new slice type for the given element type.

				
				
			

			
				
				<h3 id="Slice.Elem">func (*Slice) <a href="/src/go/types/slice.go?s=543:570#L9">Elem</a>
					<a class="permalink" href="#Slice.Elem">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Slice">Slice</a>) Elem() <a href="#Type">Type</a></pre>
				<p>Elem returns the element type of slice s.

				
				
				
			
				
				<h3 id="Slice.String">func (*Slice) <a href="/src/go/types/slice.go?s=637:668#L12">String</a>
					<a class="permalink" href="#Slice.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Slice">Slice</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Slice.Underlying">func (*Slice) <a href="/src/go/types/slice.go?s=590:623#L11">Underlying</a>
					<a class="permalink" href="#Slice.Underlying">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Slice">Slice</a>) Underlying() <a href="#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="StdSizes">type <a href="/src/go/types/sizes.go?s=1957:2104#L38">StdSizes</a>
				<a class="permalink" href="#StdSizes">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>StdSizes is a convenience type for creating commonly used Sizes.
It makes the following simplifying assumptions:
<ul>
<li>The size of explicitly sized basic types (int16, etc.) is the
specified size.
<li>The size of strings and interfaces is 2*WordSize.
<li>The size of slices is 3*WordSize.
<li>The size of an array of n elements corresponds to the size of
a struct of n consecutive fields of the array&apos;s element type.
<li>The size of a struct is the offset of the last field plus that
field&apos;s size. As with all element types, if the struct is used
in an array its size must first be aligned to a multiple of the
struct&apos;s alignment.
<li>All other types have size WordSize.
<li>Arrays and structs are aligned per spec definition; all other
types are naturally aligned with a maximum alignment MaxAlign.
</ul>
<p>*StdSizes implements Sizes.

			<pre>type StdSizes struct {
<span id="StdSizes.WordSize"></span>    WordSize <a href="/pkg/builtin/#int64">int64</a> <span class="comment">// word size in bytes - must be &gt;= 4 (32bits)</span>
<span id="StdSizes.MaxAlign"></span>    MaxAlign <a href="/pkg/builtin/#int64">int64</a> <span class="comment">// maximum alignment in bytes - must be &gt;= 1</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="StdSizes.Alignof">func (*StdSizes) <a href="/src/go/types/sizes.go?s=2106:2155#L43">Alignof</a>
					<a class="permalink" href="#StdSizes.Alignof">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#StdSizes">StdSizes</a>) Alignof(T <a href="#Type">Type</a>) (result <a href="/pkg/builtin/#int64">int64</a>)</pre>
				
				
				
				
			
				
				<h3 id="StdSizes.Offsetsof">func (*StdSizes) <a href="/src/go/types/sizes.go?s=4143:4194#L119">Offsetsof</a>
					<a class="permalink" href="#StdSizes.Offsetsof">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#StdSizes">StdSizes</a>) Offsetsof(fields []*<a href="#Var">Var</a>) []<a href="/pkg/builtin/#int64">int64</a></pre>
				
				
				
				
			
				
				<h3 id="StdSizes.Sizeof">func (*StdSizes) <a href="/src/go/types/sizes.go?s=4898:4937#L157">Sizeof</a>
					<a class="permalink" href="#StdSizes.Sizeof">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#StdSizes">StdSizes</a>) Sizeof(T <a href="#Type">Type</a>) <a href="/pkg/builtin/#int64">int64</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Struct">type <a href="/src/go/types/struct.go?s=373:550#L8">Struct</a>
				<a class="permalink" href="#Struct">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Struct represents a struct type.

			<pre>type Struct struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewStruct">func <a href="/src/go/types/struct.go?s=850:902#L17">NewStruct</a>
					<a class="permalink" href="#NewStruct">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewStruct(fields []*<a href="#Var">Var</a>, tags []<a href="/pkg/builtin/#string">string</a>) *<a href="#Struct">Struct</a></pre>
				<p>NewStruct returns a new struct with the given fields and corresponding field tags.
If a field with index i has a tag, tags[i] must be that tag, but len(tags) may be
only as long as required to hold the tag with the largest index i. Consequently,
if no field has a tag, tags may be nil.

				
				
			

			
				
				<h3 id="Struct.Field">func (*Struct) <a href="/src/go/types/struct.go?s=1401:1435#L36">Field</a>
					<a class="permalink" href="#Struct.Field">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Struct">Struct</a>) Field(i <a href="/pkg/builtin/#int">int</a>) *<a href="#Var">Var</a></pre>
				<p>Field returns the i&apos;th field for 0 &lt;= i &lt; NumFields().

				
				
				
			
				
				<h3 id="Struct.NumFields">func (*Struct) <a href="/src/go/types/struct.go?s=1284:1316#L33">NumFields</a>
					<a class="permalink" href="#Struct.NumFields">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Struct">Struct</a>) NumFields() <a href="/pkg/builtin/#int">int</a></pre>
				<p>NumFields returns the number of fields in the struct (including blank and embedded fields).

				
				
				
			
				
				<h3 id="Struct.String">func (*Struct) <a href="/src/go/types/struct.go?s=1663:1695#L47">String</a>
					<a class="permalink" href="#Struct.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Struct">Struct</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Struct.Tag">func (*Struct) <a href="/src/go/types/struct.go?s=1520:1554#L39">Tag</a>
					<a class="permalink" href="#Struct.Tag">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (s *<a href="#Struct">Struct</a>) Tag(i <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#string">string</a></pre>
				<p>Tag returns the i&apos;th field tag for 0 &lt;= i &lt; NumFields().

				
				
				
			
				
				<h3 id="Struct.Underlying">func (*Struct) <a href="/src/go/types/struct.go?s=1615:1649#L46">Underlying</a>
					<a class="permalink" href="#Struct.Underlying">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Struct">Struct</a>) Underlying() <a href="#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Term">type <a href="/src/go/types/union.go?s=1009:1023#L27">Term</a>
				<a class="permalink" href="#Term">&#xb6;</a>
				
				<span title="Added in Go 1.18">1.18</span>
			</h2>
			<p>A Term represents a term in a <a href="#Union">Union</a>.

			<pre>type Term term</pre>

			

			

			
			
			

			
				
				<h3 id="NewTerm">func <a href="/src/go/types/union.go?s=1062:1102#L30">NewTerm</a>
					<a class="permalink" href="#NewTerm">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func NewTerm(tilde <a href="/pkg/builtin/#bool">bool</a>, typ <a href="#Type">Type</a>) *<a href="#Term">Term</a></pre>
				<p>NewTerm returns a new union term.

				
				
			

			
				
				<h3 id="Term.String">func (*Term) <a href="/src/go/types/union.go?s=1231:1261#L34">String</a>
					<a class="permalink" href="#Term.String">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#Term">Term</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Term.Tilde">func (*Term) <a href="/src/go/types/union.go?s=1133:1160#L32">Tilde</a>
					<a class="permalink" href="#Term.Tilde">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#Term">Term</a>) Tilde() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="Term.Type">func (*Term) <a href="/src/go/types/union.go?s=1183:1209#L33">Type</a>
					<a class="permalink" href="#Term.Type">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#Term">Term</a>) Type() <a href="#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Tuple">type <a href="/src/go/types/tuple.go?s=530:564#L3">Tuple</a>
				<a class="permalink" href="#Tuple">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Tuple represents an ordered list of variables; a nil *Tuple is a valid (empty) tuple.
Tuples are used as components of signatures and to represent the type of multiple
assignments; they are not first class types of Go.

			<pre>type Tuple struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewTuple">func <a href="/src/go/types/tuple.go?s=623:654#L8">NewTuple</a>
					<a class="permalink" href="#NewTuple">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewTuple(x ...*<a href="#Var">Var</a>) *<a href="#Tuple">Tuple</a></pre>
				<p>NewTuple returns a new tuple for the given variables.

				
				
			

			
				
				<h3 id="Tuple.At">func (*Tuple) <a href="/src/go/types/tuple.go?s=889:919#L24">At</a>
					<a class="permalink" href="#Tuple.At">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Tuple">Tuple</a>) At(i <a href="/pkg/builtin/#int">int</a>) *<a href="#Var">Var</a></pre>
				<p>At returns the i&apos;th variable of tuple t.

				
				
				
			
				
				<h3 id="Tuple.Len">func (*Tuple) <a href="/src/go/types/tuple.go?s=765:790#L16">Len</a>
					<a class="permalink" href="#Tuple.Len">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Tuple">Tuple</a>) Len() <a href="/pkg/builtin/#int">int</a></pre>
				<p>Len returns the number variables of tuple t.

				
				
				
			
				
				<h3 id="Tuple.String">func (*Tuple) <a href="/src/go/types/tuple.go?s=989:1020#L27">String</a>
					<a class="permalink" href="#Tuple.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Tuple">Tuple</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Tuple.Underlying">func (*Tuple) <a href="/src/go/types/tuple.go?s=942:975#L26">Underlying</a>
					<a class="permalink" href="#Tuple.Underlying">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (t *<a href="#Tuple">Tuple</a>) Underlying() <a href="#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Type">type <a href="/src/go/types/type.go?s=253:540#L1">Type</a>
				<a class="permalink" href="#Type">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Type represents a type of Go.
All types implement the Type interface.

			<pre>type Type interface {
    <span class="comment">// Underlying returns the underlying type of a type.</span>
    <span class="comment">// Underlying types are never Named, TypeParam, or Alias types.</span>
    <span class="comment">//</span>
    <span class="comment">// See https://go.dev/ref/spec#Underlying_types.</span>
    Underlying() <a href="#Type">Type</a>

    <span class="comment">// String returns a string representation of a type.</span>
    String() <a href="/pkg/builtin/#string">string</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="Default">func <a href="/src/go/types/predicates.go?s=16747:16772#L516">Default</a>
					<a class="permalink" href="#Default">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func Default(t <a href="#Type">Type</a>) <a href="#Type">Type</a></pre>
				<p>Default returns the default &quot;typed&quot; type for an &quot;untyped&quot; type;
it returns the incoming type for all other types. The default type
for untyped nil is untyped nil.

				
				
			
				
				<h3 id="Instantiate">func <a href="/src/go/types/instantiate.go?s=2273:2358#L45">Instantiate</a>
					<a class="permalink" href="#Instantiate">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func Instantiate(ctxt *<a href="#Context">Context</a>, orig <a href="#Type">Type</a>, targs []<a href="#Type">Type</a>, validate <a href="/pkg/builtin/#bool">bool</a>) (<a href="#Type">Type</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Instantiate instantiates the type orig with the given type arguments targs.
orig must be an *Alias, *Named, or *Signature type. If there is no error,
the resulting Type is an instantiated type of the same kind (*Alias, *Named
or *Signature, respectively).
<p>Methods attached to a *Named type are also instantiated, and associated with
a new *Func that has the same position as the original method, but nil function
scope.
<p>If ctxt is non-nil, it may be used to de-duplicate the instance against
previous instances with the same identity. As a special case, generic
*Signature origin types are only considered identical if they are pointer
equivalent, so that instantiating distinct (but possibly identical)
signatures will yield different instances. The use of a shared context does
not guarantee that identical instances are deduplicated in all cases.
<p>If validate is set, Instantiate verifies that the number of type arguments
and parameters match, and that the type arguments satisfy their respective
type constraints. If verification fails, the resulting error may wrap an
*ArgumentError indicating which type argument did not satisfy its type parameter
constraint, and why.
<p>If validate is not set, Instantiate does not verify the type argument count
or whether the type arguments satisfy their constraints. Instantiate is
guaranteed to not return an error, but may panic. Specifically, for
*Signature types, Instantiate will panic immediately if the type argument
count is incorrect; for *Named types, a panic may occur later inside the
*Named API.

				
				
			
				
				<h3 id="Unalias">func <a href="/src/go/types/alias.go?s=3098:3123#L69">Unalias</a>
					<a class="permalink" href="#Unalias">&#xb6;</a>
					
					<span title="Added in Go 1.22">1.22</span>
				</h3>
				<pre>func Unalias(t <a href="#Type">Type</a>) <a href="#Type">Type</a></pre>
				<p>Unalias returns t if it is not an alias type;
otherwise it follows t&apos;s alias chain until it
reaches a non-alias type which is then returned.
Consequently, the result is never an alias type.

				
				
			

			
		
			
			
			<h2 id="TypeAndValue">type <a href="/src/go/types/api.go?s=14350:14431#L365">TypeAndValue</a>
				<a class="permalink" href="#TypeAndValue">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>TypeAndValue reports the type and value (for constants)
of the corresponding expression.

			<pre>type TypeAndValue struct {
<span id="TypeAndValue.Type"></span>    Type  <a href="#Type">Type</a>
<span id="TypeAndValue.Value"></span>    Value <a href="/pkg/go/constant/">constant</a>.<a href="/pkg/go/constant/#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="Eval">func <a href="/src/go/types/eval.go?s=691:791#L14">Eval</a>
					<a class="permalink" href="#Eval">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func Eval(fset *<a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#FileSet">FileSet</a>, pkg *<a href="#Package">Package</a>, pos <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>, expr <a href="/pkg/builtin/#string">string</a>) (_ <a href="#TypeAndValue">TypeAndValue</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Eval returns the type and, if constant, the value for the
expression expr, evaluated at position pos of package pkg,
which must have been derived from type-checking an AST with
complete position information relative to the provided file
set.
<p>The meaning of the parameters fset, pkg, and pos is the
same as in <a href="#CheckExpr">CheckExpr</a>. An error is returned if expr cannot
be parsed successfully, or the resulting expr AST cannot be
type-checked.

				
				
			

			
				
				<h3 id="TypeAndValue.Addressable">func (TypeAndValue) <a href="/src/go/types/api.go?s=15544:15585#L407">Addressable</a>
					<a class="permalink" href="#TypeAndValue.Addressable">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (tv <a href="#TypeAndValue">TypeAndValue</a>) Addressable() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Addressable reports whether the corresponding expression
is addressable (<a href="https://golang.org/ref/spec#Address_operators">https://golang.org/ref/spec#Address_operators</a>).

				
				
				
			
				
				<h3 id="TypeAndValue.Assignable">func (TypeAndValue) <a href="/src/go/types/api.go?s=15736:15776#L413">Assignable</a>
					<a class="permalink" href="#TypeAndValue.Assignable">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (tv <a href="#TypeAndValue">TypeAndValue</a>) Assignable() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Assignable reports whether the corresponding expression
is assignable to (provided a value of the right type).

				
				
				
			
				
				<h3 id="TypeAndValue.HasOk">func (TypeAndValue) <a href="/src/go/types/api.go?s=15939:15974#L419">HasOk</a>
					<a class="permalink" href="#TypeAndValue.HasOk">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (tv <a href="#TypeAndValue">TypeAndValue</a>) HasOk() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>HasOk reports whether the corresponding expression may be
used on the rhs of a comma-ok assignment.

				
				
				
			
				
				<h3 id="TypeAndValue.IsBuiltin">func (TypeAndValue) <a href="/src/go/types/api.go?s=14853:14892#L384">IsBuiltin</a>
					<a class="permalink" href="#TypeAndValue.IsBuiltin">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (tv <a href="#TypeAndValue">TypeAndValue</a>) IsBuiltin() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsBuiltin reports whether the corresponding expression denotes
a (possibly parenthesized) built-in function.

				
				
				
			
				
				<h3 id="TypeAndValue.IsNil">func (TypeAndValue) <a href="/src/go/types/api.go?s=15321:15356#L401">IsNil</a>
					<a class="permalink" href="#TypeAndValue.IsNil">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (tv <a href="#TypeAndValue">TypeAndValue</a>) IsNil() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsNil reports whether the corresponding expression denotes the
predeclared value nil.

				
				
				
			
				
				<h3 id="TypeAndValue.IsType">func (TypeAndValue) <a href="/src/go/types/api.go?s=14669:14705#L378">IsType</a>
					<a class="permalink" href="#TypeAndValue.IsType">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (tv <a href="#TypeAndValue">TypeAndValue</a>) IsType() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsType reports whether the corresponding expression specifies a type.

				
				
				
			
				
				<h3 id="TypeAndValue.IsValue">func (TypeAndValue) <a href="/src/go/types/api.go?s=15074:15111#L391">IsValue</a>
					<a class="permalink" href="#TypeAndValue.IsValue">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (tv <a href="#TypeAndValue">TypeAndValue</a>) IsValue() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsValue reports whether the corresponding expression is a value.
Builtins are not considered values. Constant values have a non-
nil Value.

				
				
				
			
				
				<h3 id="TypeAndValue.IsVoid">func (TypeAndValue) <a href="/src/go/types/api.go?s=14527:14563#L373">IsVoid</a>
					<a class="permalink" href="#TypeAndValue.IsVoid">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (tv <a href="#TypeAndValue">TypeAndValue</a>) IsVoid() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsVoid reports whether the corresponding expression
is a function call without results.

				
				
				
			
		
			
			
			<h2 id="TypeList">type <a href="/src/go/types/typelists.go?s=980:1016#L21">TypeList</a>
				<a class="permalink" href="#TypeList">&#xb6;</a>
				
				<span title="Added in Go 1.18">1.18</span>
			</h2>
			<p>TypeList holds a list of types.

			<pre>type TypeList struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="TypeList.At">func (*TypeList) <a href="/src/go/types/typelists.go?s=1371:1404#L36">At</a>
					<a class="permalink" href="#TypeList.At">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (l *<a href="#TypeList">TypeList</a>) At(i <a href="/pkg/builtin/#int">int</a>) <a href="#Type">Type</a></pre>
				<p>At returns the i&apos;th type in the list.

				
				
				
			
				
				<h3 id="TypeList.Len">func (*TypeList) <a href="/src/go/types/typelists.go?s=1275:1303#L33">Len</a>
					<a class="permalink" href="#TypeList.Len">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (l *<a href="#TypeList">TypeList</a>) Len() <a href="/pkg/builtin/#int">int</a></pre>
				<p>Len returns the number of types in the list.
It is safe to call on a nil receiver.

				
				
				
			
		
			
			
			<h2 id="TypeName">type <a href="/src/go/types/object.go?s=8208:8240#L254">TypeName</a>
				<a class="permalink" href="#TypeName">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A TypeName represents a name for a (defined or alias) type.

			<pre>type TypeName struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewTypeName">func <a href="/src/go/types/object.go?s=8598:8676#L265">NewTypeName</a>
					<a class="permalink" href="#NewTypeName">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewTypeName(pos <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>, pkg *<a href="#Package">Package</a>, name <a href="/pkg/builtin/#string">string</a>, typ <a href="#Type">Type</a>) *<a href="#TypeName">TypeName</a></pre>
				<p>NewTypeName returns a new type name denoting the given typ.
The remaining arguments set the attributes found with all Objects.
<p>The typ argument may be a defined (Named) type or an alias type.
It may also be nil such that the returned TypeName can be used as
argument for NewNamed, which will set the TypeName&apos;s type as a side-
effect.

				
				
			

			
				
				<h3 id="TypeName.Exported">func (*TypeName) <a href="/src/go/types/object.go?s=4774:4808#L146">Exported</a>
					<a class="permalink" href="#TypeName.Exported">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#TypeName">TypeName</a>) Exported() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Exported reports whether the object is exported (starts with a capital letter).
It doesn&apos;t take into account whether the object is in a local (function) scope
or not.

				
				
				
			
				
				<h3 id="TypeName.Id">func (*TypeName) <a href="/src/go/types/object.go?s=4892:4922#L149">Id</a>
					<a class="permalink" href="#TypeName.Id">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#TypeName">TypeName</a>) Id() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Id is a wrapper for Id(obj.Pkg(), obj.Name()).

				
				
				
			
				
				<h3 id="TypeName.IsAlias">func (*TypeName) <a href="/src/go/types/object.go?s=9208:9243#L278">IsAlias</a>
					<a class="permalink" href="#TypeName.IsAlias">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func (obj *<a href="#TypeName">TypeName</a>) IsAlias() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsAlias reports whether obj is an alias name for a type.

				
				
				
			
				
				<h3 id="TypeName.Name">func (*TypeName) <a href="/src/go/types/object.go?s=4458:4490#L138">Name</a>
					<a class="permalink" href="#TypeName.Name">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#TypeName">TypeName</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Name returns the object&apos;s (package-local, unqualified) name.

				
				
				
			
				
				<h3 id="TypeName.Parent">func (*TypeName) <a href="/src/go/types/object.go?s=4036:4070#L128">Parent</a>
					<a class="permalink" href="#TypeName.Parent">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#TypeName">TypeName</a>) Parent() *<a href="#Scope">Scope</a></pre>
				<p>Parent returns the scope in which the object is declared.
The result is nil for methods and struct fields.

				
				
				
			
				
				<h3 id="TypeName.Pkg">func (*TypeName) <a href="/src/go/types/object.go?s=4340:4373#L135">Pkg</a>
					<a class="permalink" href="#TypeName.Pkg">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#TypeName">TypeName</a>) Pkg() *<a href="#Package">Package</a></pre>
				<p>Pkg returns the package to which the object belongs.
The result is nil for labels and objects in the Universe scope.

				
				
				
			
				
				<h3 id="TypeName.Pos">func (*TypeName) <a href="/src/go/types/object.go?s=4162:4196#L131">Pos</a>
					<a class="permalink" href="#TypeName.Pos">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#TypeName">TypeName</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				<p>Pos returns the declaration position of the object&apos;s identifier.

				
				
				
			
				
				<h3 id="TypeName.String">func (*TypeName) <a href="/src/go/types/object.go?s=19571:19607#L609">String</a>
					<a class="permalink" href="#TypeName.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#TypeName">TypeName</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="TypeName.Type">func (*TypeName) <a href="/src/go/types/object.go?s=4547:4577#L141">Type</a>
					<a class="permalink" href="#TypeName.Type">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#TypeName">TypeName</a>) Type() <a href="#Type">Type</a></pre>
				<p>Type returns the object&apos;s type.

				
				
				
			
		
			
			
			<h2 id="TypeParam">type <a href="/src/go/types/typeparam.go?s=718:1073#L12">TypeParam</a>
				<a class="permalink" href="#TypeParam">&#xb6;</a>
				
				<span title="Added in Go 1.18">1.18</span>
			</h2>
			<p>A TypeParam represents a type parameter type.

			<pre>type TypeParam struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewTypeParam">func <a href="/src/go/types/typeparam.go?s=1396:1456#L26">NewTypeParam</a>
					<a class="permalink" href="#NewTypeParam">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func NewTypeParam(obj *<a href="#TypeName">TypeName</a>, constraint <a href="#Type">Type</a>) *<a href="#TypeParam">TypeParam</a></pre>
				<p>NewTypeParam returns a new TypeParam. Type parameters may be set on a Named
type by calling SetTypeParams. Setting a type parameter on more than one type
will result in a panic.
<p>The constraint argument can be nil, and set later via SetConstraint. If the
constraint is non-nil, it must be fully defined.

				
				
			

			
				
				<h3 id="TypeParam.Constraint">func (*TypeParam) <a href="/src/go/types/typeparam.go?s=2458:2495#L62">Constraint</a>
					<a class="permalink" href="#TypeParam.Constraint">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#TypeParam">TypeParam</a>) Constraint() <a href="#Type">Type</a></pre>
				<p>Constraint returns the type constraint specified for t.

				
				
				
			
				
				<h3 id="TypeParam.Index">func (*TypeParam) <a href="/src/go/types/typeparam.go?s=2346:2377#L57">Index</a>
					<a class="permalink" href="#TypeParam.Index">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#TypeParam">TypeParam</a>) Index() <a href="/pkg/builtin/#int">int</a></pre>
				<p>Index returns the index of the type param within its param list, or -1 if
the type parameter has not yet been bound to a type.

				
				
				
			
				
				<h3 id="TypeParam.Obj">func (*TypeParam) <a href="/src/go/types/typeparam.go?s=2159:2194#L53">Obj</a>
					<a class="permalink" href="#TypeParam.Obj">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#TypeParam">TypeParam</a>) Obj() *<a href="#TypeName">TypeName</a></pre>
				<p>Obj returns the type name for the type parameter t.

				
				
				
			
				
				<h3 id="TypeParam.SetConstraint">func (*TypeParam) <a href="/src/go/types/typeparam.go?s=2821:2866#L72">SetConstraint</a>
					<a class="permalink" href="#TypeParam.SetConstraint">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#TypeParam">TypeParam</a>) SetConstraint(bound <a href="#Type">Type</a>)</pre>
				<p>SetConstraint sets the type constraint for t.
<p>It must be called by users of NewTypeParam after the bound&apos;s underlying is
fully defined, and before using the type parameter in any way other than to
form other types. Once SetConstraint returns the receiver, t is safe for
concurrent use.

				
				
				
			
				
				<h3 id="TypeParam.String">func (*TypeParam) <a href="/src/go/types/typeparam.go?s=3341:3376#L90">String</a>
					<a class="permalink" href="#TypeParam.String">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#TypeParam">TypeParam</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="TypeParam.Underlying">func (*TypeParam) <a href="/src/go/types/typeparam.go?s=3280:3317#L86">Underlying</a>
					<a class="permalink" href="#TypeParam.Underlying">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (t *<a href="#TypeParam">TypeParam</a>) Underlying() <a href="#Type">Type</a></pre>
				<p>Underlying returns the <a href="https://go.dev/ref/spec#Underlying_types.">underlying type</a> of the type parameter t, which is
the underlying type of its constraint. This type is always an interface.

				
				
				
			
		
			
			
			<h2 id="TypeParamList">type <a href="/src/go/types/typelists.go?s=354:403#L1">TypeParamList</a>
				<a class="permalink" href="#TypeParamList">&#xb6;</a>
				
				<span title="Added in Go 1.18">1.18</span>
			</h2>
			<p>TypeParamList holds a list of type parameters.

			<pre>type TypeParamList struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="TypeParamList.At">func (*TypeParamList) <a href="/src/go/types/typelists.go?s=615:659#L8">At</a>
					<a class="permalink" href="#TypeParamList.At">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (l *<a href="#TypeParamList">TypeParamList</a>) At(i <a href="/pkg/builtin/#int">int</a>) *<a href="#TypeParam">TypeParam</a></pre>
				<p>At returns the i&apos;th type parameter in the list.

				
				
				
			
				
				<h3 id="TypeParamList.Len">func (*TypeParamList) <a href="/src/go/types/typelists.go?s=504:537#L5">Len</a>
					<a class="permalink" href="#TypeParamList.Len">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (l *<a href="#TypeParamList">TypeParamList</a>) Len() <a href="/pkg/builtin/#int">int</a></pre>
				<p>Len returns the number of type parameters in the list.
It is safe to call on a nil receiver.

				
				
				
			
		
			
			
			<h2 id="Union">type <a href="/src/go/types/union.go?s=389:485#L7">Union</a>
				<a class="permalink" href="#Union">&#xb6;</a>
				
				<span title="Added in Go 1.18">1.18</span>
			</h2>
			<p>A Union represents a union of terms embedded in an interface.

			<pre>type Union struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewUnion">func <a href="/src/go/types/union.go?s=629:664#L13">NewUnion</a>
					<a class="permalink" href="#NewUnion">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func NewUnion(terms []*<a href="#Term">Term</a>) *<a href="#Union">Union</a></pre>
				<p>NewUnion returns a new <a href="#Union">Union</a> type with the given terms.
It is an error to create an empty union; they are syntactically not possible.

				
				
			

			
				
				<h3 id="Union.Len">func (*Union) <a href="/src/go/types/union.go?s=740:765#L20">Len</a>
					<a class="permalink" href="#Union.Len">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (u *<a href="#Union">Union</a>) Len() <a href="/pkg/builtin/#int">int</a></pre>
				
				
				
				
			
				
				<h3 id="Union.String">func (*Union) <a href="/src/go/types/union.go?s=902:933#L24">String</a>
					<a class="permalink" href="#Union.String">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (u *<a href="#Union">Union</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Union.Term">func (*Union) <a href="/src/go/types/union.go?s=798:831#L21">Term</a>
					<a class="permalink" href="#Union.Term">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (u *<a href="#Union">Union</a>) Term(i <a href="/pkg/builtin/#int">int</a>) *<a href="#Term">Term</a></pre>
				
				
				
				
			
				
				<h3 id="Union.Underlying">func (*Union) <a href="/src/go/types/union.go?s=855:888#L23">Underlying</a>
					<a class="permalink" href="#Union.Underlying">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (u *<a href="#Union">Union</a>) Underlying() <a href="#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Var">type <a href="/src/go/types/object.go?s=10160:10441#L306">Var</a>
				<a class="permalink" href="#Var">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A Variable represents a declared variable (including function parameters and results, and struct fields).

			<pre>type Var struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewField">func <a href="/src/go/types/object.go?s=11127:11212#L328">NewField</a>
					<a class="permalink" href="#NewField">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewField(pos <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>, pkg *<a href="#Package">Package</a>, name <a href="/pkg/builtin/#string">string</a>, typ <a href="#Type">Type</a>, embedded <a href="/pkg/builtin/#bool">bool</a>) *<a href="#Var">Var</a></pre>
				<p>NewField returns a new variable representing a struct field.
For embedded fields, the name is the unqualified type name
under which the field is accessible.

				
				
			
				
				<h3 id="NewParam">func <a href="/src/go/types/object.go?s=10761:10831#L321">NewParam</a>
					<a class="permalink" href="#NewParam">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewParam(pos <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>, pkg *<a href="#Package">Package</a>, name <a href="/pkg/builtin/#string">string</a>, typ <a href="#Type">Type</a>) *<a href="#Var">Var</a></pre>
				<p>NewParam returns a new variable representing a function parameter.

				
				
			
				
				<h3 id="NewVar">func <a href="/src/go/types/object.go?s=10537:10605#L316">NewVar</a>
					<a class="permalink" href="#NewVar">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewVar(pos <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>, pkg *<a href="#Package">Package</a>, name <a href="/pkg/builtin/#string">string</a>, typ <a href="#Type">Type</a>) *<a href="#Var">Var</a></pre>
				<p>NewVar returns a new variable.
The arguments set the attributes found with all Objects.

				
				
			

			
				
				<h3 id="Var.Anonymous">func (*Var) <a href="/src/go/types/object.go?s=11459:11491#L334">Anonymous</a>
					<a class="permalink" href="#Var.Anonymous">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Var">Var</a>) Anonymous() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Anonymous reports whether the variable is an embedded field.
Same as Embedded; only present for backward-compatibility.

				
				
				
			
				
				<h3 id="Var.Embedded">func (*Var) <a href="/src/go/types/object.go?s=11580:11611#L337">Embedded</a>
					<a class="permalink" href="#Var.Embedded">&#xb6;</a>
					
					<span title="Added in Go 1.11">1.11</span>
				</h3>
				<pre>func (obj *<a href="#Var">Var</a>) Embedded() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Embedded reports whether the variable is an embedded field.

				
				
				
			
				
				<h3 id="Var.Exported">func (*Var) <a href="/src/go/types/object.go?s=4774:4808#L146">Exported</a>
					<a class="permalink" href="#Var.Exported">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Var">Var</a>) Exported() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Exported reports whether the object is exported (starts with a capital letter).
It doesn&apos;t take into account whether the object is in a local (function) scope
or not.

				
				
				
			
				
				<h3 id="Var.Id">func (*Var) <a href="/src/go/types/object.go?s=4892:4922#L149">Id</a>
					<a class="permalink" href="#Var.Id">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Var">Var</a>) Id() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Id is a wrapper for Id(obj.Pkg(), obj.Name()).

				
				
				
			
				
				<h3 id="Var.IsField">func (*Var) <a href="/src/go/types/object.go?s=11696:11726#L340">IsField</a>
					<a class="permalink" href="#Var.IsField">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Var">Var</a>) IsField() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsField reports whether the variable is a struct field.

				
				
				
			
				
				<h3 id="Var.Name">func (*Var) <a href="/src/go/types/object.go?s=4458:4490#L138">Name</a>
					<a class="permalink" href="#Var.Name">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Var">Var</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Name returns the object&apos;s (package-local, unqualified) name.

				
				
				
			
				
				<h3 id="Var.Origin">func (*Var) <a href="/src/go/types/object.go?s=12113:12142#L349">Origin</a>
					<a class="permalink" href="#Var.Origin">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (obj *<a href="#Var">Var</a>) Origin() *<a href="#Var">Var</a></pre>
				<p>Origin returns the canonical Var for its receiver, i.e. the Var object
recorded in Info.Defs.
<p>For synthetic Vars created during instantiation (such as struct fields or
function parameters that depend on type arguments), this will be the
corresponding Var on the generic (uninstantiated) type. For all other Vars
Origin returns the receiver.

				
				
				
			
				
				<h3 id="Var.Parent">func (*Var) <a href="/src/go/types/object.go?s=4036:4070#L128">Parent</a>
					<a class="permalink" href="#Var.Parent">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Var">Var</a>) Parent() *<a href="#Scope">Scope</a></pre>
				<p>Parent returns the scope in which the object is declared.
The result is nil for methods and struct fields.

				
				
				
			
				
				<h3 id="Var.Pkg">func (*Var) <a href="/src/go/types/object.go?s=4340:4373#L135">Pkg</a>
					<a class="permalink" href="#Var.Pkg">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Var">Var</a>) Pkg() *<a href="#Package">Package</a></pre>
				<p>Pkg returns the package to which the object belongs.
The result is nil for labels and objects in the Universe scope.

				
				
				
			
				
				<h3 id="Var.Pos">func (*Var) <a href="/src/go/types/object.go?s=4162:4196#L131">Pos</a>
					<a class="permalink" href="#Var.Pos">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Var">Var</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				<p>Pos returns the declaration position of the object&apos;s identifier.

				
				
				
			
				
				<h3 id="Var.String">func (*Var) <a href="/src/go/types/object.go?s=19642:19673#L610">String</a>
					<a class="permalink" href="#Var.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Var">Var</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Var.Type">func (*Var) <a href="/src/go/types/object.go?s=4547:4577#L141">Type</a>
					<a class="permalink" href="#Var.Type">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (obj *<a href="#Var">Var</a>) Type() <a href="#Type">Type</a></pre>
				<p>Type returns the object&apos;s type.

				
				
				
			
		
	

	







<div id="footer">
Build version go1.23.0.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
