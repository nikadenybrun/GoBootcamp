<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>sql - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.23.0";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package sql
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "database/sql"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package sql provides a generic interface around SQL (or SQL-like)
databases.
<p>The sql package must be used in conjunction with a database driver.
See <a href="https://golang.org/s/sqldrivers">https://golang.org/s/sqldrivers</a> for a list of drivers.
<p>Drivers that do not support context cancellation will not return until
after the query is completed.
<p>For usage examples, see the wiki page at
<a href="https://golang.org/s/sqlwiki">https://golang.org/s/sqlwiki</a>.

				<div id="example__openDBCLI" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (OpenDBCLI)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (OpenDBCLI)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">package sql_test

import (
    &#34;context&#34;
    &#34;database/sql&#34;
    &#34;flag&#34;
    &#34;log&#34;
    &#34;os&#34;
    &#34;os/signal&#34;
    &#34;time&#34;
)

var pool *sql.DB <span class="comment">// Database connection pool.</span>

func Example_openDBCLI() {
    id := flag.Int64(&#34;id&#34;, 0, &#34;person ID to find&#34;)
    dsn := flag.String(&#34;dsn&#34;, os.Getenv(&#34;DSN&#34;), &#34;connection data source name&#34;)
    flag.Parse()

    if len(*dsn) == 0 {
        log.Fatal(&#34;missing dsn flag&#34;)
    }
    if *id == 0 {
        log.Fatal(&#34;missing person ID&#34;)
    }
    var err error

    <span class="comment">// Opening a driver typically will not attempt to connect to the database.</span>
    pool, err = sql.Open(&#34;driver-name&#34;, *dsn)
    if err != nil {
        <span class="comment">// This will not be a connection error, but a DSN parse error or</span>
        <span class="comment">// another initialization error.</span>
        log.Fatal(&#34;unable to use data source name&#34;, err)
    }
    defer pool.Close()

    pool.SetConnMaxLifetime(0)
    pool.SetMaxIdleConns(3)
    pool.SetMaxOpenConns(3)

    ctx, stop := context.WithCancel(context.Background())
    defer stop()

    appSignal := make(chan os.Signal, 3)
    signal.Notify(appSignal, os.Interrupt)

    go func() {
        &lt;-appSignal
        stop()
    }()

    Ping(ctx)

    Query(ctx, *id)
}

<span class="comment">// Ping the database to verify DSN provided by the user is valid and the</span>
<span class="comment">// server accessible. If the ping fails exit the program with an error.</span>
func Ping(ctx context.Context) {
    ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
    defer cancel()

    if err := pool.PingContext(ctx); err != nil {
        log.Fatalf(&#34;unable to connect to database: %v&#34;, err)
    }
}

<span class="comment">// Query the database for the information requested and prints the results.</span>
<span class="comment">// If the query fails exit the program with an error.</span>
func Query(ctx context.Context, id int64) {
    ctx, cancel := context.WithTimeout(ctx, 5*time.Second)
    defer cancel()

    var name string
    err := pool.QueryRowContext(ctx, &#34;select p.name from people as p where p.id = :id;&#34;, sql.Named(&#34;id&#34;, id)).Scan(&amp;name)
    if err != nil {
        log.Fatal(&#34;unable to execute search query&#34;, err)
    }
    log.Println(&#34;name=&#34;, name)
}
</pre>
			
		
	</div>
</div>
<div id="example__openDBService" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (OpenDBService)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (OpenDBService)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">package sql_test

import (
    &#34;context&#34;
    &#34;database/sql&#34;
    &#34;encoding/json&#34;
    &#34;fmt&#34;
    &#34;io&#34;
    &#34;log&#34;
    &#34;net/http&#34;
    &#34;time&#34;
)

func Example_openDBService() {
    <span class="comment">// Opening a driver typically will not attempt to connect to the database.</span>
    db, err := sql.Open(&#34;driver-name&#34;, &#34;database=test1&#34;)
    if err != nil {
        <span class="comment">// This will not be a connection error, but a DSN parse error or</span>
        <span class="comment">// another initialization error.</span>
        log.Fatal(err)
    }
    db.SetConnMaxLifetime(0)
    db.SetMaxIdleConns(50)
    db.SetMaxOpenConns(50)

    s := &amp;Service{db: db}

    http.ListenAndServe(&#34;:8080&#34;, s)
}

type Service struct {
    db *sql.DB
}

func (s *Service) ServeHTTP(w http.ResponseWriter, r *http.Request) {
    db := s.db
    switch r.URL.Path {
    default:
        http.Error(w, &#34;not found&#34;, http.StatusNotFound)
        return
    case &#34;/healthz&#34;:
        ctx, cancel := context.WithTimeout(r.Context(), 1*time.Second)
        defer cancel()

        err := s.db.PingContext(ctx)
        if err != nil {
            http.Error(w, fmt.Sprintf(&#34;db down: %v&#34;, err), http.StatusFailedDependency)
            return
        }
        w.WriteHeader(http.StatusOK)
        return
    case &#34;/quick-action&#34;:
        <span class="comment">// This is a short SELECT. Use the request context as the base of</span>
        <span class="comment">// the context timeout.</span>
        ctx, cancel := context.WithTimeout(r.Context(), 3*time.Second)
        defer cancel()

        id := 5
        org := 10
        var name string
        err := db.QueryRowContext(ctx, `
select
    p.name
from
    people as p
    join organization as o on p.organization = o.id
where
    p.id = :id
    and o.id = :org
;`,
            sql.Named(&#34;id&#34;, id),
            sql.Named(&#34;org&#34;, org),
        ).Scan(&amp;name)
        if err != nil {
            if err == sql.ErrNoRows {
                http.Error(w, &#34;not found&#34;, http.StatusNotFound)
                return
            }
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        io.WriteString(w, name)
        return
    case &#34;/long-action&#34;:
        <span class="comment">// This is a long SELECT. Use the request context as the base of</span>
        <span class="comment">// the context timeout, but give it some time to finish. If</span>
        <span class="comment">// the client cancels before the query is done the query will also</span>
        <span class="comment">// be canceled.</span>
        ctx, cancel := context.WithTimeout(r.Context(), 60*time.Second)
        defer cancel()

        var names []string
        rows, err := db.QueryContext(ctx, &#34;select p.name from people as p where p.active = true;&#34;)
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }

        for rows.Next() {
            var name string
            err = rows.Scan(&amp;name)
            if err != nil {
                break
            }
            names = append(names, name)
        }
        <span class="comment">// Check for errors during rows &#34;Close&#34;.</span>
        <span class="comment">// This may be more important if multiple statements are executed</span>
        <span class="comment">// in a single batch and rows were written as well as read.</span>
        if closeErr := rows.Close(); closeErr != nil {
            http.Error(w, closeErr.Error(), http.StatusInternalServerError)
            return
        }

        <span class="comment">// Check for row scan error.</span>
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }

        <span class="comment">// Check for errors during row iteration.</span>
        if err = rows.Err(); err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }

        json.NewEncoder(w).Encode(names)
        return
    case &#34;/async-action&#34;:
        <span class="comment">// This action has side effects that we want to preserve</span>
        <span class="comment">// even if the client cancels the HTTP request part way through.</span>
        <span class="comment">// For this we do not use the http request context as a base for</span>
        <span class="comment">// the timeout.</span>
        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
        defer cancel()

        var orderRef = &#34;ABC123&#34;
        tx, err := db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelSerializable})
        if err != nil {
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        _, err = tx.ExecContext(ctx, &#34;stored_proc_name&#34;, orderRef)

        if err != nil {
            tx.Rollback()
            http.Error(w, err.Error(), http.StatusInternalServerError)
            return
        }
        err = tx.Commit()
        if err != nil {
            http.Error(w, &#34;action in unknown state, check state before attempting again&#34;, http.StatusInternalServerError)
            return
        }
        w.WriteHeader(http.StatusOK)
        return
    }
}
</pre>
			
		
	</div>
</div>

			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#Drivers">func Drivers() []string</a></dd>
			
				
				<dd><a href="#Register">func Register(name string, driver driver.Driver)</a></dd>
			
			
				
				<dd><a href="#ColumnType">type ColumnType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ColumnType.DatabaseTypeName">func (ci *ColumnType) DatabaseTypeName() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ColumnType.DecimalSize">func (ci *ColumnType) DecimalSize() (precision, scale int64, ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ColumnType.Length">func (ci *ColumnType) Length() (length int64, ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ColumnType.Name">func (ci *ColumnType) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ColumnType.Nullable">func (ci *ColumnType) Nullable() (nullable, ok bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ColumnType.ScanType">func (ci *ColumnType) ScanType() reflect.Type</a></dd>
				
			
				
				<dd><a href="#Conn">type Conn</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.BeginTx">func (c *Conn) BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.Close">func (c *Conn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.ExecContext">func (c *Conn) ExecContext(ctx context.Context, query string, args ...any) (Result, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.PingContext">func (c *Conn) PingContext(ctx context.Context) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.PrepareContext">func (c *Conn) PrepareContext(ctx context.Context, query string) (*Stmt, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.QueryContext">func (c *Conn) QueryContext(ctx context.Context, query string, args ...any) (*Rows, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.QueryRowContext">func (c *Conn) QueryRowContext(ctx context.Context, query string, args ...any) *Row</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Conn.Raw">func (c *Conn) Raw(f func(driverConn any) error) (err error)</a></dd>
				
			
				
				<dd><a href="#DB">type DB</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Open">func Open(driverName, dataSourceName string) (*DB, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#OpenDB">func OpenDB(c driver.Connector) *DB</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.Begin">func (db *DB) Begin() (*Tx, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.BeginTx">func (db *DB) BeginTx(ctx context.Context, opts *TxOptions) (*Tx, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.Close">func (db *DB) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.Conn">func (db *DB) Conn(ctx context.Context) (*Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.Driver">func (db *DB) Driver() driver.Driver</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.Exec">func (db *DB) Exec(query string, args ...any) (Result, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.ExecContext">func (db *DB) ExecContext(ctx context.Context, query string, args ...any) (Result, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.Ping">func (db *DB) Ping() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.PingContext">func (db *DB) PingContext(ctx context.Context) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.Prepare">func (db *DB) Prepare(query string) (*Stmt, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.PrepareContext">func (db *DB) PrepareContext(ctx context.Context, query string) (*Stmt, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.Query">func (db *DB) Query(query string, args ...any) (*Rows, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.QueryContext">func (db *DB) QueryContext(ctx context.Context, query string, args ...any) (*Rows, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.QueryRow">func (db *DB) QueryRow(query string, args ...any) *Row</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.QueryRowContext">func (db *DB) QueryRowContext(ctx context.Context, query string, args ...any) *Row</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.SetConnMaxIdleTime">func (db *DB) SetConnMaxIdleTime(d time.Duration)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.SetConnMaxLifetime">func (db *DB) SetConnMaxLifetime(d time.Duration)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.SetMaxIdleConns">func (db *DB) SetMaxIdleConns(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.SetMaxOpenConns">func (db *DB) SetMaxOpenConns(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DB.Stats">func (db *DB) Stats() DBStats</a></dd>
				
			
				
				<dd><a href="#DBStats">type DBStats</a></dd>
				
				
			
				
				<dd><a href="#IsolationLevel">type IsolationLevel</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IsolationLevel.String">func (i IsolationLevel) String() string</a></dd>
				
			
				
				<dd><a href="#NamedArg">type NamedArg</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Named">func Named(name string, value any) NamedArg</a></dd>
				
				
			
				
				<dd><a href="#Null">type Null</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Null.Scan">func (n *Null[T]) Scan(value any) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Null.Value">func (n Null[T]) Value() (driver.Value, error)</a></dd>
				
			
				
				<dd><a href="#NullBool">type NullBool</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NullBool.Scan">func (n *NullBool) Scan(value any) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NullBool.Value">func (n NullBool) Value() (driver.Value, error)</a></dd>
				
			
				
				<dd><a href="#NullByte">type NullByte</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NullByte.Scan">func (n *NullByte) Scan(value any) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NullByte.Value">func (n NullByte) Value() (driver.Value, error)</a></dd>
				
			
				
				<dd><a href="#NullFloat64">type NullFloat64</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NullFloat64.Scan">func (n *NullFloat64) Scan(value any) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NullFloat64.Value">func (n NullFloat64) Value() (driver.Value, error)</a></dd>
				
			
				
				<dd><a href="#NullInt16">type NullInt16</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NullInt16.Scan">func (n *NullInt16) Scan(value any) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NullInt16.Value">func (n NullInt16) Value() (driver.Value, error)</a></dd>
				
			
				
				<dd><a href="#NullInt32">type NullInt32</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NullInt32.Scan">func (n *NullInt32) Scan(value any) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NullInt32.Value">func (n NullInt32) Value() (driver.Value, error)</a></dd>
				
			
				
				<dd><a href="#NullInt64">type NullInt64</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NullInt64.Scan">func (n *NullInt64) Scan(value any) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NullInt64.Value">func (n NullInt64) Value() (driver.Value, error)</a></dd>
				
			
				
				<dd><a href="#NullString">type NullString</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NullString.Scan">func (ns *NullString) Scan(value any) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NullString.Value">func (ns NullString) Value() (driver.Value, error)</a></dd>
				
			
				
				<dd><a href="#NullTime">type NullTime</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NullTime.Scan">func (n *NullTime) Scan(value any) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NullTime.Value">func (n NullTime) Value() (driver.Value, error)</a></dd>
				
			
				
				<dd><a href="#Out">type Out</a></dd>
				
				
			
				
				<dd><a href="#RawBytes">type RawBytes</a></dd>
				
				
			
				
				<dd><a href="#Result">type Result</a></dd>
				
				
			
				
				<dd><a href="#Row">type Row</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Row.Err">func (r *Row) Err() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Row.Scan">func (r *Row) Scan(dest ...any) error</a></dd>
				
			
				
				<dd><a href="#Rows">type Rows</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Rows.Close">func (rs *Rows) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rows.ColumnTypes">func (rs *Rows) ColumnTypes() ([]*ColumnType, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rows.Columns">func (rs *Rows) Columns() ([]string, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rows.Err">func (rs *Rows) Err() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rows.Next">func (rs *Rows) Next() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rows.NextResultSet">func (rs *Rows) NextResultSet() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rows.Scan">func (rs *Rows) Scan(dest ...any) error</a></dd>
				
			
				
				<dd><a href="#Scanner">type Scanner</a></dd>
				
				
			
				
				<dd><a href="#Stmt">type Stmt</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Stmt.Close">func (s *Stmt) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Stmt.Exec">func (s *Stmt) Exec(args ...any) (Result, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Stmt.ExecContext">func (s *Stmt) ExecContext(ctx context.Context, args ...any) (Result, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Stmt.Query">func (s *Stmt) Query(args ...any) (*Rows, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Stmt.QueryContext">func (s *Stmt) QueryContext(ctx context.Context, args ...any) (*Rows, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Stmt.QueryRow">func (s *Stmt) QueryRow(args ...any) *Row</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Stmt.QueryRowContext">func (s *Stmt) QueryRowContext(ctx context.Context, args ...any) *Row</a></dd>
				
			
				
				<dd><a href="#Tx">type Tx</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Tx.Commit">func (tx *Tx) Commit() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Tx.Exec">func (tx *Tx) Exec(query string, args ...any) (Result, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Tx.ExecContext">func (tx *Tx) ExecContext(ctx context.Context, query string, args ...any) (Result, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Tx.Prepare">func (tx *Tx) Prepare(query string) (*Stmt, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Tx.PrepareContext">func (tx *Tx) PrepareContext(ctx context.Context, query string) (*Stmt, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Tx.Query">func (tx *Tx) Query(query string, args ...any) (*Rows, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Tx.QueryContext">func (tx *Tx) QueryContext(ctx context.Context, query string, args ...any) (*Rows, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Tx.QueryRow">func (tx *Tx) QueryRow(query string, args ...any) *Row</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Tx.QueryRowContext">func (tx *Tx) QueryRowContext(ctx context.Context, query string, args ...any) *Row</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Tx.Rollback">func (tx *Tx) Rollback() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Tx.Stmt">func (tx *Tx) Stmt(stmt *Stmt) *Stmt</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Tx.StmtContext">func (tx *Tx) StmtContext(ctx context.Context, stmt *Stmt) *Stmt</a></dd>
				
			
				
				<dd><a href="#TxOptions">type TxOptions</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Conn_ExecContext">Conn.ExecContext</a></dd>
			
			<dd><a class="exampleLink" href="#example_DB_BeginTx">DB.BeginTx</a></dd>
			
			<dd><a class="exampleLink" href="#example_DB_ExecContext">DB.ExecContext</a></dd>
			
			<dd><a class="exampleLink" href="#example_DB_PingContext">DB.PingContext</a></dd>
			
			<dd><a class="exampleLink" href="#example_DB_Prepare">DB.Prepare</a></dd>
			
			<dd><a class="exampleLink" href="#example_DB_QueryContext">DB.QueryContext</a></dd>
			
			<dd><a class="exampleLink" href="#example_DB_QueryRowContext">DB.QueryRowContext</a></dd>
			
			<dd><a class="exampleLink" href="#example_DB_Query_multipleResultSets">DB.Query (MultipleResultSets)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Rows">Rows</a></dd>
			
			<dd><a class="exampleLink" href="#example_Stmt">Stmt</a></dd>
			
			<dd><a class="exampleLink" href="#example_Stmt_QueryRowContext">Stmt.QueryRowContext</a></dd>
			
			<dd><a class="exampleLink" href="#example_Tx_ExecContext">Tx.ExecContext</a></dd>
			
			<dd><a class="exampleLink" href="#example_Tx_Prepare">Tx.Prepare</a></dd>
			
			<dd><a class="exampleLink" href="#example_Tx_Rollback">Tx.Rollback</a></dd>
			
			<dd><a class="exampleLink" href="#example__openDBCLI">Package (OpenDBCLI)</a></dd>
			
			<dd><a class="exampleLink" href="#example__openDBService">Package (OpenDBService)</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/database/sql/convert.go">convert.go</a>
			
				<a href="/src/database/sql/ctxutil.go">ctxutil.go</a>
			
				<a href="/src/database/sql/sql.go">sql.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>ErrConnDone is returned by any operation that is performed on a connection
that has already been returned to the connection pool.

				<pre>var <span id="ErrConnDone">ErrConnDone</span> = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;sql: connection is already closed&#34;)</pre>
			
				<p>ErrNoRows is returned by <a href="#Row.Scan">Row.Scan</a> when <a href="#DB.QueryRow">DB.QueryRow</a> doesn&apos;t return a
row. In such a case, QueryRow returns a placeholder <a href="#Row">*Row</a> value that
defers this error until a Scan.

				<pre>var <span id="ErrNoRows">ErrNoRows</span> = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;sql: no rows in result set&#34;)</pre>
			
				<p>ErrTxDone is returned by any operation that is performed on a transaction
that has already been committed or rolled back.

				<pre>var <span id="ErrTxDone">ErrTxDone</span> = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;sql: transaction has already been committed or rolled back&#34;)</pre>
			
		
		
			
			
			<h2 id="Drivers">func <a href="/src/database/sql/sql.go?s=1904:1927#L65">Drivers</a>
				<a class="permalink" href="#Drivers">&#xb6;</a>
				
				<span title="Added in Go 1.4">1.4</span>
			</h2>
			<pre>func Drivers() []<a href="/pkg/builtin/#string">string</a></pre>
			<p>Drivers returns a sorted list of the names of the registered drivers.

			
			

		
			
			
			<h2 id="Register">func <a href="/src/database/sql/sql.go?s=1418:1466#L45">Register</a>
				<a class="permalink" href="#Register">&#xb6;</a>
				
				
			</h2>
			<pre>func Register(name <a href="/pkg/builtin/#string">string</a>, driver <a href="/pkg/database/sql/driver/">driver</a>.<a href="/pkg/database/sql/driver/#Driver">Driver</a>)</pre>
			<p>Register makes a database driver available by the provided name.
If Register is called twice with the same name or if driver is nil,
it panics.

			
			

		
		
			
			
			<h2 id="ColumnType">type <a href="/src/database/sql/sql.go?s=91510:91750#L3198">ColumnType</a>
				<a class="permalink" href="#ColumnType">&#xb6;</a>
				
				<span title="Added in Go 1.8">1.8</span>
			</h2>
			<p>ColumnType contains the name and type of a column.

			<pre>type ColumnType struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ColumnType.DatabaseTypeName">func (*ColumnType) <a href="/src/database/sql/sql.go?s=93369:93416#L3252">DatabaseTypeName</a>
					<a class="permalink" href="#ColumnType.DatabaseTypeName">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (ci *<a href="#ColumnType">ColumnType</a>) DatabaseTypeName() <a href="/pkg/builtin/#string">string</a></pre>
				<p>DatabaseTypeName returns the database system name of the column type. If an empty
string is returned, then the driver type name is not supported.
Consult your driver documentation for a list of driver data types. <a href="#ColumnType.Length">ColumnType.Length</a> specifiers
are not included.
Common type names include &quot;VARCHAR&quot;, &quot;TEXT&quot;, &quot;NVARCHAR&quot;, &quot;DECIMAL&quot;, &quot;BOOL&quot;,
&quot;INT&quot;, and &quot;BIGINT&quot;.

				
				
				
			
				
				<h3 id="ColumnType.DecimalSize">func (*ColumnType) <a href="/src/database/sql/sql.go?s=92405:92474#L3229">DecimalSize</a>
					<a class="permalink" href="#ColumnType.DecimalSize">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (ci *<a href="#ColumnType">ColumnType</a>) DecimalSize() (precision, scale <a href="/pkg/builtin/#int64">int64</a>, ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>DecimalSize returns the scale and precision of a decimal type.
If not applicable or if not supported ok is false.

				
				
				
			
				
				<h3 id="ColumnType.Length">func (*ColumnType) <a href="/src/database/sql/sql.go?s=92193:92247#L3223">Length</a>
					<a class="permalink" href="#ColumnType.Length">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (ci *<a href="#ColumnType">ColumnType</a>) Length() (length <a href="/pkg/builtin/#int64">int64</a>, ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>Length returns the column type length for variable length column types such
as text and binary field types. If the type length is unbounded the value will
be <a href="/math#MaxInt64">math.MaxInt64</a> (any database limits will still apply).
If the column type is not variable length, such as an int, or if not supported
by the driver ok is false.

				
				
				
			
				
				<h3 id="ColumnType.Name">func (*ColumnType) <a href="/src/database/sql/sql.go?s=91801:91836#L3214">Name</a>
					<a class="permalink" href="#ColumnType.Name">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (ci *<a href="#ColumnType">ColumnType</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Name returns the name or alias of the column.

				
				
				
			
				
				<h3 id="ColumnType.Nullable">func (*ColumnType) <a href="/src/database/sql/sql.go?s=92898:92950#L3242">Nullable</a>
					<a class="permalink" href="#ColumnType.Nullable">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (ci *<a href="#ColumnType">ColumnType</a>) Nullable() (nullable, ok <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>Nullable reports whether the column may be null.
If a driver does not support this property ok will be false.

				
				
				
			
				
				<h3 id="ColumnType.ScanType">func (*ColumnType) <a href="/src/database/sql/sql.go?s=92711:92756#L3236">ScanType</a>
					<a class="permalink" href="#ColumnType.ScanType">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (ci *<a href="#ColumnType">ColumnType</a>) ScanType() <a href="/pkg/reflect/">reflect</a>.<a href="/pkg/reflect/#Type">Type</a></pre>
				<p>ScanType returns a Go type suitable for scanning into using <a href="#Rows.Scan">Rows.Scan</a>.
If a driver does not support this property ScanType will return
the type of an empty interface.

				
				
				
			
		
			
			
			<h2 id="Conn">type <a href="/src/database/sql/sql.go?s=54770:55386#L1958">Conn</a>
				<a class="permalink" href="#Conn">&#xb6;</a>
				
				<span title="Added in Go 1.9">1.9</span>
			</h2>
			<p>Conn represents a single database connection rather than a pool of database
connections. Prefer running queries from <a href="#DB">DB</a> unless there is a specific
need for a continuous single database connection.
<p>A Conn must call <a href="#Conn.Close">Conn.Close</a> to return the connection to the database pool
and may do so concurrently with a running query.
<p>After a call to <a href="#Conn.Close">Conn.Close</a>, all operations on the
connection fail with <a href="#ErrConnDone">ErrConnDone</a>.

			<pre>type Conn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Conn.BeginTx">func (*Conn) <a href="/src/database/sql/sql.go?s=59132:59205#L2092">BeginTx</a>
					<a class="permalink" href="#Conn.BeginTx">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func (c *<a href="#Conn">Conn</a>) BeginTx(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, opts *<a href="#TxOptions">TxOptions</a>) (*<a href="#Tx">Tx</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>BeginTx starts a transaction.
<p>The provided context is used until the transaction is committed or rolled back.
If the context is canceled, the sql package will roll back
the transaction. <a href="#Tx.Commit">Tx.Commit</a> will return an error if the context provided to
BeginTx is canceled.
<p>The provided <a href="#TxOptions">TxOptions</a> is optional and may be nil if defaults should be used.
If a non-default isolation level is used that the driver doesn&apos;t support,
an error will be returned.

				
				
				
			
				
				<h3 id="Conn.Close">func (*Conn) <a href="/src/database/sql/sql.go?s=60271:60299#L2134">Close</a>
					<a class="permalink" href="#Conn.Close">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func (c *<a href="#Conn">Conn</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Close returns the connection to the connection pool.
All operations after a Close will return with <a href="#ErrConnDone">ErrConnDone</a>.
Close is safe to call concurrently with other operations and will
block until all other operations finish. It may be useful to first
cancel any used context and then call close directly after.

				
				
				
			
				
				<h3 id="Conn.ExecContext">func (*Conn) <a href="/src/database/sql/sql.go?s=56117:56207#L2004">ExecContext</a>
					<a class="permalink" href="#Conn.ExecContext">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func (c *<a href="#Conn">Conn</a>) ExecContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, query <a href="/pkg/builtin/#string">string</a>, args ...<a href="/pkg/builtin/#any">any</a>) (<a href="#Result">Result</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ExecContext executes a query without returning any rows.
The args are for any placeholder parameters in the query.

				
				<div id="example_Conn_ExecContext" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// A *DB is a pool of connections. Call Conn to reserve a connection for</span>
<span class="comment">// exclusive use.</span>
conn, err := db.Conn(ctx)
if err != nil {
    log.Fatal(err)
}
defer conn.Close() <span class="comment">// Return the connection to the pool.</span>
id := 41
result, err := conn.ExecContext(ctx, `UPDATE balances SET balance = balance + 10 WHERE user_id = ?;`, id)
if err != nil {
    log.Fatal(err)
}
rows, err := result.RowsAffected()
if err != nil {
    log.Fatal(err)
}
if rows != 1 {
    log.Fatalf(&#34;expected single row affected, got %d rows affected&#34;, rows)
}
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Conn.PingContext">func (*Conn) <a href="/src/database/sql/sql.go?s=55829:55882#L1994">PingContext</a>
					<a class="permalink" href="#Conn.PingContext">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func (c *<a href="#Conn">Conn</a>) PingContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>PingContext verifies the connection to the database is still alive.

				
				
				
			
				
				<h3 id="Conn.PrepareContext">func (*Conn) <a href="/src/database/sql/sql.go?s=57617:57696#L2041">PrepareContext</a>
					<a class="permalink" href="#Conn.PrepareContext">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func (c *<a href="#Conn">Conn</a>) PrepareContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, query <a href="/pkg/builtin/#string">string</a>) (*<a href="#Stmt">Stmt</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>PrepareContext creates a prepared statement for later queries or executions.
Multiple queries or executions may be run concurrently from the
returned statement.
The caller must call the statement&apos;s <a href="#Stmt.Close">*Stmt.Close</a> method
when the statement is no longer needed.
<p>The provided context is used for the preparation of the statement, not for the
execution of the statement.

				
				
				
			
				
				<h3 id="Conn.QueryContext">func (*Conn) <a href="/src/database/sql/sql.go?s=56472:56562#L2014">QueryContext</a>
					<a class="permalink" href="#Conn.QueryContext">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func (c *<a href="#Conn">Conn</a>) QueryContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, query <a href="/pkg/builtin/#string">string</a>, args ...<a href="/pkg/builtin/#any">any</a>) (*<a href="#Rows">Rows</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>QueryContext executes a query that returns rows, typically a SELECT.
The args are for any placeholder parameters in the query.

				
				
				
			
				
				<h3 id="Conn.QueryRowContext">func (*Conn) <a href="/src/database/sql/sql.go?s=57053:57136#L2028">QueryRowContext</a>
					<a class="permalink" href="#Conn.QueryRowContext">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func (c *<a href="#Conn">Conn</a>) QueryRowContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, query <a href="/pkg/builtin/#string">string</a>, args ...<a href="/pkg/builtin/#any">any</a>) *<a href="#Row">Row</a></pre>
				<p>QueryRowContext executes a query that is expected to return at most one row.
QueryRowContext always returns a non-nil value. Errors are deferred until
the <a href="#Row.Scan">*Row.Scan</a> method is called.
If the query selects no rows, the <a href="#Row.Scan">*Row.Scan</a> will return <a href="#ErrNoRows">ErrNoRows</a>.
Otherwise, the <a href="#Row.Scan">*Row.Scan</a> scans the first selected row and discards
the rest.

				
				
				
			
				
				<h3 id="Conn.Raw">func (*Conn) <a href="/src/database/sql/sql.go?s=58088:58148#L2054">Raw</a>
					<a class="permalink" href="#Conn.Raw">&#xb6;</a>
					
					<span title="Added in Go 1.13">1.13</span>
				</h3>
				<pre>func (c *<a href="#Conn">Conn</a>) Raw(f func(driverConn <a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#error">error</a>) (err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Raw executes f exposing the underlying driver connection for the
duration of f. The driverConn must not be used outside of f.
<p>Once f returns and err is not <a href="/database/sql/driver#ErrBadConn">driver.ErrBadConn</a>, the <a href="#Conn">Conn</a> will continue to be usable
until <a href="#Conn.Close">Conn.Close</a> is called.

				
				
				
			
		
			
			
			<h2 id="DB">type <a href="/src/database/sql/sql.go?s=13183:14997#L489">DB</a>
				<a class="permalink" href="#DB">&#xb6;</a>
				
				
			</h2>
			<p>DB is a database handle representing a pool of zero or more
underlying connections. It&apos;s safe for concurrent use by multiple
goroutines.
<p>The sql package creates and frees connections automatically; it
also maintains a free pool of idle connections. If the database has
a concept of per-connection state, such state can be reliably observed
within a transaction (<a href="#Tx">Tx</a>) or connection (<a href="#Conn">Conn</a>). Once <a href="#DB.Begin">DB.Begin</a> is called, the
returned <a href="#Tx">Tx</a> is bound to a single connection. Once <a href="#Tx.Commit">Tx.Commit</a> or
<a href="#Tx.Rollback">Tx.Rollback</a> is called on the transaction, that transaction&apos;s
connection is returned to <a href="#DB">DB</a>&apos;s idle connection pool. The pool size
can be controlled with <a href="#DB.SetMaxIdleConns">DB.SetMaxIdleConns</a>.

			<pre>type DB struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="Open">func <a href="/src/database/sql/sql.go?s=24050:24107#L845">Open</a>
					<a class="permalink" href="#Open">&#xb6;</a>
					
					
				</h3>
				<pre>func Open(driverName, dataSourceName <a href="/pkg/builtin/#string">string</a>) (*<a href="#DB">DB</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Open opens a database specified by its database driver name and a
driver-specific data source name, usually consisting of at least a
database name and connection information.
<p>Most users will open a database via a driver-specific connection
helper function that returns a <a href="#DB">*DB</a>. No database drivers are included
in the Go standard library. See <a href="https://golang.org/s/sqldrivers">https://golang.org/s/sqldrivers</a> for
a list of third-party drivers.
<p>Open may just validate its arguments without creating a connection
to the database. To verify that the data source name is valid, call
<a href="#DB.Ping">DB.Ping</a>.
<p>The returned <a href="#DB">DB</a> is safe for concurrent use by multiple goroutines
and maintains its own pool of idle connections. Thus, the Open
function should be called just once. It is rarely necessary to
close a <a href="#DB">DB</a>.

				
				
			
				
				<h3 id="OpenDB">func <a href="/src/database/sql/sql.go?s=22938:22973#L814">OpenDB</a>
					<a class="permalink" href="#OpenDB">&#xb6;</a>
					
					<span title="Added in Go 1.10">1.10</span>
				</h3>
				<pre>func OpenDB(c <a href="/pkg/database/sql/driver/">driver</a>.<a href="/pkg/database/sql/driver/#Connector">Connector</a>) *<a href="#DB">DB</a></pre>
				<p>OpenDB opens a database using a <a href="/database/sql/driver#Connector">driver.Connector</a>, allowing drivers to
bypass a string based data source name.
<p>Most users will open a database via a driver-specific connection
helper function that returns a <a href="#DB">*DB</a>. No database drivers are included
in the Go standard library. See <a href="https://golang.org/s/sqldrivers">https://golang.org/s/sqldrivers</a> for
a list of third-party drivers.
<p>OpenDB may just validate its arguments without creating a connection
to the database. To verify that the data source name is valid, call
<a href="#DB.Ping">DB.Ping</a>.
<p>The returned <a href="#DB">DB</a> is safe for concurrent use by multiple goroutines
and maintains its own pool of idle connections. Thus, the OpenDB
function should be called just once. It is rarely necessary to
close a <a href="#DB">DB</a>.

				
				
			

			
				
				<h3 id="DB.Begin">func (*DB) <a href="/src/database/sql/sql.go?s=51971:52005#L1868">Begin</a>
					<a class="permalink" href="#DB.Begin">&#xb6;</a>
					
					
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) Begin() (*<a href="#Tx">Tx</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Begin starts a transaction. The default isolation level is dependent on
the driver.
<p>Begin uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#DB.BeginTx">DB.BeginTx</a>.

				
				
				
			
				
				<h3 id="DB.BeginTx">func (*DB) <a href="/src/database/sql/sql.go?s=51547:51619#L1851">BeginTx</a>
					<a class="permalink" href="#DB.BeginTx">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) BeginTx(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, opts *<a href="#TxOptions">TxOptions</a>) (*<a href="#Tx">Tx</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>BeginTx starts a transaction.
<p>The provided context is used until the transaction is committed or rolled back.
If the context is canceled, the sql package will roll back
the transaction. <a href="#Tx.Commit">Tx.Commit</a> will return an error if the context provided to
BeginTx is canceled.
<p>The provided <a href="#TxOptions">TxOptions</a> is optional and may be nil if defaults should be used.
If a non-default isolation level is used that the driver doesn&apos;t support,
an error will be returned.

				
				<div id="example_DB_BeginTx" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
tx, err := db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelSerializable})
if err != nil {
    log.Fatal(err)
}
id := 37
_, execErr := tx.Exec(`UPDATE users SET status = ? WHERE id = ?`, &#34;paid&#34;, id)
if execErr != nil {
    _ = tx.Rollback()
    log.Fatal(execErr)
}
if err := tx.Commit(); err != nil {
    log.Fatal(err)
}
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="DB.Close">func (*DB) <a href="/src/database/sql/sql.go?s=25741:25768#L908">Close</a>
					<a class="permalink" href="#DB.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Close closes the database and prevents new queries from starting.
Close then waits for all queries that have started processing on the server
to finish.
<p>It is rare to Close a <a href="#DB">DB</a>, as the <a href="#DB">DB</a> handle is meant to be
long-lived and shared between many goroutines.

				
				
				
			
				
				<h3 id="DB.Conn">func (*DB) <a href="/src/database/sql/sql.go?s=53999:54053#L1927">Conn</a>
					<a class="permalink" href="#DB.Conn">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) Conn(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>) (*<a href="#Conn">Conn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Conn returns a single connection by either opening a new connection
or returning an existing connection from the connection pool. Conn will
block until either a connection is returned or ctx is canceled.
Queries run on the same Conn will be run in the same database session.
<p>Every Conn must be returned to the database pool after use by
calling <a href="#Conn.Close">Conn.Close</a>.

				
				
				
			
				
				<h3 id="DB.Driver">func (*DB) <a href="/src/database/sql/sql.go?s=53344:53380#L1912">Driver</a>
					<a class="permalink" href="#DB.Driver">&#xb6;</a>
					
					
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) Driver() <a href="/pkg/database/sql/driver/">driver</a>.<a href="/pkg/database/sql/driver/#Driver">Driver</a></pre>
				<p>Driver returns the database&apos;s underlying driver.

				
				
				
			
				
				<h3 id="DB.Exec">func (*DB) <a href="/src/database/sql/sql.go?s=46006:46067#L1666">Exec</a>
					<a class="permalink" href="#DB.Exec">&#xb6;</a>
					
					
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) Exec(query <a href="/pkg/builtin/#string">string</a>, args ...<a href="/pkg/builtin/#any">any</a>) (<a href="#Result">Result</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Exec executes a query without returning any rows.
The args are for any placeholder parameters in the query.
<p>Exec uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#DB.ExecContext">DB.ExecContext</a>.

				
				
				
			
				
				<h3 id="DB.ExecContext">func (*DB) <a href="/src/database/sql/sql.go?s=45526:45615#L1649">ExecContext</a>
					<a class="permalink" href="#DB.ExecContext">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) ExecContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, query <a href="/pkg/builtin/#string">string</a>, args ...<a href="/pkg/builtin/#any">any</a>) (<a href="#Result">Result</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ExecContext executes a query without returning any rows.
The args are for any placeholder parameters in the query.

				
				<div id="example_DB_ExecContext" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
id := 47
result, err := db.ExecContext(ctx, &#34;UPDATE balances SET balance = balance + 10 WHERE user_id = ?&#34;, id)
if err != nil {
    log.Fatal(err)
}
rows, err := result.RowsAffected()
if err != nil {
    log.Fatal(err)
}
if rows != 1 {
    log.Fatalf(&#34;expected to affect 1 row, affected %d&#34;, rows)
}
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="DB.Ping">func (*DB) <a href="/src/database/sql/sql.go?s=25384:25410#L898">Ping</a>
					<a class="permalink" href="#DB.Ping">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) Ping() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Ping verifies a connection to the database is still alive,
establishing a connection if necessary.
<p>Ping uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#DB.PingContext">DB.PingContext</a>.

				
				
				
			
				
				<h3 id="DB.PingContext">func (*DB) <a href="/src/database/sql/sql.go?s=24900:24952#L877">PingContext</a>
					<a class="permalink" href="#DB.PingContext">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) PingContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>PingContext verifies a connection to the database is still alive,
establishing a connection if necessary.

				
				<div id="example_DB_PingContext" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Ping and PingContext may be used to determine if communication with</span>
<span class="comment">// the database server is still possible.</span>
<span class="comment">//</span>
<span class="comment">// When used in a command line application Ping may be used to establish</span>
<span class="comment">// that further queries are possible; that the provided DSN is valid.</span>
<span class="comment">//</span>
<span class="comment">// When used in long running service Ping may be part of the health</span>
<span class="comment">// checking system.</span>

ctx, cancel := context.WithTimeout(ctx, 1*time.Second)
defer cancel()

status := &#34;up&#34;
if err := db.PingContext(ctx); err != nil {
    status = &#34;down&#34;
}
log.Println(status)
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="DB.Prepare">func (*DB) <a href="/src/database/sql/sql.go?s=43818:43868#L1596">Prepare</a>
					<a class="permalink" href="#DB.Prepare">&#xb6;</a>
					
					
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) Prepare(query <a href="/pkg/builtin/#string">string</a>) (*<a href="#Stmt">Stmt</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Prepare creates a prepared statement for later queries or executions.
Multiple queries or executions may be run concurrently from the
returned statement.
The caller must call the statement&apos;s <a href="#Stmt.Close">*Stmt.Close</a> method
when the statement is no longer needed.
<p>Prepare uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#DB.PrepareContext">DB.PrepareContext</a>.

				
				<div id="example_DB_Prepare" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
projects := []struct {
    mascot  string
    release int
}{
    {&#34;tux&#34;, 1991},
    {&#34;duke&#34;, 1996},
    {&#34;gopher&#34;, 2009},
    {&#34;moby dock&#34;, 2013},
}

stmt, err := db.Prepare(&#34;INSERT INTO projects(id, mascot, release, category) VALUES( ?, ?, ?, ? )&#34;)
if err != nil {
    log.Fatal(err)
}
defer stmt.Close() <span class="comment">// Prepared statements take up server resources and should be closed after use.</span>

for id, project := range projects {
    if _, err := stmt.Exec(id+1, project.mascot, project.release, &#34;open source&#34;); err != nil {
        log.Fatal(err)
    }
}
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="DB.PrepareContext">func (*DB) <a href="/src/database/sql/sql.go?s=43191:43269#L1576">PrepareContext</a>
					<a class="permalink" href="#DB.PrepareContext">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) PrepareContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, query <a href="/pkg/builtin/#string">string</a>) (*<a href="#Stmt">Stmt</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>PrepareContext creates a prepared statement for later queries or executions.
Multiple queries or executions may be run concurrently from the
returned statement.
The caller must call the statement&apos;s <a href="#Stmt.Close">*Stmt.Close</a> method
when the statement is no longer needed.
<p>The provided context is used for the preparation of the statement, not for the
execution of the statement.

				
				
				
			
				
				<h3 id="DB.Query">func (*DB) <a href="/src/database/sql/sql.go?s=47921:47982#L1736">Query</a>
					<a class="permalink" href="#DB.Query">&#xb6;</a>
					
					
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) Query(query <a href="/pkg/builtin/#string">string</a>, args ...<a href="/pkg/builtin/#any">any</a>) (*<a href="#Rows">Rows</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Query executes a query that returns rows, typically a SELECT.
The args are for any placeholder parameters in the query.
<p>Query uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#DB.QueryContext">DB.QueryContext</a>.

				
				<div id="example_DB_Query_multipleResultSets" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (MultipleResultSets)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (MultipleResultSets)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
age := 27
q := `
create temp table uid (id bigint); -- Create temp table for queries.
insert into uid
select id from users where age &lt; ?; -- Populate temp table.

-- First result set.
select
    users.id, name
from
    users
    join uid on users.id = uid.id
;

-- Second result set.
select 
    ur.user, ur.role
from
    user_roles as ur
    join uid on uid.id = ur.user
;
    `
rows, err := db.Query(q, age)
if err != nil {
    log.Fatal(err)
}
defer rows.Close()

for rows.Next() {
    var (
        id   int64
        name string
    )
    if err := rows.Scan(&amp;id, &amp;name); err != nil {
        log.Fatal(err)
    }
    log.Printf(&#34;id %d name is %s\n&#34;, id, name)
}
if !rows.NextResultSet() {
    log.Fatalf(&#34;expected more result sets: %v&#34;, rows.Err())
}
var roleMap = map[int64]string{
    1: &#34;user&#34;,
    2: &#34;admin&#34;,
    3: &#34;gopher&#34;,
}
for rows.Next() {
    var (
        id   int64
        role int64
    )
    if err := rows.Scan(&amp;id, &amp;role); err != nil {
        log.Fatal(err)
    }
    log.Printf(&#34;id %d has role %s\n&#34;, id, roleMap[role])
}
if err := rows.Err(); err != nil {
    log.Fatal(err)
}
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="DB.QueryContext">func (*DB) <a href="/src/database/sql/sql.go?s=47424:47513#L1719">QueryContext</a>
					<a class="permalink" href="#DB.QueryContext">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) QueryContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, query <a href="/pkg/builtin/#string">string</a>, args ...<a href="/pkg/builtin/#any">any</a>) (*<a href="#Rows">Rows</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>QueryContext executes a query that returns rows, typically a SELECT.
The args are for any placeholder parameters in the query.

				
				<div id="example_DB_QueryContext" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
age := 27
rows, err := db.QueryContext(ctx, &#34;SELECT name FROM users WHERE age=?&#34;, age)
if err != nil {
    log.Fatal(err)
}
defer rows.Close()
names := make([]string, 0)

for rows.Next() {
    var name string
    if err := rows.Scan(&amp;name); err != nil {
        <span class="comment">// Check for a scan error.</span>
        <span class="comment">// Query rows will be closed with defer.</span>
        log.Fatal(err)
    }
    names = append(names, name)
}
<span class="comment">// If the database is being written to ensure to check for Close</span>
<span class="comment">// errors that may be returned from the driver. The query may</span>
<span class="comment">// encounter an auto-commit error and be forced to rollback changes.</span>
rerr := rows.Close()
if rerr != nil {
    log.Fatal(rerr)
}

<span class="comment">// Rows.Err will report the last error encountered by Rows.Scan.</span>
if err := rows.Err(); err != nil {
    log.Fatal(err)
}
fmt.Printf(&#34;%s are %d years old&#34;, strings.Join(names, &#34;, &#34;), age)
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="DB.QueryRow">func (*DB) <a href="/src/database/sql/sql.go?s=50944:50998#L1837">QueryRow</a>
					<a class="permalink" href="#DB.QueryRow">&#xb6;</a>
					
					
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) QueryRow(query <a href="/pkg/builtin/#string">string</a>, args ...<a href="/pkg/builtin/#any">any</a>) *<a href="#Row">Row</a></pre>
				<p>QueryRow executes a query that is expected to return at most one row.
QueryRow always returns a non-nil value. Errors are deferred until
<a href="#Row">Row</a>&apos;s Scan method is called.
If the query selects no rows, the <a href="#Row.Scan">*Row.Scan</a> will return <a href="#ErrNoRows">ErrNoRows</a>.
Otherwise, <a href="#Row.Scan">*Row.Scan</a> scans the first selected row and discards
the rest.
<p>QueryRow uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#DB.QueryRowContext">DB.QueryRowContext</a>.

				
				
				
			
				
				<h3 id="DB.QueryRowContext">func (*DB) <a href="/src/database/sql/sql.go?s=50332:50414#L1823">QueryRowContext</a>
					<a class="permalink" href="#DB.QueryRowContext">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) QueryRowContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, query <a href="/pkg/builtin/#string">string</a>, args ...<a href="/pkg/builtin/#any">any</a>) *<a href="#Row">Row</a></pre>
				<p>QueryRowContext executes a query that is expected to return at most one row.
QueryRowContext always returns a non-nil value. Errors are deferred until
<a href="#Row">Row</a>&apos;s Scan method is called.
If the query selects no rows, the <a href="#Row.Scan">*Row.Scan</a> will return <a href="#ErrNoRows">ErrNoRows</a>.
Otherwise, <a href="#Row.Scan">*Row.Scan</a> scans the first selected row and discards
the rest.

				
				<div id="example_DB_QueryRowContext" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
id := 123
var username string
var created time.Time
err := db.QueryRowContext(ctx, &#34;SELECT username, created_at FROM users WHERE id=?&#34;, id).Scan(&amp;username, &amp;created)
switch {
case err == sql.ErrNoRows:
    log.Printf(&#34;no user with id %d\n&#34;, id)
case err != nil:
    log.Fatalf(&#34;query error: %v\n&#34;, err)
default:
    log.Printf(&#34;username is %q, account created on %s\n&#34;, username, created)
}
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="DB.SetConnMaxIdleTime">func (*DB) <a href="/src/database/sql/sql.go?s=29161:29210#L1051">SetConnMaxIdleTime</a>
					<a class="permalink" href="#DB.SetConnMaxIdleTime">&#xb6;</a>
					
					<span title="Added in Go 1.15">1.15</span>
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) SetConnMaxIdleTime(d <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a>)</pre>
				<p>SetConnMaxIdleTime sets the maximum amount of time a connection may be idle.
<p>Expired connections may be closed lazily before reuse.
<p>If d &lt;= 0, connections are not closed due to a connection&apos;s idle time.

				
				
				
			
				
				<h3 id="DB.SetConnMaxLifetime">func (*DB) <a href="/src/database/sql/sql.go?s=28621:28670#L1029">SetConnMaxLifetime</a>
					<a class="permalink" href="#DB.SetConnMaxLifetime">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) SetConnMaxLifetime(d <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a>)</pre>
				<p>SetConnMaxLifetime sets the maximum amount of time a connection may be reused.
<p>Expired connections may be closed lazily before reuse.
<p>If d &lt;= 0, connections are not closed due to a connection&apos;s age.

				
				
				
			
				
				<h3 id="DB.SetMaxIdleConns">func (*DB) <a href="/src/database/sql/sql.go?s=27226:27262#L977">SetMaxIdleConns</a>
					<a class="permalink" href="#DB.SetMaxIdleConns">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) SetMaxIdleConns(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>SetMaxIdleConns sets the maximum number of connections in the idle
connection pool.
<p>If MaxOpenConns is greater than 0 but less than the new MaxIdleConns,
then the new MaxIdleConns will be reduced to match the MaxOpenConns limit.
<p>If n &lt;= 0, no idle connections are retained.
<p>The default max idle connections is currently 2. This may change in
a future release.

				
				
				
			
				
				<h3 id="DB.SetMaxOpenConns">func (*DB) <a href="/src/database/sql/sql.go?s=28171:28207#L1011">SetMaxOpenConns</a>
					<a class="permalink" href="#DB.SetMaxOpenConns">&#xb6;</a>
					
					<span title="Added in Go 1.2">1.2</span>
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) SetMaxOpenConns(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>SetMaxOpenConns sets the maximum number of open connections to the database.
<p>If MaxIdleConns is greater than 0 and the new MaxOpenConns is less than
MaxIdleConns, then MaxIdleConns will be reduced to match the new
MaxOpenConns limit.
<p>If n &lt;= 0, then there is no limit on the number of open connections.
The default is 0 (unlimited).

				
				
				
			
				
				<h3 id="DB.Stats">func (*DB) <a href="/src/database/sql/sql.go?s=33118:33147#L1197">Stats</a>
					<a class="permalink" href="#DB.Stats">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (db *<a href="#DB">DB</a>) Stats() <a href="#DBStats">DBStats</a></pre>
				<p>Stats returns database statistics.

				
				
				
			
		
			
			
			<h2 id="DBStats">type <a href="/src/database/sql/sql.go?s=32265:33078#L1180">DBStats</a>
				<a class="permalink" href="#DBStats">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>DBStats contains database statistics.

			<pre>type DBStats struct {
<span id="DBStats.MaxOpenConnections"></span>    MaxOpenConnections <a href="/pkg/builtin/#int">int</a> <span class="comment">// Maximum number of open connections to the database; added in Go 1.11</span>

    <span class="comment">// Pool Status</span>
<span id="DBStats.OpenConnections"></span>    OpenConnections <a href="/pkg/builtin/#int">int</a> <span class="comment">// The number of established connections both in use and idle.</span>
<span id="DBStats.InUse"></span>    InUse           <a href="/pkg/builtin/#int">int</a> <span class="comment">// The number of connections currently in use; added in Go 1.11</span>
<span id="DBStats.Idle"></span>    Idle            <a href="/pkg/builtin/#int">int</a> <span class="comment">// The number of idle connections; added in Go 1.11</span>

    <span class="comment">// Counters</span>
<span id="DBStats.WaitCount"></span>    WaitCount         <a href="/pkg/builtin/#int64">int64</a>         <span class="comment">// The total number of connections waited for; added in Go 1.11</span>
<span id="DBStats.WaitDuration"></span>    WaitDuration      <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a> <span class="comment">// The total time blocked waiting for a new connection; added in Go 1.11</span>
<span id="DBStats.MaxIdleClosed"></span>    MaxIdleClosed     <a href="/pkg/builtin/#int64">int64</a>         <span class="comment">// The total number of connections closed due to SetMaxIdleConns; added in Go 1.11</span>
<span id="DBStats.MaxIdleTimeClosed"></span>    MaxIdleTimeClosed <a href="/pkg/builtin/#int64">int64</a>         <span class="comment">// The total number of connections closed due to SetConnMaxIdleTime; added in Go 1.15</span>
<span id="DBStats.MaxLifetimeClosed"></span>    MaxLifetimeClosed <a href="/pkg/builtin/#int64">int64</a>         <span class="comment">// The total number of connections closed due to SetConnMaxLifetime; added in Go 1.11</span>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="IsolationLevel">type <a href="/src/database/sql/sql.go?s=3429:3452#L120">IsolationLevel</a>
				<a class="permalink" href="#IsolationLevel">&#xb6;</a>
				
				<span title="Added in Go 1.8">1.8</span>
			</h2>
			<p>IsolationLevel is the transaction isolation level used in <a href="#TxOptions">TxOptions</a>.

			<pre>type IsolationLevel <a href="/pkg/builtin/#int">int</a></pre>

			
				<p>Various isolation levels that drivers may support in <a href="#DB.BeginTx">DB.BeginTx</a>.
If a driver does not support a given isolation level an error may be returned.
<p>See <a href="https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels">https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels</a>.

				<pre>const (
    <span id="LevelDefault">LevelDefault</span> <a href="#IsolationLevel">IsolationLevel</a> = <a href="/pkg/builtin/#iota">iota</a>
    <span id="LevelReadUncommitted">LevelReadUncommitted</span>
    <span id="LevelReadCommitted">LevelReadCommitted</span>
    <span id="LevelWriteCommitted">LevelWriteCommitted</span>
    <span id="LevelRepeatableRead">LevelRepeatableRead</span>
    <span id="LevelSnapshot">LevelSnapshot</span>
    <span id="LevelSerializable">LevelSerializable</span>
    <span id="LevelLinearizable">LevelLinearizable</span>
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="IsolationLevel.String">func (IsolationLevel) <a href="/src/database/sql/sql.go?s=3940:3979#L138">String</a>
					<a class="permalink" href="#IsolationLevel.String">&#xb6;</a>
					
					<span title="Added in Go 1.11">1.11</span>
				</h3>
				<pre>func (i <a href="#IsolationLevel">IsolationLevel</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>String returns the name of the transaction isolation level.

				
				
				
			
		
			
			
			<h2 id="NamedArg">type <a href="/src/database/sql/sql.go?s=2374:2739#L82">NamedArg</a>
				<a class="permalink" href="#NamedArg">&#xb6;</a>
				
				<span title="Added in Go 1.8">1.8</span>
			</h2>
			<p>A NamedArg is a named argument. NamedArg values may be used as
arguments to <a href="#DB.Query">DB.Query</a> or <a href="#DB.Exec">DB.Exec</a> and bind to the corresponding named
parameter in the SQL statement.
<p>For a more concise way to create NamedArg values, see
the <a href="#Named">Named</a> function.

			<pre>type NamedArg struct {

<span id="NamedArg.Name"></span>    <span class="comment">// Name is the name of the parameter placeholder.</span>
    <span class="comment">//</span>
    <span class="comment">// If empty, the ordinal position in the argument list will be</span>
    <span class="comment">// used.</span>
    <span class="comment">//</span>
    <span class="comment">// Name must omit any symbol prefix.</span>
    Name <a href="/pkg/builtin/#string">string</a>

<span id="NamedArg.Value"></span>    <span class="comment">// Value is the value of the parameter.</span>
    <span class="comment">// It may be assigned the same value types as the query</span>
    <span class="comment">// arguments.</span>
    Value <a href="/pkg/builtin/#any">any</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="Named">func <a href="/src/database/sql/sql.go?s=3043:3086#L111">Named</a>
					<a class="permalink" href="#Named">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func Named(name <a href="/pkg/builtin/#string">string</a>, value <a href="/pkg/builtin/#any">any</a>) <a href="#NamedArg">NamedArg</a></pre>
				<p>Named provides a more concise way to create <a href="#NamedArg">NamedArg</a> values.
<p>Example usage:
<pre>db.ExecContext(ctx, `
    delete from Invoice
    where
        TimeCreated &lt; @end
        and TimeCreated &gt;= @start;`,
    sql.Named(&quot;start&quot;, startTime),
    sql.Named(&quot;end&quot;, endTime),
)
</pre>

				
				
			

			
		
			
			
			<h2 id="Null">type <a href="/src/database/sql/sql.go?s=10587:10635#L407">Null</a>
				<a class="permalink" href="#Null">&#xb6;</a>
				
				
			</h2>
			<p>Null represents a value that may be null.
Null implements the <a href="#Scanner">Scanner</a> interface so
it can be used as a scan destination:
<pre>var s Null[string]
err := db.QueryRow(&quot;SELECT name FROM foo WHERE id=?&quot;, id).Scan(&amp;s)
...
if s.Valid {
   // use s.V
} else {
   // NULL value
}
</pre>

			<pre>type Null[T <a href="/pkg/builtin/#any">any</a>] struct {
<span id="Null.V"></span>    V     T
<span id="Null.Valid"></span>    Valid <a href="/pkg/builtin/#bool">bool</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Null.Scan">func (*Null[T]) <a href="/src/database/sql/sql.go?s=10637:10676#L412">Scan</a>
					<a class="permalink" href="#Null.Scan">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Null">Null</a>[T]) Scan(value <a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#error">error</a></pre>
				
				
				
				
			
				
				<h3 id="Null.Value">func (Null[T]) <a href="/src/database/sql/sql.go?s=10800:10846#L421">Value</a>
					<a class="permalink" href="#Null.Value">&#xb6;</a>
					
					
				</h3>
				<pre>func (n <a href="#Null">Null</a>[T]) Value() (<a href="/pkg/database/sql/driver/">driver</a>.<a href="/pkg/database/sql/driver/#Value">Value</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="NullBool">type <a href="/src/database/sql/sql.go?s=9183:9268#L346">NullBool</a>
				<a class="permalink" href="#NullBool">&#xb6;</a>
				
				
			</h2>
			<p>NullBool represents a bool that may be null.
NullBool implements the <a href="#Scanner">Scanner</a> interface so
it can be used as a scan destination, similar to <a href="#NullString">NullString</a>.

			<pre>type NullBool struct {
<span id="NullBool.Bool"></span>    Bool  <a href="/pkg/builtin/#bool">bool</a>
<span id="NullBool.Valid"></span>    Valid <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// Valid is true if Bool is not NULL</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="NullBool.Scan">func (*NullBool) <a href="/src/database/sql/sql.go?s=9314:9354#L352">Scan</a>
					<a class="permalink" href="#NullBool.Scan">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#NullBool">NullBool</a>) Scan(value <a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>Scan implements the <a href="#Scanner">Scanner</a> interface.

				
				
				
			
				
				<h3 id="NullBool.Value">func (NullBool) <a href="/src/database/sql/sql.go?s=9533:9580#L362">Value</a>
					<a class="permalink" href="#NullBool.Value">&#xb6;</a>
					
					
				</h3>
				<pre>func (n <a href="#NullBool">NullBool</a>) Value() (<a href="/pkg/database/sql/driver/">driver</a>.<a href="/pkg/database/sql/driver/#Value">Value</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Value implements the <a href="/database/sql/driver#Valuer">driver.Valuer</a> interface.

				
				
				
			
		
			
			
			<h2 id="NullByte">type <a href="/src/database/sql/sql.go?s=7883:7968#L293">NullByte</a>
				<a class="permalink" href="#NullByte">&#xb6;</a>
				
				<span title="Added in Go 1.17">1.17</span>
			</h2>
			<p>NullByte represents a byte that may be null.
NullByte implements the <a href="#Scanner">Scanner</a> interface so
it can be used as a scan destination, similar to <a href="#NullString">NullString</a>.

			<pre>type NullByte struct {
<span id="NullByte.Byte"></span>    Byte  <a href="/pkg/builtin/#byte">byte</a>
<span id="NullByte.Valid"></span>    Valid <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// Valid is true if Byte is not NULL</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="NullByte.Scan">func (*NullByte) <a href="/src/database/sql/sql.go?s=8014:8054#L299">Scan</a>
					<a class="permalink" href="#NullByte.Scan">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (n *<a href="#NullByte">NullByte</a>) Scan(value <a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>Scan implements the <a href="#Scanner">Scanner</a> interface.

				
				
				
			
				
				<h3 id="NullByte.Value">func (NullByte) <a href="/src/database/sql/sql.go?s=8247:8294#L310">Value</a>
					<a class="permalink" href="#NullByte.Value">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (n <a href="#NullByte">NullByte</a>) Value() (<a href="/pkg/database/sql/driver/">driver</a>.<a href="/pkg/database/sql/driver/#Value">Value</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Value implements the <a href="/database/sql/driver#Valuer">driver.Valuer</a> interface.

				
				
				
			
		
			
			
			<h2 id="NullFloat64">type <a href="/src/database/sql/sql.go?s=8536:8634#L320">NullFloat64</a>
				<a class="permalink" href="#NullFloat64">&#xb6;</a>
				
				
			</h2>
			<p>NullFloat64 represents a float64 that may be null.
NullFloat64 implements the <a href="#Scanner">Scanner</a> interface so
it can be used as a scan destination, similar to <a href="#NullString">NullString</a>.

			<pre>type NullFloat64 struct {
<span id="NullFloat64.Float64"></span>    Float64 <a href="/pkg/builtin/#float64">float64</a>
<span id="NullFloat64.Valid"></span>    Valid   <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// Valid is true if Float64 is not NULL</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="NullFloat64.Scan">func (*NullFloat64) <a href="/src/database/sql/sql.go?s=8680:8723#L326">Scan</a>
					<a class="permalink" href="#NullFloat64.Scan">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#NullFloat64">NullFloat64</a>) Scan(value <a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>Scan implements the <a href="#Scanner">Scanner</a> interface.

				
				
				
			
				
				<h3 id="NullFloat64.Value">func (NullFloat64) <a href="/src/database/sql/sql.go?s=8904:8954#L336">Value</a>
					<a class="permalink" href="#NullFloat64.Value">&#xb6;</a>
					
					
				</h3>
				<pre>func (n <a href="#NullFloat64">NullFloat64</a>) Value() (<a href="/pkg/database/sql/driver/">driver</a>.<a href="/pkg/database/sql/driver/#Value">Value</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Value implements the <a href="/database/sql/driver#Valuer">driver.Valuer</a> interface.

				
				
				
			
		
			
			
			<h2 id="NullInt16">type <a href="/src/database/sql/sql.go?s=7231:7319#L266">NullInt16</a>
				<a class="permalink" href="#NullInt16">&#xb6;</a>
				
				<span title="Added in Go 1.17">1.17</span>
			</h2>
			<p>NullInt16 represents an int16 that may be null.
NullInt16 implements the <a href="#Scanner">Scanner</a> interface so
it can be used as a scan destination, similar to <a href="#NullString">NullString</a>.

			<pre>type NullInt16 struct {
<span id="NullInt16.Int16"></span>    Int16 <a href="/pkg/builtin/#int16">int16</a>
<span id="NullInt16.Valid"></span>    Valid <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// Valid is true if Int16 is not NULL</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="NullInt16.Scan">func (*NullInt16) <a href="/src/database/sql/sql.go?s=7365:7406#L272">Scan</a>
					<a class="permalink" href="#NullInt16.Scan">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (n *<a href="#NullInt16">NullInt16</a>) Scan(value <a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>Scan implements the <a href="#Scanner">Scanner</a> interface.

				
				
				
			
				
				<h3 id="NullInt16.Value">func (NullInt16) <a href="/src/database/sql/sql.go?s=7601:7649#L283">Value</a>
					<a class="permalink" href="#NullInt16.Value">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (n <a href="#NullInt16">NullInt16</a>) Value() (<a href="/pkg/database/sql/driver/">driver</a>.<a href="/pkg/database/sql/driver/#Value">Value</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Value implements the <a href="/database/sql/driver#Valuer">driver.Valuer</a> interface.

				
				
				
			
		
			
			
			<h2 id="NullInt32">type <a href="/src/database/sql/sql.go?s=6593:6681#L240">NullInt32</a>
				<a class="permalink" href="#NullInt32">&#xb6;</a>
				
				<span title="Added in Go 1.13">1.13</span>
			</h2>
			<p>NullInt32 represents an int32 that may be null.
NullInt32 implements the <a href="#Scanner">Scanner</a> interface so
it can be used as a scan destination, similar to <a href="#NullString">NullString</a>.

			<pre>type NullInt32 struct {
<span id="NullInt32.Int32"></span>    Int32 <a href="/pkg/builtin/#int32">int32</a>
<span id="NullInt32.Valid"></span>    Valid <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// Valid is true if Int32 is not NULL</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="NullInt32.Scan">func (*NullInt32) <a href="/src/database/sql/sql.go?s=6727:6768#L246">Scan</a>
					<a class="permalink" href="#NullInt32.Scan">&#xb6;</a>
					
					<span title="Added in Go 1.13">1.13</span>
				</h3>
				<pre>func (n *<a href="#NullInt32">NullInt32</a>) Scan(value <a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>Scan implements the <a href="#Scanner">Scanner</a> interface.

				
				
				
			
				
				<h3 id="NullInt32.Value">func (NullInt32) <a href="/src/database/sql/sql.go?s=6945:6993#L256">Value</a>
					<a class="permalink" href="#NullInt32.Value">&#xb6;</a>
					
					<span title="Added in Go 1.13">1.13</span>
				</h3>
				<pre>func (n <a href="#NullInt32">NullInt32</a>) Value() (<a href="/pkg/database/sql/driver/">driver</a>.<a href="/pkg/database/sql/driver/#Value">Value</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Value implements the <a href="/database/sql/driver#Valuer">driver.Valuer</a> interface.

				
				
				
			
		
			
			
			<h2 id="NullInt64">type <a href="/src/database/sql/sql.go?s=5962:6050#L214">NullInt64</a>
				<a class="permalink" href="#NullInt64">&#xb6;</a>
				
				
			</h2>
			<p>NullInt64 represents an int64 that may be null.
NullInt64 implements the <a href="#Scanner">Scanner</a> interface so
it can be used as a scan destination, similar to <a href="#NullString">NullString</a>.

			<pre>type NullInt64 struct {
<span id="NullInt64.Int64"></span>    Int64 <a href="/pkg/builtin/#int64">int64</a>
<span id="NullInt64.Valid"></span>    Valid <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// Valid is true if Int64 is not NULL</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="NullInt64.Scan">func (*NullInt64) <a href="/src/database/sql/sql.go?s=6096:6137#L220">Scan</a>
					<a class="permalink" href="#NullInt64.Scan">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#NullInt64">NullInt64</a>) Scan(value <a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>Scan implements the <a href="#Scanner">Scanner</a> interface.

				
				
				
			
				
				<h3 id="NullInt64.Value">func (NullInt64) <a href="/src/database/sql/sql.go?s=6314:6362#L230">Value</a>
					<a class="permalink" href="#NullInt64.Value">&#xb6;</a>
					
					
				</h3>
				<pre>func (n <a href="#NullInt64">NullInt64</a>) Value() (<a href="/pkg/database/sql/driver/">driver</a>.<a href="/pkg/database/sql/driver/#Value">Value</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Value implements the <a href="/database/sql/driver#Valuer">driver.Valuer</a> interface.

				
				
				
			
		
			
			
			<h2 id="NullString">type <a href="/src/database/sql/sql.go?s=5312:5405#L188">NullString</a>
				<a class="permalink" href="#NullString">&#xb6;</a>
				
				
			</h2>
			<p>NullString represents a string that may be null.
NullString implements the <a href="#Scanner">Scanner</a> interface so
it can be used as a scan destination:
<pre>var s NullString
err := db.QueryRow(&quot;SELECT name FROM foo WHERE id=?&quot;, id).Scan(&amp;s)
...
if s.Valid {
   // use s.String
} else {
   // NULL value
}
</pre>

			<pre>type NullString struct {
<span id="NullString.String"></span>    String <a href="/pkg/builtin/#string">string</a>
<span id="NullString.Valid"></span>    Valid  <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// Valid is true if String is not NULL</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="NullString.Scan">func (*NullString) <a href="/src/database/sql/sql.go?s=5451:5494#L194">Scan</a>
					<a class="permalink" href="#NullString.Scan">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns *<a href="#NullString">NullString</a>) Scan(value <a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>Scan implements the <a href="#Scanner">Scanner</a> interface.

				
				
				
			
				
				<h3 id="NullString.Value">func (NullString) <a href="/src/database/sql/sql.go?s=5678:5728#L204">Value</a>
					<a class="permalink" href="#NullString.Value">&#xb6;</a>
					
					
				</h3>
				<pre>func (ns <a href="#NullString">NullString</a>) Value() (<a href="/pkg/database/sql/driver/">driver</a>.<a href="/pkg/database/sql/driver/#Value">Value</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Value implements the <a href="/database/sql/driver#Valuer">driver.Valuer</a> interface.

				
				
				
			
		
			
			
			<h2 id="NullTime">type <a href="/src/database/sql/sql.go?s=9813:9903#L372">NullTime</a>
				<a class="permalink" href="#NullTime">&#xb6;</a>
				
				<span title="Added in Go 1.13">1.13</span>
			</h2>
			<p>NullTime represents a <a href="/time#Time">time.Time</a> that may be null.
NullTime implements the <a href="#Scanner">Scanner</a> interface so
it can be used as a scan destination, similar to <a href="#NullString">NullString</a>.

			<pre>type NullTime struct {
<span id="NullTime.Time"></span>    Time  <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>
<span id="NullTime.Valid"></span>    Valid <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// Valid is true if Time is not NULL</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="NullTime.Scan">func (*NullTime) <a href="/src/database/sql/sql.go?s=9949:9989#L378">Scan</a>
					<a class="permalink" href="#NullTime.Scan">&#xb6;</a>
					
					<span title="Added in Go 1.13">1.13</span>
				</h3>
				<pre>func (n *<a href="#NullTime">NullTime</a>) Scan(value <a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>Scan implements the <a href="#Scanner">Scanner</a> interface.

				
				
				
			
				
				<h3 id="NullTime.Value">func (NullTime) <a href="/src/database/sql/sql.go?s=10174:10221#L388">Value</a>
					<a class="permalink" href="#NullTime.Value">&#xb6;</a>
					
					<span title="Added in Go 1.13">1.13</span>
				</h3>
				<pre>func (n <a href="#NullTime">NullTime</a>) Value() (<a href="/pkg/database/sql/driver/">driver</a>.<a href="/pkg/database/sql/driver/#Value">Value</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Value implements the <a href="/database/sql/driver#Valuer">driver.Valuer</a> interface.

				
				
				
			
		
			
			
			<h2 id="Out">type <a href="/src/database/sql/sql.go?s=11851:12237#L459">Out</a>
				<a class="permalink" href="#Out">&#xb6;</a>
				
				<span title="Added in Go 1.9">1.9</span>
			</h2>
			<p>Out may be used to retrieve OUTPUT value parameters from stored procedures.
<p>Not all drivers and databases support OUTPUT value parameters.
<p>Example usage:
<pre>var outArg string
_, err := db.ExecContext(ctx, &quot;ProcName&quot;, sql.Named(&quot;Arg1&quot;, sql.Out{Dest: &amp;outArg}))
</pre>

			<pre>type Out struct {

<span id="Out.Dest"></span>    <span class="comment">// Dest is a pointer to the value that will be set to the result of the</span>
    <span class="comment">// stored procedure&#39;s OUTPUT parameter.</span>
    Dest <a href="/pkg/builtin/#any">any</a>

<span id="Out.In"></span>    <span class="comment">// In is whether the parameter is an INOUT parameter. If so, the input value to the stored</span>
    <span class="comment">// procedure is the dereferenced value of Dest&#39;s pointer, which is then replaced with</span>
    <span class="comment">// the output value.</span>
    In <a href="/pkg/builtin/#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="RawBytes">type <a href="/src/database/sql/sql.go?s=4970:4990#L174">RawBytes</a>
				<a class="permalink" href="#RawBytes">&#xb6;</a>
				
				
			</h2>
			<p>RawBytes is a byte slice that holds a reference to memory owned by
the database itself. After a <a href="#Rows.Scan">Rows.Scan</a> into a RawBytes, the slice is only
valid until the next call to <a href="#Rows.Next">Rows.Next</a>, <a href="#Rows.Scan">Rows.Scan</a>, or <a href="#Rows.Close">Rows.Close</a>.

			<pre>type RawBytes []<a href="/pkg/builtin/#byte">byte</a></pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Result">type <a href="/src/database/sql/sql.go?s=101946:102452#L3516">Result</a>
				<a class="permalink" href="#Result">&#xb6;</a>
				
				
			</h2>
			<p>A Result summarizes an executed SQL command.

			<pre>type Result interface {
    <span class="comment">// LastInsertId returns the integer generated by the database</span>
    <span class="comment">// in response to a command. Typically this will be from an</span>
    <span class="comment">// &#34;auto increment&#34; column when inserting a new row. Not all</span>
    <span class="comment">// databases support this feature, and the syntax of such</span>
    <span class="comment">// statements varies.</span>
    LastInsertId() (<a href="/pkg/builtin/#int64">int64</a>, <a href="/pkg/builtin/#error">error</a>)

    <span class="comment">// RowsAffected returns the number of rows affected by an</span>
    <span class="comment">// update, insert, or delete. Not every database or database</span>
    <span class="comment">// driver may support this.</span>
    RowsAffected() (<a href="/pkg/builtin/#int64">int64</a>, <a href="/pkg/builtin/#error">error</a>)
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Row">type <a href="/src/database/sql/sql.go?s=99987:100104#L3459">Row</a>
				<a class="permalink" href="#Row">&#xb6;</a>
				
				
			</h2>
			<p>Row is the result of calling <a href="#DB.QueryRow">DB.QueryRow</a> to select a single row.

			<pre>type Row struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Row.Err">func (*Row) <a href="/src/database/sql/sql.go?s=101853:101878#L3511">Err</a>
					<a class="permalink" href="#Row.Err">&#xb6;</a>
					
					<span title="Added in Go 1.15">1.15</span>
				</h3>
				<pre>func (r *<a href="#Row">Row</a>) Err() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Err provides a way for wrapping packages to check for
query errors without calling <a href="#Row.Scan">Row.Scan</a>.
Err returns the error, if any, that was encountered while running the query.
If this error is not nil, this error will also be returned from <a href="#Row.Scan">Row.Scan</a>.

				
				
				
			
				
				<h3 id="Row.Scan">func (*Row) <a href="/src/database/sql/sql.go?s=100394:100431#L3470">Scan</a>
					<a class="permalink" href="#Row.Scan">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="#Row">Row</a>) Scan(dest ...<a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>Scan copies the columns from the matched row into the values
pointed at by dest. See the documentation on <a href="#Rows.Scan">Rows.Scan</a> for details.
If more than one row matches the query,
Scan uses the first row and discards the rest. If no row matches
the query, Scan returns <a href="#ErrNoRows">ErrNoRows</a>.

				
				
				
			
		
			
			
			<h2 id="Rows">type <a href="/src/database/sql/sql.go?s=82746:84599#L2911">Rows</a>
				<a class="permalink" href="#Rows">&#xb6;</a>
				
				
			</h2>
			<p>Rows is the result of a query. Its cursor starts before the first row
of the result set. Use <a href="#Rows.Next">Rows.Next</a> to advance from row to row.

			<pre>type Rows struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Rows" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
age := 27
rows, err := db.QueryContext(ctx, &#34;SELECT name FROM users WHERE age=?&#34;, age)
if err != nil {
    log.Fatal(err)
}
defer rows.Close()

names := make([]string, 0)
for rows.Next() {
    var name string
    if err := rows.Scan(&amp;name); err != nil {
        log.Fatal(err)
    }
    names = append(names, name)
}
<span class="comment">// Check for errors from iterating over rows.</span>
if err := rows.Err(); err != nil {
    log.Fatal(err)
}
log.Printf(&#34;%s are %d years old&#34;, strings.Join(names, &#34;, &#34;), age)
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="Rows.Close">func (*Rows) <a href="/src/database/sql/sql.go?s=99123:99152#L3417">Close</a>
					<a class="permalink" href="#Rows.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (rs *<a href="#Rows">Rows</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Close closes the <a href="#Rows">Rows</a>, preventing further enumeration. If <a href="#Rows.Next">Rows.Next</a> is called
and returns false and there are no further result sets,
the <a href="#Rows">Rows</a> are closed automatically and it will suffice to check the
result of <a href="#Rows.Err">Rows.Err</a>. Close is idempotent and does not affect the result of <a href="#Rows.Err">Rows.Err</a>.

				
				
				
			
				
				<h3 id="Rows.ColumnTypes">func (*Rows) <a href="/src/database/sql/sql.go?s=91118:91170#L3182">ColumnTypes</a>
					<a class="permalink" href="#Rows.ColumnTypes">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (rs *<a href="#Rows">Rows</a>) ColumnTypes() ([]*<a href="#ColumnType">ColumnType</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ColumnTypes returns column information such as column type, length,
and nullable. Some information may not be available from some drivers.

				
				
				
			
				
				<h3 id="Rows.Columns">func (*Rows) <a href="/src/database/sql/sql.go?s=90665:90708#L3165">Columns</a>
					<a class="permalink" href="#Rows.Columns">&#xb6;</a>
					
					
				</h3>
				<pre>func (rs *<a href="#Rows">Rows</a>) Columns() ([]<a href="/pkg/builtin/#string">string</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Columns returns the column names.
Columns returns an error if the rows are closed.

				
				
				
			
				
				<h3 id="Rows.Err">func (*Rows) <a href="/src/database/sql/sql.go?s=89318:89345#L3118">Err</a>
					<a class="permalink" href="#Rows.Err">&#xb6;</a>
					
					
				</h3>
				<pre>func (rs *<a href="#Rows">Rows</a>) Err() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Err returns the error, if any, that was encountered during iteration.
Err may be called after an explicit or implicit <a href="#Rows.Close">Rows.Close</a>.

				
				
				
			
				
				<h3 id="Rows.Next">func (*Rows) <a href="/src/database/sql/sql.go?s=86411:86438#L3011">Next</a>
					<a class="permalink" href="#Rows.Next">&#xb6;</a>
					
					
				</h3>
				<pre>func (rs *<a href="#Rows">Rows</a>) Next() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Next prepares the next result row for reading with the <a href="#Rows.Scan">Rows.Scan</a> method. It
returns true on success, or false if there is no next result row or an error
happened while preparing it. <a href="#Rows.Err">Rows.Err</a> should be consulted to distinguish between
the two cases.
<p>Every call to <a href="#Rows.Scan">Rows.Scan</a>, even the first one, must be preceded by a call to <a href="#Rows.Next">Rows.Next</a>.

				
				
				
			
				
				<h3 id="Rows.NextResultSet">func (*Rows) <a href="/src/database/sql/sql.go?s=88317:88353#L3077">NextResultSet</a>
					<a class="permalink" href="#Rows.NextResultSet">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (rs *<a href="#Rows">Rows</a>) NextResultSet() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>NextResultSet prepares the next result set for reading. It reports whether
there is further result sets, or false if there is no further result set
or if there is an error advancing to it. The <a href="#Rows.Err">Rows.Err</a> method should be consulted
to distinguish between the two cases.
<p>After calling NextResultSet, the <a href="#Rows.Next">Rows.Next</a> method should always be called before
scanning. If there are further result sets they may not have rows in the result
set.

				
				
				
			
				
				<h3 id="Rows.Scan">func (*Rows) <a href="/src/database/sql/sql.go?s=97119:97158#L3347">Scan</a>
					<a class="permalink" href="#Rows.Scan">&#xb6;</a>
					
					
				</h3>
				<pre>func (rs *<a href="#Rows">Rows</a>) Scan(dest ...<a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>Scan copies the columns in the current row into the values pointed
at by dest. The number of values in dest must be the same as the
number of columns in <a href="#Rows">Rows</a>.
<p>Scan converts columns read from the database into the following
common Go types and special types provided by the sql package:
<pre>*string
*[]byte
*int, *int8, *int16, *int32, *int64
*uint, *uint8, *uint16, *uint32, *uint64
*bool
*float32, *float64
*interface{}
*RawBytes
*Rows (cursor value)
any type implementing Scanner (see Scanner docs)
</pre>
<p>In the most simple case, if the type of the value from the source
column is an integer, bool or string type T and dest is of type *T,
Scan simply assigns the value through the pointer.
<p>Scan also converts between string and numeric types, as long as no
information would be lost. While Scan stringifies all numbers
scanned from numeric database columns into *string, scans into
numeric types are checked for overflow. For example, a float64 with
value 300 or a string with value &quot;300&quot; can scan into a uint16, but
not into a uint8, though float64(255) or &quot;255&quot; can scan into a
uint8. One exception is that scans of some float64 numbers to
strings may lose information when stringifying. In general, scan
floating point columns into *float64.
<p>If a dest argument has type *[]byte, Scan saves in that argument a
copy of the corresponding data. The copy is owned by the caller and
can be modified and held indefinitely. The copy can be avoided by
using an argument of type <a href="#RawBytes">*RawBytes</a> instead; see the documentation
for <a href="#RawBytes">RawBytes</a> for restrictions on its use.
<p>If an argument has type *interface{}, Scan copies the value
provided by the underlying driver without conversion. When scanning
from a source value of type []byte to *interface{}, a copy of the
slice is made and the caller owns the result.
<p>Source values of type <a href="/time#Time">time.Time</a> may be scanned into values of type
*time.Time, *interface{}, *string, or *[]byte. When converting to
the latter two, <a href="/time#RFC3339Nano">time.RFC3339Nano</a> is used.
<p>Source values of type bool may be scanned into types *bool,
*interface{}, *string, *[]byte, or <a href="#RawBytes">*RawBytes</a>.
<p>For scanning into *bool, the source may be true, false, 1, 0, or
string inputs parseable by <a href="/strconv#ParseBool">strconv.ParseBool</a>.
<p>Scan can also convert a cursor returned from a query, such as
&quot;select cursor(select * from my_table) from dual&quot;, into a
<a href="#Rows">*Rows</a> value that can itself be scanned from. The parent
select query will close any cursor <a href="#Rows">*Rows</a> if the parent <a href="#Rows">*Rows</a> is closed.
<p>If any of the first arguments implementing <a href="#Scanner">Scanner</a> returns an error,
that error will be wrapped in the returned error.

				
				
				
			
		
			
			
			<h2 id="Scanner">type <a href="/src/database/sql/sql.go?s=10953:11568#L429">Scanner</a>
				<a class="permalink" href="#Scanner">&#xb6;</a>
				
				
			</h2>
			<p>Scanner is an interface used by <a href="#Rows.Scan">Rows.Scan</a>.

			<pre>type Scanner interface {
    <span class="comment">// Scan assigns a value from a database driver.</span>
    <span class="comment">//</span>
    <span class="comment">// The src value will be of one of the following types:</span>
    <span class="comment">//</span>
    <span class="comment">//    int64</span>
    <span class="comment">//    float64</span>
    <span class="comment">//    bool</span>
    <span class="comment">//    []byte</span>
    <span class="comment">//    string</span>
    <span class="comment">//    time.Time</span>
    <span class="comment">//    nil - for NULL values</span>
    <span class="comment">//</span>
    <span class="comment">// An error should be returned if the value cannot be stored</span>
    <span class="comment">// without loss of information.</span>
    <span class="comment">//</span>
    <span class="comment">// Reference types such as []byte are only valid until the next call to Scan</span>
    <span class="comment">// and should not be retained. Their underlying memory is owned by the driver.</span>
    <span class="comment">// If retention is necessary, copy their values before the next call to Scan.</span>
    Scan(src <a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#error">error</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Stmt">type <a href="/src/database/sql/sql.go?s=73670:75088#L2585">Stmt</a>
				<a class="permalink" href="#Stmt">&#xb6;</a>
				
				
			</h2>
			<p>Stmt is a prepared statement.
A Stmt is safe for concurrent use by multiple goroutines.
<p>If a Stmt is prepared on a <a href="#Tx">Tx</a> or <a href="#Conn">Conn</a>, it will be bound to a single
underlying connection forever. If the <a href="#Tx">Tx</a> or <a href="#Conn">Conn</a> closes, the Stmt will
become unusable and all operations will return an error.
If a Stmt is prepared on a <a href="#DB">DB</a>, it will remain usable for the lifetime of the
<a href="#DB">DB</a>. When the Stmt needs to execute on a new underlying connection, it will
prepare itself on the new connection automatically.

			<pre>type Stmt struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Stmt" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// In normal use, create one Stmt when your process starts.</span>
stmt, err := db.PrepareContext(ctx, &#34;SELECT username FROM users WHERE id = ?&#34;)
if err != nil {
    log.Fatal(err)
}
defer stmt.Close()

<span class="comment">// Then reuse it each time you need to issue the query.</span>
id := 43
var username string
err = stmt.QueryRowContext(ctx, id).Scan(&amp;username)
switch {
case err == sql.ErrNoRows:
    log.Fatalf(&#34;no user with id %d&#34;, id)
case err != nil:
    log.Fatal(err)
default:
    log.Printf(&#34;username is %s\n&#34;, username)
}
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="Stmt.Close">func (*Stmt) <a href="/src/database/sql/sql.go?s=81873:81901#L2866">Close</a>
					<a class="permalink" href="#Stmt.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Stmt">Stmt</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Close closes the statement.

				
				
				
			
				
				<h3 id="Stmt.Exec">func (*Stmt) <a href="/src/database/sql/sql.go?s=75867:75915#L2649">Exec</a>
					<a class="permalink" href="#Stmt.Exec">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Stmt">Stmt</a>) Exec(args ...<a href="/pkg/builtin/#any">any</a>) (<a href="#Result">Result</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Exec executes a prepared statement with the given arguments and
returns a <a href="#Result">Result</a> summarizing the effect of the statement.
<p>Exec uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Stmt.ExecContext">Stmt.ExecContext</a>.

				
				
				
			
				
				<h3 id="Stmt.ExecContext">func (*Stmt) <a href="/src/database/sql/sql.go?s=75227:75303#L2625">ExecContext</a>
					<a class="permalink" href="#Stmt.ExecContext">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (s *<a href="#Stmt">Stmt</a>) ExecContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, args ...<a href="/pkg/builtin/#any">any</a>) (<a href="#Result">Result</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ExecContext executes a prepared statement with the given arguments and
returns a <a href="#Result">Result</a> summarizing the effect of the statement.

				
				
				
			
				
				<h3 id="Stmt.Query">func (*Stmt) <a href="/src/database/sql/sql.go?s=80169:80217#L2819">Query</a>
					<a class="permalink" href="#Stmt.Query">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Stmt">Stmt</a>) Query(args ...<a href="/pkg/builtin/#any">any</a>) (*<a href="#Rows">Rows</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Query executes a prepared query statement with the given arguments
and returns the query results as a *Rows.
<p>Query uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Stmt.QueryContext">Stmt.QueryContext</a>.

				
				
				
			
				
				<h3 id="Stmt.QueryContext">func (*Stmt) <a href="/src/database/sql/sql.go?s=78846:78922#L2767">QueryContext</a>
					<a class="permalink" href="#Stmt.QueryContext">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (s *<a href="#Stmt">Stmt</a>) QueryContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, args ...<a href="/pkg/builtin/#any">any</a>) (*<a href="#Rows">Rows</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>QueryContext executes a prepared query statement with the given arguments
and returns the query results as a <a href="#Rows">*Rows</a>.

				
				
				
			
				
				<h3 id="Stmt.QueryRow">func (*Stmt) <a href="/src/database/sql/sql.go?s=81738:81779#L2861">QueryRow</a>
					<a class="permalink" href="#Stmt.QueryRow">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Stmt">Stmt</a>) QueryRow(args ...<a href="/pkg/builtin/#any">any</a>) *<a href="#Row">Row</a></pre>
				<p>QueryRow executes a prepared query statement with the given arguments.
If an error occurs during the execution of the statement, that error will
be returned by a call to Scan on the returned <a href="#Row">*Row</a>, which is always non-nil.
If the query selects no rows, the <a href="#Row.Scan">*Row.Scan</a> will return <a href="#ErrNoRows">ErrNoRows</a>.
Otherwise, the <a href="#Row.Scan">*Row.Scan</a> scans the first selected row and discards
the rest.
<p>Example usage:
<pre>var name string
err := nameByUseridStmt.QueryRow(id).Scan(&amp;name)
</pre>
<p>QueryRow uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Stmt.QueryRowContext">Stmt.QueryRowContext</a>.

				
				
				
			
				
				<h3 id="Stmt.QueryRowContext">func (*Stmt) <a href="/src/database/sql/sql.go?s=80956:81025#L2839">QueryRowContext</a>
					<a class="permalink" href="#Stmt.QueryRowContext">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (s *<a href="#Stmt">Stmt</a>) QueryRowContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, args ...<a href="/pkg/builtin/#any">any</a>) *<a href="#Row">Row</a></pre>
				<p>QueryRowContext executes a prepared query statement with the given arguments.
If an error occurs during the execution of the statement, that error will
be returned by a call to Scan on the returned <a href="#Row">*Row</a>, which is always non-nil.
If the query selects no rows, the <a href="#Row.Scan">*Row.Scan</a> will return <a href="#ErrNoRows">ErrNoRows</a>.
Otherwise, the <a href="#Row.Scan">*Row.Scan</a> scans the first selected row and discards
the rest.

				
				<div id="example_Stmt_QueryRowContext" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// In normal use, create one Stmt when your process starts.</span>
stmt, err := db.PrepareContext(ctx, &#34;SELECT username FROM users WHERE id = ?&#34;)
if err != nil {
    log.Fatal(err)
}
defer stmt.Close()

<span class="comment">// Then reuse it each time you need to issue the query.</span>
id := 43
var username string
err = stmt.QueryRowContext(ctx, id).Scan(&amp;username)
switch {
case err == sql.ErrNoRows:
    log.Fatalf(&#34;no user with id %d&#34;, id)
case err != nil:
    log.Fatal(err)
default:
    log.Printf(&#34;username is %s\n&#34;, username)
}
</pre>
			
		
	</div>
</div>

				
			
		
			
			
			<h2 id="Tx">type <a href="/src/database/sql/sql.go?s=60731:61823#L2148">Tx</a>
				<a class="permalink" href="#Tx">&#xb6;</a>
				
				
			</h2>
			<p>Tx is an in-progress database transaction.
<p>A transaction must end with a call to <a href="#Tx.Commit">Tx.Commit</a> or <a href="#Tx.Rollback">Tx.Rollback</a>.
<p>After a call to <a href="#Tx.Commit">Tx.Commit</a> or <a href="#Tx.Rollback">Tx.Rollback</a>, all operations on the
transaction fail with <a href="#ErrTxDone">ErrTxDone</a>.
<p>The statements prepared for a transaction by calling
the transaction&apos;s <a href="#Tx.Prepare">Tx.Prepare</a> or <a href="#Tx.Stmt">Tx.Stmt</a> methods are closed
by the call to <a href="#Tx.Commit">Tx.Commit</a> or <a href="#Tx.Rollback">Tx.Rollback</a>.

			<pre>type Tx struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Tx.Commit">func (*Tx) <a href="/src/database/sql/sql.go?s=64208:64236#L2269">Commit</a>
					<a class="permalink" href="#Tx.Commit">&#xb6;</a>
					
					
				</h3>
				<pre>func (tx *<a href="#Tx">Tx</a>) Commit() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Commit commits the transaction.

				
				
				
			
				
				<h3 id="Tx.Exec">func (*Tx) <a href="/src/database/sql/sql.go?s=70618:70679#L2506">Exec</a>
					<a class="permalink" href="#Tx.Exec">&#xb6;</a>
					
					
				</h3>
				<pre>func (tx *<a href="#Tx">Tx</a>) Exec(query <a href="/pkg/builtin/#string">string</a>, args ...<a href="/pkg/builtin/#any">any</a>) (<a href="#Result">Result</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Exec executes a query that doesn&apos;t return rows.
For example: an INSERT and UPDATE.
<p>Exec uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Tx.ExecContext">Tx.ExecContext</a>.

				
				
				
			
				
				<h3 id="Tx.ExecContext">func (*Tx) <a href="/src/database/sql/sql.go?s=70208:70297#L2493">ExecContext</a>
					<a class="permalink" href="#Tx.ExecContext">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (tx *<a href="#Tx">Tx</a>) ExecContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, query <a href="/pkg/builtin/#string">string</a>, args ...<a href="/pkg/builtin/#any">any</a>) (<a href="#Result">Result</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ExecContext executes a query that doesn&apos;t return rows.
For example: an INSERT and UPDATE.

				
				<div id="example_Tx_ExecContext" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
tx, err := db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelSerializable})
if err != nil {
    log.Fatal(err)
}
id := 37
_, execErr := tx.ExecContext(ctx, &#34;UPDATE users SET status = ? WHERE id = ?&#34;, &#34;paid&#34;, id)
if execErr != nil {
    if rollbackErr := tx.Rollback(); rollbackErr != nil {
        log.Fatalf(&#34;update failed: %v, unable to rollback: %v\n&#34;, execErr, rollbackErr)
    }
    log.Fatalf(&#34;update failed: %v&#34;, execErr)
}
if err := tx.Commit(); err != nil {
    log.Fatal(err)
}
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Tx.Prepare">func (*Tx) <a href="/src/database/sql/sql.go?s=67176:67226#L2379">Prepare</a>
					<a class="permalink" href="#Tx.Prepare">&#xb6;</a>
					
					
				</h3>
				<pre>func (tx *<a href="#Tx">Tx</a>) Prepare(query <a href="/pkg/builtin/#string">string</a>) (*<a href="#Stmt">Stmt</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Prepare creates a prepared statement for use within a transaction.
<p>The returned statement operates within the transaction and will be closed
when the transaction has been committed or rolled back.
<p>To use an existing prepared statement on this transaction, see <a href="#Tx.Stmt">Tx.Stmt</a>.
<p>Prepare uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Tx.PrepareContext">Tx.PrepareContext</a>.

				
				<div id="example_Tx_Prepare" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
projects := []struct {
    mascot  string
    release int
}{
    {&#34;tux&#34;, 1991},
    {&#34;duke&#34;, 1996},
    {&#34;gopher&#34;, 2009},
    {&#34;moby dock&#34;, 2013},
}

tx, err := db.Begin()
if err != nil {
    log.Fatal(err)
}
defer tx.Rollback() <span class="comment">// The rollback will be ignored if the tx has been committed later in the function.</span>

stmt, err := tx.Prepare(&#34;INSERT INTO projects(id, mascot, release, category) VALUES( ?, ?, ?, ? )&#34;)
if err != nil {
    log.Fatal(err)
}
defer stmt.Close() <span class="comment">// Prepared statements take up server resources and should be closed after use.</span>

for id, project := range projects {
    if _, err := stmt.Exec(id+1, project.mascot, project.release, &#34;open source&#34;); err != nil {
        log.Fatal(err)
    }
}
if err := tx.Commit(); err != nil {
    log.Fatal(err)
}
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Tx.PrepareContext">func (*Tx) <a href="/src/database/sql/sql.go?s=66432:66510#L2354">PrepareContext</a>
					<a class="permalink" href="#Tx.PrepareContext">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (tx *<a href="#Tx">Tx</a>) PrepareContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, query <a href="/pkg/builtin/#string">string</a>) (*<a href="#Stmt">Stmt</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>PrepareContext creates a prepared statement for use within a transaction.
<p>The returned statement operates within the transaction and will be closed
when the transaction has been committed or rolled back.
<p>To use an existing prepared statement on this transaction, see <a href="#Tx.Stmt">Tx.Stmt</a>.
<p>The provided context will be used for the preparation of the context, not
for the execution of the returned statement. The returned statement
will run in the transaction context.

				
				
				
			
				
				<h3 id="Tx.Query">func (*Tx) <a href="/src/database/sql/sql.go?s=71216:71277#L2524">Query</a>
					<a class="permalink" href="#Tx.Query">&#xb6;</a>
					
					
				</h3>
				<pre>func (tx *<a href="#Tx">Tx</a>) Query(query <a href="/pkg/builtin/#string">string</a>, args ...<a href="/pkg/builtin/#any">any</a>) (*<a href="#Rows">Rows</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Query executes a query that returns rows, typically a SELECT.
<p>Query uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Tx.QueryContext">Tx.QueryContext</a>.

				
				
				
			
				
				<h3 id="Tx.QueryContext">func (*Tx) <a href="/src/database/sql/sql.go?s=70818:70907#L2511">QueryContext</a>
					<a class="permalink" href="#Tx.QueryContext">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (tx *<a href="#Tx">Tx</a>) QueryContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, query <a href="/pkg/builtin/#string">string</a>, args ...<a href="/pkg/builtin/#any">any</a>) (*<a href="#Rows">Rows</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>QueryContext executes a query that returns rows, typically a SELECT.

				
				
				
			
				
				<h3 id="Tx.QueryRow">func (*Tx) <a href="/src/database/sql/sql.go?s=72311:72365#L2548">QueryRow</a>
					<a class="permalink" href="#Tx.QueryRow">&#xb6;</a>
					
					
				</h3>
				<pre>func (tx *<a href="#Tx">Tx</a>) QueryRow(query <a href="/pkg/builtin/#string">string</a>, args ...<a href="/pkg/builtin/#any">any</a>) *<a href="#Row">Row</a></pre>
				<p>QueryRow executes a query that is expected to return at most one row.
QueryRow always returns a non-nil value. Errors are deferred until
<a href="#Row">Row</a>&apos;s Scan method is called.
If the query selects no rows, the <a href="#Row.Scan">*Row.Scan</a> will return <a href="#ErrNoRows">ErrNoRows</a>.
Otherwise, the <a href="#Row.Scan">*Row.Scan</a> scans the first selected row and discards
the rest.
<p>QueryRow uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Tx.QueryRowContext">Tx.QueryRowContext</a>.

				
				
				
			
				
				<h3 id="Tx.QueryRowContext">func (*Tx) <a href="/src/database/sql/sql.go?s=71695:71777#L2534">QueryRowContext</a>
					<a class="permalink" href="#Tx.QueryRowContext">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (tx *<a href="#Tx">Tx</a>) QueryRowContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, query <a href="/pkg/builtin/#string">string</a>, args ...<a href="/pkg/builtin/#any">any</a>) *<a href="#Row">Row</a></pre>
				<p>QueryRowContext executes a query that is expected to return at most one row.
QueryRowContext always returns a non-nil value. Errors are deferred until
<a href="#Row">Row</a>&apos;s Scan method is called.
If the query selects no rows, the <a href="#Row.Scan">*Row.Scan</a> will return <a href="#ErrNoRows">ErrNoRows</a>.
Otherwise, the <a href="#Row.Scan">*Row.Scan</a> scans the first selected row and discards
the rest.

				
				
				
			
				
				<h3 id="Tx.Rollback">func (*Tx) <a href="/src/database/sql/sql.go?s=65882:65912#L2340">Rollback</a>
					<a class="permalink" href="#Tx.Rollback">&#xb6;</a>
					
					
				</h3>
				<pre>func (tx *<a href="#Tx">Tx</a>) Rollback() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Rollback aborts the transaction.

				
				<div id="example_Tx_Rollback" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
tx, err := db.BeginTx(ctx, &amp;sql.TxOptions{Isolation: sql.LevelSerializable})
if err != nil {
    log.Fatal(err)
}
id := 53
_, err = tx.ExecContext(ctx, &#34;UPDATE drivers SET status = ? WHERE id = ?;&#34;, &#34;assigned&#34;, id)
if err != nil {
    if rollbackErr := tx.Rollback(); rollbackErr != nil {
        log.Fatalf(&#34;update drivers: unable to rollback: %v&#34;, rollbackErr)
    }
    log.Fatal(err)
}
_, err = tx.ExecContext(ctx, &#34;UPDATE pickups SET driver_id = $1;&#34;, id)
if err != nil {
    if rollbackErr := tx.Rollback(); rollbackErr != nil {
        log.Fatalf(&#34;update failed: %v, unable to back: %v&#34;, err, rollbackErr)
    }
    log.Fatal(err)
}
if err := tx.Commit(); err != nil {
    log.Fatal(err)
}
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Tx.Stmt">func (*Tx) <a href="/src/database/sql/sql.go?s=70019:70055#L2487">Stmt</a>
					<a class="permalink" href="#Tx.Stmt">&#xb6;</a>
					
					
				</h3>
				<pre>func (tx *<a href="#Tx">Tx</a>) Stmt(stmt *<a href="#Stmt">Stmt</a>) *<a href="#Stmt">Stmt</a></pre>
				<p>Stmt returns a transaction-specific prepared statement from
an existing statement.
<p>Example:
<pre>updateMoney, err := db.Prepare(&quot;UPDATE balance SET money=money+? WHERE id=?&quot;)
...
tx, err := db.Begin()
...
res, err := tx.Stmt(updateMoney).Exec(123.45, 98293203)
</pre>
<p>The returned statement operates within the transaction and will be closed
when the transaction has been committed or rolled back.
<p>Stmt uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Tx.StmtContext">Tx.StmtContext</a>.

				
				
				
			
				
				<h3 id="Tx.StmtContext">func (*Tx) <a href="/src/database/sql/sql.go?s=67847:67911#L2399">StmtContext</a>
					<a class="permalink" href="#Tx.StmtContext">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (tx *<a href="#Tx">Tx</a>) StmtContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, stmt *<a href="#Stmt">Stmt</a>) *<a href="#Stmt">Stmt</a></pre>
				<p>StmtContext returns a transaction-specific prepared statement from
an existing statement.
<p>Example:
<pre>updateMoney, err := db.Prepare(&quot;UPDATE balance SET money=money+? WHERE id=?&quot;)
...
tx, err := db.Begin()
...
res, err := tx.StmtContext(ctx, updateMoney).Exec(123.45, 98293203)
</pre>
<p>The provided context is used for the preparation of the statement, not for the
execution of the statement.
<p>The returned statement operates within the transaction and will be closed
when the transaction has been committed or rolled back.

				
				
				
			
		
			
			
			<h2 id="TxOptions">type <a href="/src/database/sql/sql.go?s=4566:4744#L164">TxOptions</a>
				<a class="permalink" href="#TxOptions">&#xb6;</a>
				
				<span title="Added in Go 1.8">1.8</span>
			</h2>
			<p>TxOptions holds the transaction options to be used in <a href="#DB.BeginTx">DB.BeginTx</a>.

			<pre>type TxOptions struct {
<span id="TxOptions.Isolation"></span>    <span class="comment">// Isolation is the transaction isolation level.</span>
    <span class="comment">// If zero, the driver or database&#39;s default level is used.</span>
    Isolation <a href="#IsolationLevel">IsolationLevel</a>
<span id="TxOptions.ReadOnly"></span>    ReadOnly  <a href="/pkg/builtin/#bool">bool</a>
}
</pre>

			

			

			
			
			

			

			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="..">..</a></td>
			</tr>
			

			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="driver/">driver</a>
					</td>
				
					<td class="pkg-synopsis">
						Package driver defines interfaces to be implemented by database drivers as used by package sql.
					</td>
				</tr>
			
		</table>
	</div>



<div id="footer">
Build version go1.23.0.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
