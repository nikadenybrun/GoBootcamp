<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>binary - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.23.0";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package binary
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "encoding/binary"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package binary implements simple translation between numbers and byte
sequences and encoding and decoding of varints.
<p>Numbers are translated by reading and writing fixed-size values.
A fixed-size value is either a fixed-size arithmetic
type (bool, int8, uint8, int16, float32, complex64, ...)
or an array or struct containing only fixed-size values.
<p>The varint functions encode and decode single integer values using
a variable-length encoding; smaller values require fewer bytes.
For a specification, see
<a href="https://developers.google.com/protocol-buffers/docs/encoding">https://developers.google.com/protocol-buffers/docs/encoding</a>.
<p>This package favors simplicity over efficiency. Clients that require
high-performance serialization, especially for large data structures,
should look at more advanced solutions such as the <a href="/encoding/gob">encoding/gob</a>
package or <a href="/google.golang.org/protobuf">google.golang.org/protobuf</a> for protocol buffers.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#Append">func Append(buf []byte, order ByteOrder, data any) ([]byte, error)</a></dd>
			
				
				<dd><a href="#AppendUvarint">func AppendUvarint(buf []byte, x uint64) []byte</a></dd>
			
				
				<dd><a href="#AppendVarint">func AppendVarint(buf []byte, x int64) []byte</a></dd>
			
				
				<dd><a href="#Decode">func Decode(buf []byte, order ByteOrder, data any) (int, error)</a></dd>
			
				
				<dd><a href="#Encode">func Encode(buf []byte, order ByteOrder, data any) (int, error)</a></dd>
			
				
				<dd><a href="#PutUvarint">func PutUvarint(buf []byte, x uint64) int</a></dd>
			
				
				<dd><a href="#PutVarint">func PutVarint(buf []byte, x int64) int</a></dd>
			
				
				<dd><a href="#Read">func Read(r io.Reader, order ByteOrder, data any) error</a></dd>
			
				
				<dd><a href="#ReadUvarint">func ReadUvarint(r io.ByteReader) (uint64, error)</a></dd>
			
				
				<dd><a href="#ReadVarint">func ReadVarint(r io.ByteReader) (int64, error)</a></dd>
			
				
				<dd><a href="#Size">func Size(v any) int</a></dd>
			
				
				<dd><a href="#Uvarint">func Uvarint(buf []byte) (uint64, int)</a></dd>
			
				
				<dd><a href="#Varint">func Varint(buf []byte) (int64, int)</a></dd>
			
				
				<dd><a href="#Write">func Write(w io.Writer, order ByteOrder, data any) error</a></dd>
			
			
				
				<dd><a href="#AppendByteOrder">type AppendByteOrder</a></dd>
				
				
			
				
				<dd><a href="#ByteOrder">type ByteOrder</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="#example_ByteOrder_get">ByteOrder (Get)</a></dd>
			
			<dd><a class="exampleLink" href="#example_ByteOrder_put">ByteOrder (Put)</a></dd>
			
			<dd><a class="exampleLink" href="#example_PutUvarint">PutUvarint</a></dd>
			
			<dd><a class="exampleLink" href="#example_PutVarint">PutVarint</a></dd>
			
			<dd><a class="exampleLink" href="#example_Read">Read</a></dd>
			
			<dd><a class="exampleLink" href="#example_Read_multi">Read (Multi)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Uvarint">Uvarint</a></dd>
			
			<dd><a class="exampleLink" href="#example_Varint">Varint</a></dd>
			
			<dd><a class="exampleLink" href="#example_Write">Write</a></dd>
			
			<dd><a class="exampleLink" href="#example_Write_multi">Write (Multi)</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/encoding/binary/binary.go">binary.go</a>
			
				<a href="/src/encoding/binary/native_endian_little.go">native_endian_little.go</a>
			
				<a href="/src/encoding/binary/varint.go">varint.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				<p>MaxVarintLenN is the maximum length of a varint-encoded N-bit integer.

				<pre>const (
    <span id="MaxVarintLen16">MaxVarintLen16</span> = 3
    <span id="MaxVarintLen32">MaxVarintLen32</span> = 5
    <span id="MaxVarintLen64">MaxVarintLen64</span> = 10
)</pre>
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>BigEndian is the big-endian implementation of <a href="#ByteOrder">ByteOrder</a> and <a href="#AppendByteOrder">AppendByteOrder</a>.

				<pre>var <span id="BigEndian">BigEndian</span> bigEndian</pre>
			
				<p>LittleEndian is the little-endian implementation of <a href="#ByteOrder">ByteOrder</a> and <a href="#AppendByteOrder">AppendByteOrder</a>.

				<pre>var <span id="LittleEndian">LittleEndian</span> littleEndian</pre>
			
				<p>NativeEndian is the native-endian implementation of <a href="#ByteOrder">ByteOrder</a> and <a href="#AppendByteOrder">AppendByteOrder</a>.

				<pre>var <span id="NativeEndian">NativeEndian</span> nativeEndian</pre>
			
		
		
			
			
			<h2 id="Append">func <a href="/src/encoding/binary/binary.go?s=12037:12103#L442">Append</a>
				<a class="permalink" href="#Append">&#xb6;</a>
				
				<span title="Added in Go 1.23">1.23</span>
			</h2>
			<pre>func Append(buf []<a href="/pkg/builtin/#byte">byte</a>, order <a href="#ByteOrder">ByteOrder</a>, data <a href="/pkg/builtin/#any">any</a>) ([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>Append appends the binary representation of data to buf.
buf may be nil, in which case a new buffer will be allocated.
See <a href="#Write">Write</a> on which data are acceptable.
It returns the (possibily extended) buffer containing data or an error.

			
			

		
			
			
			<h2 id="AppendUvarint">func <a href="/src/encoding/binary/varint.go?s=1604:1651#L31">AppendUvarint</a>
				<a class="permalink" href="#AppendUvarint">&#xb6;</a>
				
				<span title="Added in Go 1.19">1.19</span>
			</h2>
			<pre>func AppendUvarint(buf []<a href="/pkg/builtin/#byte">byte</a>, x <a href="/pkg/builtin/#uint64">uint64</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>AppendUvarint appends the varint-encoded form of x,
as generated by <a href="#PutUvarint">PutUvarint</a>, to buf and returns the extended buffer.

			
			

		
			
			
			<h2 id="AppendVarint">func <a href="/src/encoding/binary/varint.go?s=2903:2948#L81">AppendVarint</a>
				<a class="permalink" href="#AppendVarint">&#xb6;</a>
				
				<span title="Added in Go 1.19">1.19</span>
			</h2>
			<pre>func AppendVarint(buf []<a href="/pkg/builtin/#byte">byte</a>, x <a href="/pkg/builtin/#int64">int64</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>AppendVarint appends the varint-encoded form of x,
as generated by <a href="#PutVarint">PutVarint</a>, to buf and returns the extended buffer.

			
			

		
			
			
			<h2 id="Decode">func <a href="/src/encoding/binary/binary.go?s=7722:7785#L269">Decode</a>
				<a class="permalink" href="#Decode">&#xb6;</a>
				
				<span title="Added in Go 1.23">1.23</span>
			</h2>
			<pre>func Decode(buf []<a href="/pkg/builtin/#byte">byte</a>, order <a href="#ByteOrder">ByteOrder</a>, data <a href="/pkg/builtin/#any">any</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>Decode decodes binary data from buf into data according to
the given byte order.
It returns an error if buf is too small, otherwise the number of
bytes consumed from buf.

			
			

		
			
			
			<h2 id="Encode">func <a href="/src/encoding/binary/binary.go?s=11170:11233#L412">Encode</a>
				<a class="permalink" href="#Encode">&#xb6;</a>
				
				<span title="Added in Go 1.23">1.23</span>
			</h2>
			<pre>func Encode(buf []<a href="/pkg/builtin/#byte">byte</a>, order <a href="#ByteOrder">ByteOrder</a>, data <a href="/pkg/builtin/#any">any</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>Encode encodes the binary representation of data into buf according to
the given byte order.
It returns an error if buf is too small, otherwise the number of
bytes written into buf.

			
			

		
			
			
			<h2 id="PutUvarint">func <a href="/src/encoding/binary/varint.go?s=1885:1926#L41">PutUvarint</a>
				<a class="permalink" href="#PutUvarint">&#xb6;</a>
				
				
			</h2>
			<pre>func PutUvarint(buf []<a href="/pkg/builtin/#byte">byte</a>, x <a href="/pkg/builtin/#uint64">uint64</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>PutUvarint encodes a uint64 into buf and returns the number of bytes written.
If the buffer is too small, PutUvarint will panic.

			<div id="example_PutUvarint" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">buf := make([]byte, binary.MaxVarintLen64)

for _, x := range []uint64{1, 2, 127, 128, 255, 256} {
    n := binary.PutUvarint(buf, x)
    fmt.Printf(&#34;%x\n&#34;, buf[:n])
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">01
02
7f
8001
ff01
8002
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="PutVarint">func <a href="/src/encoding/binary/varint.go?s=3166:3205#L91">PutVarint</a>
				<a class="permalink" href="#PutVarint">&#xb6;</a>
				
				
			</h2>
			<pre>func PutVarint(buf []<a href="/pkg/builtin/#byte">byte</a>, x <a href="/pkg/builtin/#int64">int64</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>PutVarint encodes an int64 into buf and returns the number of bytes written.
If the buffer is too small, PutVarint will panic.

			<div id="example_PutVarint" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">buf := make([]byte, binary.MaxVarintLen64)

for _, x := range []int64{-65, -64, -2, -1, 0, 1, 2, 63, 64} {
    n := binary.PutVarint(buf, x)
    fmt.Printf(&#34;%x\n&#34;, buf[:n])
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">8101
7f
03
01
00
02
04
7e
8001
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Read">func <a href="/src/encoding/binary/binary.go?s=6800:6855#L230">Read</a>
				<a class="permalink" href="#Read">&#xb6;</a>
				
				
			</h2>
			<pre>func Read(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>, order <a href="#ByteOrder">ByteOrder</a>, data <a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#error">error</a></pre>
			<p>Read reads structured binary data from r into data.
Data must be a pointer to a fixed-size value or a slice
of fixed-size values.
Bytes read from r are decoded using the specified byte order
and written to successive fields of the data.
When decoding boolean values, a zero byte is decoded as false, and
any other non-zero byte is decoded as true.
When reading into structs, the field data for fields with
blank (_) field names is skipped; i.e., blank field names
may be used for padding.
When reading into a struct, all non-blank fields must be exported
or Read may panic.
<p>The error is <a href="/io#EOF">io.EOF</a> only if no bytes were read.
If an <a href="/io#EOF">io.EOF</a> happens after reading some but not all the bytes,
Read returns <a href="/io#ErrUnexpectedEOF">io.ErrUnexpectedEOF</a>.

			<div id="example_Read" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">var pi float64
b := []byte{0x18, 0x2d, 0x44, 0x54, 0xfb, 0x21, 0x09, 0x40}
buf := bytes.NewReader(b)
err := binary.Read(buf, binary.LittleEndian, &amp;pi)
if err != nil {
    fmt.Println(&#34;binary.Read failed:&#34;, err)
}
fmt.Print(pi)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">3.141592653589793
</pre>
			
		
	</div>
</div>
<div id="example_Read_multi" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Multi)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Multi)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">b := []byte{0x18, 0x2d, 0x44, 0x54, 0xfb, 0x21, 0x09, 0x40, 0xff, 0x01, 0x02, 0x03, 0xbe, 0xef}
r := bytes.NewReader(b)

var data struct {
    PI   float64
    Uate uint8
    Mine [3]byte
    Too  uint16
}

if err := binary.Read(r, binary.LittleEndian, &amp;data); err != nil {
    fmt.Println(&#34;binary.Read failed:&#34;, err)
}

fmt.Println(data.PI)
fmt.Println(data.Uate)
fmt.Printf(&#34;% x\n&#34;, data.Mine)
fmt.Println(data.Too)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">3.141592653589793
255
01 02 03
61374
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ReadUvarint">func <a href="/src/encoding/binary/varint.go?s=4103:4152#L120">ReadUvarint</a>
				<a class="permalink" href="#ReadUvarint">&#xb6;</a>
				
				
			</h2>
			<pre>func ReadUvarint(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#ByteReader">ByteReader</a>) (<a href="/pkg/builtin/#uint64">uint64</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.
The error is <a href="/io#EOF">io.EOF</a> only if no bytes were read.
If an <a href="/io#EOF">io.EOF</a> happens after reading some but not all the bytes,
ReadUvarint returns <a href="/io#ErrUnexpectedEOF">io.ErrUnexpectedEOF</a>.

			
			

		
			
			
			<h2 id="ReadVarint">func <a href="/src/encoding/binary/varint.go?s=4784:4831#L147">ReadVarint</a>
				<a class="permalink" href="#ReadVarint">&#xb6;</a>
				
				
			</h2>
			<pre>func ReadVarint(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#ByteReader">ByteReader</a>) (<a href="/pkg/builtin/#int64">int64</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>ReadVarint reads an encoded signed integer from r and returns it as an int64.
The error is <a href="/io#EOF">io.EOF</a> only if no bytes were read.
If an <a href="/io#EOF">io.EOF</a> happens after reading some but not all the bytes,
ReadVarint returns <a href="/io#ErrUnexpectedEOF">io.ErrUnexpectedEOF</a>.

			
			

		
			
			
			<h2 id="Size">func <a href="/src/encoding/binary/binary.go?s=14774:14794#L569">Size</a>
				<a class="permalink" href="#Size">&#xb6;</a>
				
				
			</h2>
			<pre>func Size(v <a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>Size returns how many bytes <a href="#Write">Write</a> would generate to encode the value v, which
must be a fixed-size value or a slice of fixed-size values, or a pointer to such data.
If v is neither of these, Size returns -1.

			
			

		
			
			
			<h2 id="Uvarint">func <a href="/src/encoding/binary/varint.go?s=2340:2378#L58">Uvarint</a>
				<a class="permalink" href="#Uvarint">&#xb6;</a>
				
				
			</h2>
			<pre>func Uvarint(buf []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#uint64">uint64</a>, <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>Uvarint decodes a uint64 from buf and returns that value and the
number of bytes read (&gt; 0). If an error occurred, the value is 0
and the number of bytes n is &lt;= 0 meaning:
<ul>
<li>n == 0: buf too small;
<li>n &lt; 0: value larger than 64 bits (overflow) and -n is the number of
bytes read.
</ul>

			<div id="example_Uvarint" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">inputs := [][]byte{
    {0x01},
    {0x02},
    {0x7f},
    {0x80, 0x01},
    {0xff, 0x01},
    {0x80, 0x02},
}
for _, b := range inputs {
    x, n := binary.Uvarint(b)
    if n != len(b) {
        fmt.Println(&#34;Uvarint did not consume all of in&#34;)
    }
    fmt.Println(x)
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">1
2
127
128
255
256
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Varint">func <a href="/src/encoding/binary/varint.go?s=3611:3647#L105">Varint</a>
				<a class="permalink" href="#Varint">&#xb6;</a>
				
				
			</h2>
			<pre>func Varint(buf []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int64">int64</a>, <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>Varint decodes an int64 from buf and returns that value and the
number of bytes read (&gt; 0). If an error occurred, the value is 0
and the number of bytes n is &lt;= 0 with the following meaning:
<ul>
<li>n == 0: buf too small;
<li>n &lt; 0: value larger than 64 bits (overflow)
and -n is the number of bytes read.
</ul>

			<div id="example_Varint" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">inputs := [][]byte{
    {0x81, 0x01},
    {0x7f},
    {0x03},
    {0x01},
    {0x00},
    {0x02},
    {0x04},
    {0x7e},
    {0x80, 0x01},
}
for _, b := range inputs {
    x, n := binary.Varint(b)
    if n != len(b) {
        fmt.Println(&#34;Varint did not consume all of in&#34;)
    }
    fmt.Println(x)
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">-65
-64
-2
-1
0
1
2
63
64
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Write">func <a href="/src/encoding/binary/binary.go?s=10363:10419#L382">Write</a>
				<a class="permalink" href="#Write">&#xb6;</a>
				
				
			</h2>
			<pre>func Write(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>, order <a href="#ByteOrder">ByteOrder</a>, data <a href="/pkg/builtin/#any">any</a>) <a href="/pkg/builtin/#error">error</a></pre>
			<p>Write writes the binary representation of data into w.
Data must be a fixed-size value or a slice of fixed-size
values, or a pointer to such data.
Boolean values encode as one byte: 1 for true, and 0 for false.
Bytes written to w are encoded using the specified byte order
and read from successive fields of the data.
When writing structs, zero values are written for fields
with blank (_) field names.

			<div id="example_Write" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">buf := new(bytes.Buffer)
var pi float64 = math.Pi
err := binary.Write(buf, binary.LittleEndian, pi)
if err != nil {
    fmt.Println(&#34;binary.Write failed:&#34;, err)
}
fmt.Printf(&#34;% x&#34;, buf.Bytes())
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">18 2d 44 54 fb 21 09 40
</pre>
			
		
	</div>
</div>
<div id="example_Write_multi" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Multi)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Multi)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">buf := new(bytes.Buffer)
var data = []any{
    uint16(61374),
    int8(-54),
    uint8(254),
}
for _, v := range data {
    err := binary.Write(buf, binary.LittleEndian, v)
    if err != nil {
        fmt.Println(&#34;binary.Write failed:&#34;, err)
    }
}
fmt.Printf(&#34;%x&#34;, buf.Bytes())
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">beefcafe
</pre>
			
		
	</div>
</div>

			

		
		
			
			
			<h2 id="AppendByteOrder">type <a href="/src/encoding/binary/binary.go?s=1734:1896#L43">AppendByteOrder</a>
				<a class="permalink" href="#AppendByteOrder">&#xb6;</a>
				
				<span title="Added in Go 1.19">1.19</span>
			</h2>
			<p>AppendByteOrder specifies how to append 16-, 32-, or 64-bit unsigned integers
into a byte slice.
<p>It is implemented by <a href="#LittleEndian">LittleEndian</a>, <a href="#BigEndian">BigEndian</a>, and <a href="#NativeEndian">NativeEndian</a>.

			<pre>type AppendByteOrder interface {
    AppendUint16([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#uint16">uint16</a>) []<a href="/pkg/builtin/#byte">byte</a>
    AppendUint32([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#uint32">uint32</a>) []<a href="/pkg/builtin/#byte">byte</a>
    AppendUint64([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#uint64">uint64</a>) []<a href="/pkg/builtin/#byte">byte</a>
    String() <a href="/pkg/builtin/#string">string</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ByteOrder">type <a href="/src/encoding/binary/binary.go?s=1358:1553#L29">ByteOrder</a>
				<a class="permalink" href="#ByteOrder">&#xb6;</a>
				
				
			</h2>
			<p>A ByteOrder specifies how to convert byte slices into
16-, 32-, or 64-bit unsigned integers.
<p>It is implemented by <a href="#LittleEndian">LittleEndian</a>, <a href="#BigEndian">BigEndian</a>, and <a href="#NativeEndian">NativeEndian</a>.

			<pre>type ByteOrder interface {
    Uint16([]<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#uint16">uint16</a>
    Uint32([]<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#uint32">uint32</a>
    Uint64([]<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#uint64">uint64</a>
    PutUint16([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#uint16">uint16</a>)
    PutUint32([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#uint32">uint32</a>)
    PutUint64([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#uint64">uint64</a>)
    String() <a href="/pkg/builtin/#string">string</a>
}</pre>

			

			

			<div id="example_ByteOrder_get" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Get)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Get)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">b := []byte{0xe8, 0x03, 0xd0, 0x07}
x1 := binary.LittleEndian.Uint16(b[0:])
x2 := binary.LittleEndian.Uint16(b[2:])
fmt.Printf(&#34;%#04x %#04x\n&#34;, x1, x2)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">0x03e8 0x07d0
</pre>
			
		
	</div>
</div>
<div id="example_ByteOrder_put" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Put)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Put)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">b := make([]byte, 4)
binary.LittleEndian.PutUint16(b[0:], 0x03e8)
binary.LittleEndian.PutUint16(b[2:], 0x07d0)
fmt.Printf(&#34;% x\n&#34;, b)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">e8 03 d0 07
</pre>
			
		
	</div>
</div>

			
			

			

			
		
	

	







<div id="footer">
Build version go1.23.0.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
