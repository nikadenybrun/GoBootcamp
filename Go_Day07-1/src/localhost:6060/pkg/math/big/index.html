<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>big - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.23.0";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package big
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "math/big"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package big implements arbitrary-precision arithmetic (big numbers).
The following numeric types are supported:
<pre>Int    signed integers
Rat    rational numbers
Float  floating-point numbers
</pre>
<p>The zero value for an <a href="#Int">Int</a>, <a href="#Rat">Rat</a>, or <a href="#Float">Float</a> correspond to 0. Thus, new
values can be declared in the usual ways and denote 0 without further
initialization:
<pre>var x Int        // &amp;x is an *Int of value 0
var r = &amp;Rat{}   // r is a *Rat of value 0
y := new(Float)  // y is a *Float of value 0
</pre>
<p>Alternatively, new values can be allocated and initialized with factory
functions of the form:
<pre>func NewT(v V) *T
</pre>
<p>For instance, <a href="#NewInt">NewInt</a>(x) returns an *<a href="#Int">Int</a> set to the value of the int64
argument x, <a href="#NewRat">NewRat</a>(a, b) returns a *<a href="#Rat">Rat</a> set to the fraction a/b where
a and b are int64 values, and <a href="#NewFloat">NewFloat</a>(f) returns a *<a href="#Float">Float</a> initialized
to the float64 argument f. More flexibility is provided with explicit
setters, for instance:
<pre>var z1 Int
z1.SetUint64(123)                 // z1 := 123
z2 := new(Rat).SetFloat64(1.25)   // z2 := 5/4
z3 := new(Float).SetInt(z1)       // z3 := 123.0
</pre>
<p>Setters, numeric operations and predicates are represented as methods of
the form:
<pre>func (z *T) SetV(v V) *T          // z = v
func (z *T) Unary(x *T) *T        // z = unary x
func (z *T) Binary(x, y *T) *T    // z = x binary y
func (x *T) Pred() P              // p = pred(x)
</pre>
<p>with T one of <a href="#Int">Int</a>, <a href="#Rat">Rat</a>, or <a href="#Float">Float</a>. For unary and binary operations, the
result is the receiver (usually named z in that case; see below); if it
is one of the operands x or y it may be safely overwritten (and its memory
reused).
<p>Arithmetic expressions are typically written as a sequence of individual
method calls, with each call corresponding to an operation. The receiver
denotes the result and the method arguments are the operation&apos;s operands.
For instance, given three *Int values a, b and c, the invocation
<pre>c.Add(a, b)
</pre>
<p>computes the sum a + b and stores the result in c, overwriting whatever
value was held in c before. Unless specified otherwise, operations permit
aliasing of parameters, so it is perfectly ok to write
<pre>sum.Add(sum, x)
</pre>
<p>to accumulate values x in a sum.
<p>(By always passing in a result value via the receiver, memory use can be
much better controlled. Instead of having to allocate new memory for each
result, an operation can reuse the space allocated for the result value,
and overwrite that value with the new result in the process.)
<p>Notational convention: Incoming method parameters (including the receiver)
are named consistently in the API to clarify their use. Incoming operands
are usually named x, y, a, b, and so on, but never z. A parameter specifying
the result is named z (typically the receiver).
<p>For instance, the arguments for (*Int).Add are named x and y, and because
the receiver specifies the result destination, it is called z:
<pre>func (z *Int) Add(x, y *Int) *Int
</pre>
<p>Methods of this form typically return the incoming receiver as well, to
enable simple call chaining.
<p>Methods which don&apos;t require a result value to be passed in (for instance,
<a href="#Int.Sign">Int.Sign</a>), simply return the result. In this case, the receiver is typically
the first operand, named x:
<pre>func (x *Int) Sign() int
</pre>
<p>Various methods support conversions between strings and corresponding
numeric values, and vice versa: *<a href="#Int">Int</a>, *<a href="#Rat">Rat</a>, and *<a href="#Float">Float</a> values implement
the Stringer interface for a (default) string representation of the value,
but also provide SetString methods to initialize a value from a string in
a variety of supported formats (see the respective SetString documentation).
<p>Finally, *<a href="#Int">Int</a>, *<a href="#Rat">Rat</a>, and *<a href="#Float">Float</a> satisfy <a href="/fmt#Scanner">fmt.Scanner</a> for scanning
and (except for *<a href="#Rat">Rat</a>) the Formatter interface for formatted printing.

				<div id="example__eConvergents" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (EConvergents)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (EConvergents)</span></p>
		<p>This example demonstrates how to use big.Rat to compute the
first 15 terms in the sequence of rational convergents for
the constant e (base of natural logarithm).
</p>
		
		
			<p>Code:</p>
			<pre class="code">package big_test

import (
    &#34;fmt&#34;
    &#34;math/big&#34;
)

<span class="comment">// Use the classic continued fraction for e</span>
<span class="comment">//</span>
<span class="comment">//	e = [1; 0, 1, 1, 2, 1, 1, ... 2n, 1, 1, ...]</span>
<span class="comment">//</span>
<span class="comment">// i.e., for the nth term, use</span>
<span class="comment">//</span>
<span class="comment">//	   1          if   n mod 3 != 1</span>
<span class="comment">//	(n-1)/3 * 2   if   n mod 3 == 1</span>
func recur(n, lim int64) *big.Rat {
    term := new(big.Rat)
    if n%3 != 1 {
        term.SetInt64(1)
    } else {
        term.SetInt64((n - 1) / 3 * 2)
    }

    if n &gt; lim {
        return term
    }

    <span class="comment">// Directly initialize frac as the fractional</span>
    <span class="comment">// inverse of the result of recur.</span>
    frac := new(big.Rat).Inv(recur(n+1, lim))

    return term.Add(term, frac)
}

<span class="comment">// This example demonstrates how to use big.Rat to compute the</span>
<span class="comment">// first 15 terms in the sequence of rational convergents for</span>
<span class="comment">// the constant e (base of natural logarithm).</span>
func Example_eConvergents() {
    for i := 1; i &lt;= 15; i++ {
        r := recur(0, int64(i))

        <span class="comment">// Print r both as a fraction and as a floating-point number.</span>
        <span class="comment">// Since big.Rat implements fmt.Formatter, we can use %-13s to</span>
        <span class="comment">// get a left-aligned string representation of the fraction.</span>
        fmt.Printf(&#34;%-13s = %s\n&#34;, r, r.FloatString(8))
    }

    <span class="comment">// Output:</span>
    <span class="comment">// 2/1           = 2.00000000</span>
    <span class="comment">// 3/1           = 3.00000000</span>
    <span class="comment">// 8/3           = 2.66666667</span>
    <span class="comment">// 11/4          = 2.75000000</span>
    <span class="comment">// 19/7          = 2.71428571</span>
    <span class="comment">// 87/32         = 2.71875000</span>
    <span class="comment">// 106/39        = 2.71794872</span>
    <span class="comment">// 193/71        = 2.71830986</span>
    <span class="comment">// 1264/465      = 2.71827957</span>
    <span class="comment">// 1457/536      = 2.71828358</span>
    <span class="comment">// 2721/1001     = 2.71828172</span>
    <span class="comment">// 23225/8544    = 2.71828184</span>
    <span class="comment">// 25946/9545    = 2.71828182</span>
    <span class="comment">// 49171/18089   = 2.71828183</span>
    <span class="comment">// 517656/190435 = 2.71828183</span>
}
</pre>
			
		
	</div>
</div>
<div id="example__fibonacci" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Fibonacci)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Fibonacci)</span></p>
		<p>This example demonstrates how to use big.Int to compute the smallest
Fibonacci number with 100 decimal digits and to test whether it is prime.
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Initialize two big ints with the first two numbers in the sequence.</span>
a := big.NewInt(0)
b := big.NewInt(1)

<span class="comment">// Initialize limit as 10^99, the smallest integer with 100 digits.</span>
var limit big.Int
limit.Exp(big.NewInt(10), big.NewInt(99), nil)

<span class="comment">// Loop while a is smaller than 1e100.</span>
for a.Cmp(&amp;limit) &lt; 0 {
    <span class="comment">// Compute the next Fibonacci number, storing it in a.</span>
    a.Add(a, b)
    <span class="comment">// Swap a and b so that b is the next number in the sequence.</span>
    a, b = b, a
}
fmt.Println(a) <span class="comment">// 100-digit Fibonacci number</span>

<span class="comment">// Test a for primality.</span>
<span class="comment">// (ProbablyPrimes&#39; argument sets the number of Miller-Rabin</span>
<span class="comment">// rounds to be performed. 20 is a good value.)</span>
fmt.Println(a.ProbablyPrime(20))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">1344719667586153181419716641724567886890850696275767987106294472017884974410332069524504824747437757
false
</pre>
			
		
	</div>
</div>
<div id="example__sqrt2" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Sqrt2)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Sqrt2)</span></p>
		<p>This example shows how to use big.Float to compute the square root of 2 with
a precision of 200 bits, and how to print the result as a decimal number.
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// We&#39;ll do computations with 200 bits of precision in the mantissa.</span>
const prec = 200

<span class="comment">// Compute the square root of 2 using Newton&#39;s Method. We start with</span>
<span class="comment">// an initial estimate for sqrt(2), and then iterate:</span>
<span class="comment">//     x_{n+1} = 1/2 * ( x_n + (2.0 / x_n) )</span>

<span class="comment">// Since Newton&#39;s Method doubles the number of correct digits at each</span>
<span class="comment">// iteration, we need at least log_2(prec) steps.</span>
steps := int(math.Log2(prec))

<span class="comment">// Initialize values we need for the computation.</span>
two := new(big.Float).SetPrec(prec).SetInt64(2)
half := new(big.Float).SetPrec(prec).SetFloat64(0.5)

<span class="comment">// Use 1 as the initial estimate.</span>
x := new(big.Float).SetPrec(prec).SetInt64(1)

<span class="comment">// We use t as a temporary variable. There&#39;s no need to set its precision</span>
<span class="comment">// since big.Float values with unset (== 0) precision automatically assume</span>
<span class="comment">// the largest precision of the arguments when used as the result (receiver)</span>
<span class="comment">// of a big.Float operation.</span>
t := new(big.Float)

<span class="comment">// Iterate.</span>
for i := 0; i &lt;= steps; i++ {
    t.Quo(two, x)  <span class="comment">// t = 2.0 / x_n</span>
    t.Add(x, t)    <span class="comment">// t = x_n + (2.0 / x_n)</span>
    x.Mul(half, t) <span class="comment">// x_{n+1} = 0.5 * t</span>
}

<span class="comment">// We can use the usual fmt.Printf verbs since big.Float implements fmt.Formatter</span>
fmt.Printf(&#34;sqrt(2) = %.50f\n&#34;, x)

<span class="comment">// Print the error between 2 and x*x.</span>
t.Mul(x, x) <span class="comment">// t = x*x</span>
fmt.Printf(&#34;error = %e\n&#34;, t.Sub(two, t))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">sqrt(2) = 1.41421356237309504880168872420969807856967187537695
error = 0.000000e+00
</pre>
			
		
	</div>
</div>

			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
			
				
				<dd><a href="#Jacobi">func Jacobi(x, y *Int) int</a></dd>
			
			
				
				<dd><a href="#Accuracy">type Accuracy</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Accuracy.String">func (i Accuracy) String() string</a></dd>
				
			
				
				<dd><a href="#ErrNaN">type ErrNaN</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ErrNaN.Error">func (err ErrNaN) Error() string</a></dd>
				
			
				
				<dd><a href="#Float">type Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFloat">func NewFloat(x float64) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseFloat">func ParseFloat(s string, base int, prec uint, mode RoundingMode) (f *Float, b int, err error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Abs">func (z *Float) Abs(x *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Acc">func (x *Float) Acc() Accuracy</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Add">func (z *Float) Add(x, y *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Append">func (x *Float) Append(buf []byte, fmt byte, prec int) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Cmp">func (x *Float) Cmp(y *Float) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Copy">func (z *Float) Copy(x *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Float32">func (x *Float) Float32() (float32, Accuracy)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Float64">func (x *Float) Float64() (float64, Accuracy)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Format">func (x *Float) Format(s fmt.State, format rune)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.GobDecode">func (z *Float) GobDecode(buf []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.GobEncode">func (x *Float) GobEncode() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Int">func (x *Float) Int(z *Int) (*Int, Accuracy)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Int64">func (x *Float) Int64() (int64, Accuracy)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.IsInf">func (x *Float) IsInf() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.IsInt">func (x *Float) IsInt() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.MantExp">func (x *Float) MantExp(mant *Float) (exp int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.MarshalText">func (x *Float) MarshalText() (text []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.MinPrec">func (x *Float) MinPrec() uint</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Mode">func (x *Float) Mode() RoundingMode</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Mul">func (z *Float) Mul(x, y *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Neg">func (z *Float) Neg(x *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Parse">func (z *Float) Parse(s string, base int) (f *Float, b int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Prec">func (x *Float) Prec() uint</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Quo">func (z *Float) Quo(x, y *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Rat">func (x *Float) Rat(z *Rat) (*Rat, Accuracy)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Scan">func (z *Float) Scan(s fmt.ScanState, ch rune) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Set">func (z *Float) Set(x *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.SetFloat64">func (z *Float) SetFloat64(x float64) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.SetInf">func (z *Float) SetInf(signbit bool) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.SetInt">func (z *Float) SetInt(x *Int) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.SetInt64">func (z *Float) SetInt64(x int64) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.SetMantExp">func (z *Float) SetMantExp(mant *Float, exp int) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.SetMode">func (z *Float) SetMode(mode RoundingMode) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.SetPrec">func (z *Float) SetPrec(prec uint) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.SetRat">func (z *Float) SetRat(x *Rat) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.SetString">func (z *Float) SetString(s string) (*Float, bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.SetUint64">func (z *Float) SetUint64(x uint64) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Sign">func (x *Float) Sign() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Signbit">func (x *Float) Signbit() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Sqrt">func (z *Float) Sqrt(x *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.String">func (x *Float) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Sub">func (z *Float) Sub(x, y *Float) *Float</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Text">func (x *Float) Text(format byte, prec int) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.Uint64">func (x *Float) Uint64() (uint64, Accuracy)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Float.UnmarshalText">func (z *Float) UnmarshalText(text []byte) error</a></dd>
				
			
				
				<dd><a href="#Int">type Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewInt">func NewInt(x int64) *Int</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Abs">func (z *Int) Abs(x *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Add">func (z *Int) Add(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.And">func (z *Int) And(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.AndNot">func (z *Int) AndNot(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Append">func (x *Int) Append(buf []byte, base int) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Binomial">func (z *Int) Binomial(n, k int64) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Bit">func (x *Int) Bit(i int) uint</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.BitLen">func (x *Int) BitLen() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Bits">func (x *Int) Bits() []Word</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Bytes">func (x *Int) Bytes() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Cmp">func (x *Int) Cmp(y *Int) (r int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.CmpAbs">func (x *Int) CmpAbs(y *Int) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Div">func (z *Int) Div(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.DivMod">func (z *Int) DivMod(x, y, m *Int) (*Int, *Int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Exp">func (z *Int) Exp(x, y, m *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.FillBytes">func (x *Int) FillBytes(buf []byte) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Float64">func (x *Int) Float64() (float64, Accuracy)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Format">func (x *Int) Format(s fmt.State, ch rune)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.GCD">func (z *Int) GCD(x, y, a, b *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.GobDecode">func (z *Int) GobDecode(buf []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.GobEncode">func (x *Int) GobEncode() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Int64">func (x *Int) Int64() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.IsInt64">func (x *Int) IsInt64() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.IsUint64">func (x *Int) IsUint64() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Lsh">func (z *Int) Lsh(x *Int, n uint) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.MarshalJSON">func (x *Int) MarshalJSON() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.MarshalText">func (x *Int) MarshalText() (text []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Mod">func (z *Int) Mod(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.ModInverse">func (z *Int) ModInverse(g, n *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.ModSqrt">func (z *Int) ModSqrt(x, p *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Mul">func (z *Int) Mul(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.MulRange">func (z *Int) MulRange(a, b int64) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Neg">func (z *Int) Neg(x *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Not">func (z *Int) Not(x *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Or">func (z *Int) Or(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.ProbablyPrime">func (x *Int) ProbablyPrime(n int) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Quo">func (z *Int) Quo(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.QuoRem">func (z *Int) QuoRem(x, y, r *Int) (*Int, *Int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Rand">func (z *Int) Rand(rnd *rand.Rand, n *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Rem">func (z *Int) Rem(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Rsh">func (z *Int) Rsh(x *Int, n uint) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Scan">func (z *Int) Scan(s fmt.ScanState, ch rune) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Set">func (z *Int) Set(x *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.SetBit">func (z *Int) SetBit(x *Int, i int, b uint) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.SetBits">func (z *Int) SetBits(abs []Word) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.SetBytes">func (z *Int) SetBytes(buf []byte) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.SetInt64">func (z *Int) SetInt64(x int64) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.SetString">func (z *Int) SetString(s string, base int) (*Int, bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.SetUint64">func (z *Int) SetUint64(x uint64) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Sign">func (x *Int) Sign() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Sqrt">func (z *Int) Sqrt(x *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.String">func (x *Int) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Sub">func (z *Int) Sub(x, y *Int) *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Text">func (x *Int) Text(base int) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.TrailingZeroBits">func (x *Int) TrailingZeroBits() uint</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Uint64">func (x *Int) Uint64() uint64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.UnmarshalJSON">func (z *Int) UnmarshalJSON(text []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.UnmarshalText">func (z *Int) UnmarshalText(text []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int.Xor">func (z *Int) Xor(x, y *Int) *Int</a></dd>
				
			
				
				<dd><a href="#Rat">type Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRat">func NewRat(a, b int64) *Rat</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.Abs">func (z *Rat) Abs(x *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.Add">func (z *Rat) Add(x, y *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.Cmp">func (x *Rat) Cmp(y *Rat) int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.Denom">func (x *Rat) Denom() *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.Float32">func (x *Rat) Float32() (f float32, exact bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.Float64">func (x *Rat) Float64() (f float64, exact bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.FloatPrec">func (x *Rat) FloatPrec() (n int, exact bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.FloatString">func (x *Rat) FloatString(prec int) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.GobDecode">func (z *Rat) GobDecode(buf []byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.GobEncode">func (x *Rat) GobEncode() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.Inv">func (z *Rat) Inv(x *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.IsInt">func (x *Rat) IsInt() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.MarshalText">func (x *Rat) MarshalText() (text []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.Mul">func (z *Rat) Mul(x, y *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.Neg">func (z *Rat) Neg(x *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.Num">func (x *Rat) Num() *Int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.Quo">func (z *Rat) Quo(x, y *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.RatString">func (x *Rat) RatString() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.Scan">func (z *Rat) Scan(s fmt.ScanState, ch rune) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.Set">func (z *Rat) Set(x *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.SetFloat64">func (z *Rat) SetFloat64(f float64) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.SetFrac">func (z *Rat) SetFrac(a, b *Int) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.SetFrac64">func (z *Rat) SetFrac64(a, b int64) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.SetInt">func (z *Rat) SetInt(x *Int) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.SetInt64">func (z *Rat) SetInt64(x int64) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.SetString">func (z *Rat) SetString(s string) (*Rat, bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.SetUint64">func (z *Rat) SetUint64(x uint64) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.Sign">func (x *Rat) Sign() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.String">func (x *Rat) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.Sub">func (z *Rat) Sub(x, y *Rat) *Rat</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Rat.UnmarshalText">func (z *Rat) UnmarshalText(text []byte) error</a></dd>
				
			
				
				<dd><a href="#RoundingMode">type RoundingMode</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RoundingMode.String">func (i RoundingMode) String() string</a></dd>
				
			
				
				<dd><a href="#Word">type Word</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Float_Add">Float.Add</a></dd>
			
			<dd><a class="exampleLink" href="#example_Float_Cmp">Float.Cmp</a></dd>
			
			<dd><a class="exampleLink" href="#example_Float_Copy">Float.Copy</a></dd>
			
			<dd><a class="exampleLink" href="#example_Float_Scan">Float.Scan</a></dd>
			
			<dd><a class="exampleLink" href="#example_Float_SetString">Float.SetString</a></dd>
			
			<dd><a class="exampleLink" href="#example_Float_shift">Float (Shift)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Int_Scan">Int.Scan</a></dd>
			
			<dd><a class="exampleLink" href="#example_Int_SetString">Int.SetString</a></dd>
			
			<dd><a class="exampleLink" href="#example_Rat_Scan">Rat.Scan</a></dd>
			
			<dd><a class="exampleLink" href="#example_Rat_SetString">Rat.SetString</a></dd>
			
			<dd><a class="exampleLink" href="#example_RoundingMode">RoundingMode</a></dd>
			
			<dd><a class="exampleLink" href="#example__eConvergents">Package (EConvergents)</a></dd>
			
			<dd><a class="exampleLink" href="#example__fibonacci">Package (Fibonacci)</a></dd>
			
			<dd><a class="exampleLink" href="#example__sqrt2">Package (Sqrt2)</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/math/big/accuracy_string.go">accuracy_string.go</a>
			
				<a href="/src/math/big/arith.go">arith.go</a>
			
				<a href="/src/math/big/arith_decl.go">arith_decl.go</a>
			
				<a href="/src/math/big/decimal.go">decimal.go</a>
			
				<a href="/src/math/big/doc.go">doc.go</a>
			
				<a href="/src/math/big/float.go">float.go</a>
			
				<a href="/src/math/big/floatconv.go">floatconv.go</a>
			
				<a href="/src/math/big/floatmarsh.go">floatmarsh.go</a>
			
				<a href="/src/math/big/ftoa.go">ftoa.go</a>
			
				<a href="/src/math/big/int.go">int.go</a>
			
				<a href="/src/math/big/intconv.go">intconv.go</a>
			
				<a href="/src/math/big/intmarsh.go">intmarsh.go</a>
			
				<a href="/src/math/big/nat.go">nat.go</a>
			
				<a href="/src/math/big/natconv.go">natconv.go</a>
			
				<a href="/src/math/big/natdiv.go">natdiv.go</a>
			
				<a href="/src/math/big/prime.go">prime.go</a>
			
				<a href="/src/math/big/rat.go">rat.go</a>
			
				<a href="/src/math/big/ratconv.go">ratconv.go</a>
			
				<a href="/src/math/big/ratmarsh.go">ratmarsh.go</a>
			
				<a href="/src/math/big/roundingmode_string.go">roundingmode_string.go</a>
			
				<a href="/src/math/big/sqrt.go">sqrt.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				<p>Exponent and precision limits.

				<pre>const (
    <span id="MaxExp">MaxExp</span>  = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#MaxInt32">MaxInt32</a>  <span class="comment">// largest supported exponent</span>
    <span id="MinExp">MinExp</span>  = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#MinInt32">MinInt32</a>  <span class="comment">// smallest supported exponent</span>
    <span id="MaxPrec">MaxPrec</span> = <a href="/pkg/math/">math</a>.<a href="/pkg/math/#MaxUint32">MaxUint32</a> <span class="comment">// largest (theoretically) supported precision; likely memory-limited</span>
)</pre>
			
				<p>MaxBase is the largest number base accepted for string conversions.

				<pre>const <span id="MaxBase">MaxBase</span> = 10 + (&#39;z&#39; - &#39;a&#39; + 1) + (&#39;Z&#39; - &#39;A&#39; + 1)</pre>
			
		
		
		
			
			
			<h2 id="Jacobi">func <a href="/src/math/big/int.go?s=24723:24749#L922">Jacobi</a>
				<a class="permalink" href="#Jacobi">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func Jacobi(x, y *<a href="#Int">Int</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0.
The y argument must be an odd integer.

			
			

		
		
			
			
			<h2 id="Accuracy">type <a href="/src/math/big/float.go?s=5908:5926#L138">Accuracy</a>
				<a class="permalink" href="#Accuracy">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>Accuracy describes the rounding error produced by the most recent
operation that generated a <a href="#Float">Float</a> value, relative to the exact value.

			<pre>type Accuracy <a href="/pkg/builtin/#int8">int8</a></pre>

			
				<p>Constants describing the <a href="#Accuracy">Accuracy</a> of a <a href="#Float">Float</a>.

				<pre>const (
    <span id="Below">Below</span> <a href="#Accuracy">Accuracy</a> = -1
    <span id="Exact">Exact</span> <a href="#Accuracy">Accuracy</a> = 0
    <span id="Above">Above</span> <a href="#Accuracy">Accuracy</a> = +1
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="Accuracy.String">func (Accuracy) <a href="/src/math/big/accuracy_string.go?s=416:449#L10">String</a>
					<a class="permalink" href="#Accuracy.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (i <a href="#Accuracy">Accuracy</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="ErrNaN">type <a href="/src/math/big/float.go?s=3270:3304#L67">ErrNaN</a>
				<a class="permalink" href="#ErrNaN">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>An ErrNaN panic is raised by a <a href="#Float">Float</a> operation that would lead to
a NaN under IEEE 754 rules. An ErrNaN implements the error interface.

			<pre>type ErrNaN struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ErrNaN.Error">func (ErrNaN) <a href="/src/math/big/float.go?s=3306:3338#L71">Error</a>
					<a class="permalink" href="#ErrNaN.Error">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (err <a href="#ErrNaN">ErrNaN</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Float">type <a href="/src/math/big/float.go?s=3012:3124#L55">Float</a>
				<a class="permalink" href="#Float">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>A nonzero finite Float represents a multi-precision floating point number
<pre>sign × mantissa × 2**exponent
</pre>
<p>with 0.5 &lt;= mantissa &lt; 1.0, and MinExp &lt;= exponent &lt;= MaxExp.
A Float may also be zero (+0, -0) or infinite (+Inf, -Inf).
All Floats are ordered, and the ordering of two Floats x and y
is defined by x.Cmp(y).
<p>Each Float value also has a precision, rounding mode, and accuracy.
The precision is the maximum number of mantissa bits available to
represent the value. The rounding mode specifies how a result should
be rounded to fit into the mantissa bits, and accuracy describes the
rounding error with respect to the exact result.
<p>Unless specified otherwise, all operations (including setters) that
specify a *Float variable for the result (usually via the receiver
with the exception of <a href="#Float.MantExp">Float.MantExp</a>), round the numeric result according
to the precision and rounding mode of the result variable.
<p>If the provided result precision is 0 (see below), it is set to the
precision of the argument with the largest precision value before any
rounding takes place, and the rounding mode remains unchanged. Thus,
uninitialized Floats provided as result arguments will have their
precision set to a reasonable value determined by the operands, and
their mode is the zero value for RoundingMode (ToNearestEven).
<p>By setting the desired precision to 24 or 53 and using matching rounding
mode (typically <a href="#ToNearestEven">ToNearestEven</a>), Float operations produce the same results
as the corresponding float32 or float64 IEEE 754 arithmetic for operands
that correspond to normal (i.e., not denormal) float32 or float64 numbers.
Exponent underflow and overflow lead to a 0 or an Infinity for different
values than IEEE 754 because Float exponents have a much larger range.
<p>The zero (uninitialized) value for a Float is ready to use and represents
the number +0.0 exactly, with precision 0 and rounding mode <a href="#ToNearestEven">ToNearestEven</a>.
<p>Operations always take pointer arguments (*Float) rather
than Float values, and each unique Float value requires
its own unique *Float pointer. To &quot;copy&quot; a Float value,
an existing (or newly allocated) Float must be set to
a new value using the <a href="#Float.Set">Float.Set</a> method; shallow copies
of Floats are not supported and may lead to errors.

			<pre>type Float struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Float_shift" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Shift)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Shift)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Implement Float &#34;shift&#34; by modifying the (binary) exponents directly.</span>
for s := -5; s &lt;= 5; s++ {
    x := big.NewFloat(0.5)
    x.SetMantExp(x, x.MantExp(nil)+s) <span class="comment">// shift x by s</span>
    fmt.Println(x)
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">0.015625
0.03125
0.0625
0.125
0.25
0.5
1
2
4
8
16
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewFloat">func <a href="/src/math/big/float.go?s=3522:3553#L78">NewFloat</a>
					<a class="permalink" href="#NewFloat">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func NewFloat(x <a href="/pkg/builtin/#float64">float64</a>) *<a href="#Float">Float</a></pre>
				<p>NewFloat allocates and returns a new <a href="#Float">Float</a> set to x,
with precision 53 and rounding mode <a href="#ToNearestEven">ToNearestEven</a>.
NewFloat panics with <a href="#ErrNaN">ErrNaN</a> if x is a NaN.

				
				
			
				
				<h3 id="ParseFloat">func <a href="/src/math/big/floatconv.go?s=7915:8009#L277">ParseFloat</a>
					<a class="permalink" href="#ParseFloat">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func ParseFloat(s <a href="/pkg/builtin/#string">string</a>, base <a href="/pkg/builtin/#int">int</a>, prec <a href="/pkg/builtin/#uint">uint</a>, mode <a href="#RoundingMode">RoundingMode</a>) (f *<a href="#Float">Float</a>, b <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ParseFloat is like f.Parse(s, base) with f set to the given precision
and rounding mode.

				
				
			

			
				
				<h3 id="Float.Abs">func (*Float) <a href="/src/math/big/float.go?s=32207:32243#L1170">Abs</a>
					<a class="permalink" href="#Float.Abs">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) Abs(x *<a href="#Float">Float</a>) *<a href="#Float">Float</a></pre>
				<p>Abs sets z to the (possibly rounded) value |x| (the absolute value of x)
and returns z.

				
				
				
			
				
				<h3 id="Float.Acc">func (*Float) <a href="/src/math/big/float.go?s=7907:7937#L220">Acc</a>
					<a class="permalink" href="#Float.Acc">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) Acc() <a href="#Accuracy">Accuracy</a></pre>
				<p>Acc returns the accuracy of x produced by the most recent
operation, unless explicitly documented otherwise by that
operation.

				
				
				
			
				
				<h3 id="Float.Add">func (*Float) <a href="/src/math/big/float.go?s=39992:40031#L1437">Add</a>
					<a class="permalink" href="#Float.Add">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) Add(x, y *<a href="#Float">Float</a>) *<a href="#Float">Float</a></pre>
				<p>Add sets z to the rounded sum x+y and returns z. If z&apos;s precision is 0,
it is changed to the larger of x&apos;s or y&apos;s precision before the operation.
Rounding is performed according to z&apos;s precision and rounding mode; and
z&apos;s accuracy reports the result error relative to the exact (not rounded)
result. Add panics with <a href="#ErrNaN">ErrNaN</a> if x and y are infinities with opposite
signs. The value of z is undefined in that case.

				
				<div id="example_Float_Add" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Operate on numbers of different precision.</span>
var x, y, z big.Float
x.SetInt64(1000)          <span class="comment">// x is automatically set to 64bit precision</span>
y.SetFloat64(2.718281828) <span class="comment">// y is automatically set to 53bit precision</span>
z.SetPrec(32)
z.Add(&amp;x, &amp;y)
fmt.Printf(&#34;x = %.10g (%s, prec = %d, acc = %s)\n&#34;, &amp;x, x.Text(&#39;p&#39;, 0), x.Prec(), x.Acc())
fmt.Printf(&#34;y = %.10g (%s, prec = %d, acc = %s)\n&#34;, &amp;y, y.Text(&#39;p&#39;, 0), y.Prec(), y.Acc())
fmt.Printf(&#34;z = %.10g (%s, prec = %d, acc = %s)\n&#34;, &amp;z, z.Text(&#39;p&#39;, 0), z.Prec(), z.Acc())
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">x = 1000 (0x.fap+10, prec = 64, acc = Exact)
y = 2.718281828 (0x.adf85458248cd8p+2, prec = 53, acc = Exact)
z = 1002.718282 (0x.faadf854p+10, prec = 32, acc = Below)
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Float.Append">func (*Float) <a href="/src/math/big/ftoa.go?s=2524:2585#L53">Append</a>
					<a class="permalink" href="#Float.Append">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) Append(buf []<a href="/pkg/builtin/#byte">byte</a>, fmt <a href="/pkg/builtin/#byte">byte</a>, prec <a href="/pkg/builtin/#int">int</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>Append appends to buf the string form of the floating-point number x,
as generated by x.Text, and returns the extended buffer.

				
				
				
			
				
				<h3 id="Float.Cmp">func (*Float) <a href="/src/math/big/float.go?s=44908:44941#L1668">Cmp</a>
					<a class="permalink" href="#Float.Cmp">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) Cmp(y *<a href="#Float">Float</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>Cmp compares x and y and returns:
<ul>
<li>-1 if x &lt; y;
<li>0 if x == y (incl. -0 == 0, -Inf == -Inf, and +Inf == +Inf);
<li>+1 if x &gt; y.
</ul>

				
				<div id="example_Float_Cmp" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">inf := math.Inf(1)
zero := 0.0

operands := []float64{-inf, -1.2, -zero, 0, +1.2, +inf}

fmt.Println(&#34;   x     y  cmp&#34;)
fmt.Println(&#34;---------------&#34;)
for _, x64 := range operands {
    x := big.NewFloat(x64)
    for _, y64 := range operands {
        y := big.NewFloat(y64)
        fmt.Printf(&#34;%4g  %4g  %3d\n&#34;, x, y, x.Cmp(y))
    }
    fmt.Println()
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">   x     y  cmp
---------------
-Inf  -Inf    0
-Inf  -1.2   -1
-Inf    -0   -1
-Inf     0   -1
-Inf   1.2   -1
-Inf  +Inf   -1

-1.2  -Inf    1
-1.2  -1.2    0
-1.2    -0   -1
-1.2     0   -1
-1.2   1.2   -1
-1.2  +Inf   -1

  -0  -Inf    1
  -0  -1.2    1
  -0    -0    0
  -0     0    0
  -0   1.2   -1
  -0  +Inf   -1

   0  -Inf    1
   0  -1.2    1
   0    -0    0
   0     0    0
   0   1.2   -1
   0  +Inf   -1

 1.2  -Inf    1
 1.2  -1.2    1
 1.2    -0    1
 1.2     0    1
 1.2   1.2    0
 1.2  +Inf   -1

+Inf  -Inf    1
+Inf  -1.2    1
+Inf    -0    1
+Inf     0    1
+Inf   1.2    1
+Inf  +Inf    0
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Float.Copy">func (*Float) <a href="/src/math/big/float.go?s=19109:19146#L666">Copy</a>
					<a class="permalink" href="#Float.Copy">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) Copy(x *<a href="#Float">Float</a>) *<a href="#Float">Float</a></pre>
				<p>Copy sets z to x, with the same precision, rounding mode, and accuracy as x.
Copy returns z. If x and z are identical, Copy is a no-op.

				
				<div id="example_Float_Copy" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">var x, z big.Float

x.SetFloat64(1.23)
r := z.Copy(&amp;x)
fmt.Printf(&#34;a) r = %g, z = %g, x = %g, r == z = %v\n&#34;, r, &amp;z, &amp;x, r == &amp;z)

<span class="comment">// changing z changes r since they are identical</span>
z.SetInt64(42)
fmt.Printf(&#34;b) r = %g, z = %g, r == z = %v\n&#34;, r, &amp;z, r == &amp;z)

x.SetPrec(1)
z.Copy(&amp;x)
fmt.Printf(&#34;c) z = %g, x = %g, z == x = %v\n&#34;, &amp;z, &amp;x, &amp;z == &amp;x)

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">a) r = 1.23, z = 1.23, x = 1.23, r == z = true
b) r = 42, z = 42, r == z = true
c) z = 1, x = 1, z == x = false
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Float.Float32">func (*Float) <a href="/src/math/big/float.go?s=22563:22608#L829">Float32</a>
					<a class="permalink" href="#Float.Float32">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) Float32() (<a href="/pkg/builtin/#float32">float32</a>, <a href="#Accuracy">Accuracy</a>)</pre>
				<p>Float32 returns the float32 value nearest to x. If x is too small to be
represented by a float32 (|x| &lt; <a href="/math#SmallestNonzeroFloat32">math.SmallestNonzeroFloat32</a>), the result
is (0, <a href="#Below">Below</a>) or (-0, <a href="#Above">Above</a>), respectively, depending on the sign of x.
If x is too large to be represented by a float32 (|x| &gt; <a href="/math#MaxFloat32">math.MaxFloat32</a>),
the result is (+Inf, <a href="#Above">Above</a>) or (-Inf, <a href="#Below">Below</a>), depending on the sign of x.

				
				
				
			
				
				<h3 id="Float.Float64">func (*Float) <a href="/src/math/big/float.go?s=26428:26473#L949">Float64</a>
					<a class="permalink" href="#Float.Float64">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) Float64() (<a href="/pkg/builtin/#float64">float64</a>, <a href="#Accuracy">Accuracy</a>)</pre>
				<p>Float64 returns the float64 value nearest to x. If x is too small to be
represented by a float64 (|x| &lt; <a href="/math#SmallestNonzeroFloat64">math.SmallestNonzeroFloat64</a>), the result
is (0, <a href="#Below">Below</a>) or (-0, <a href="#Above">Above</a>), respectively, depending on the sign of x.
If x is too large to be represented by a float64 (|x| &gt; <a href="/math#MaxFloat64">math.MaxFloat64</a>),
the result is (+Inf, <a href="#Above">Above</a>) or (-Inf, <a href="#Below">Below</a>), depending on the sign of x.

				
				
				
			
				
				<h3 id="Float.Format">func (*Float) <a href="/src/math/big/ftoa.go?s=12383:12431#L448">Format</a>
					<a class="permalink" href="#Float.Format">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) Format(s <a href="/pkg/fmt/">fmt</a>.<a href="/pkg/fmt/#State">State</a>, format <a href="/pkg/builtin/#rune">rune</a>)</pre>
				<p>Format implements <a href="/fmt#Formatter">fmt.Formatter</a>. It accepts all the regular
formats for floating-point numbers (&apos;b&apos;, &apos;e&apos;, &apos;E&apos;, &apos;f&apos;, &apos;F&apos;,
&apos;g&apos;, &apos;G&apos;, &apos;x&apos;) as well as &apos;p&apos; and &apos;v&apos;. See (*Float).Text for the
interpretation of &apos;p&apos;. The &apos;v&apos; format is handled like &apos;g&apos;.
Format also supports specification of the minimum precision
in digits, the output field width, as well as the format flags
&apos;+&apos; and &apos; &apos; for sign control, &apos;0&apos; for space or zero padding,
and &apos;-&apos; for left or right justification. See the fmt package
for details.

				
				
				
			
				
				<h3 id="Float.GobDecode">func (*Float) <a href="/src/math/big/floatmarsh.go?s=1952:1995#L55">GobDecode</a>
					<a class="permalink" href="#Float.GobDecode">&#xb6;</a>
					
					<span title="Added in Go 1.7">1.7</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) GobDecode(buf []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>GobDecode implements the <a href="/encoding/gob#GobDecoder">encoding/gob.GobDecoder</a> interface.
The result is rounded per the precision and rounding mode of
z unless z&apos;s precision is 0, in which case z is set exactly
to the decoded value.

				
				
				
			
				
				<h3 id="Float.GobEncode">func (*Float) <a href="/src/math/big/floatmarsh.go?s=549:592#L11">GobEncode</a>
					<a class="permalink" href="#Float.GobEncode">&#xb6;</a>
					
					<span title="Added in Go 1.7">1.7</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) GobEncode() ([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>GobEncode implements the <a href="/encoding/gob#GobEncoder">encoding/gob.GobEncoder</a> interface.
The <a href="#Float">Float</a> value and all its attributes (precision,
rounding mode, accuracy) are marshaled.

				
				
				
			
				
				<h3 id="Float.Int">func (*Float) <a href="/src/math/big/float.go?s=30166:30210#L1070">Int</a>
					<a class="permalink" href="#Float.Int">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) Int(z *<a href="#Int">Int</a>) (*<a href="#Int">Int</a>, <a href="#Accuracy">Accuracy</a>)</pre>
				<p>Int returns the result of truncating x towards zero;
or nil if x is an infinity.
The result is <a href="#Exact">Exact</a> if x.IsInt(); otherwise it is <a href="#Below">Below</a>
for x &gt; 0, and <a href="#Above">Above</a> for x &lt; 0.
If a non-nil *<a href="#Int">Int</a> argument z is provided, <a href="#Int">Int</a> stores
the result in z instead of allocating a new <a href="#Int">Int</a>.

				
				
				
			
				
				<h3 id="Float.Int64">func (*Float) <a href="/src/math/big/float.go?s=21282:21323#L774">Int64</a>
					<a class="permalink" href="#Float.Int64">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) Int64() (<a href="/pkg/builtin/#int64">int64</a>, <a href="#Accuracy">Accuracy</a>)</pre>
				<p>Int64 returns the integer resulting from truncating x towards zero.
If <a href="/math#MinInt64">math.MinInt64</a> &lt;= x &lt;= <a href="/math#MaxInt64">math.MaxInt64</a>, the result is <a href="#Exact">Exact</a> if x is
an integer, and <a href="#Above">Above</a> (x &lt; 0) or <a href="#Below">Below</a> (x &gt; 0) otherwise.
The result is (<a href="/math#MinInt64">math.MinInt64</a>, <a href="#Above">Above</a>) for x &lt; <a href="/math#MinInt64">math.MinInt64</a>,
and (<a href="/math#MaxInt64">math.MaxInt64</a>, <a href="#Below">Below</a>) for x &gt; <a href="/math#MaxInt64">math.MaxInt64</a>.

				
				
				
			
				
				<h3 id="Float.IsInf">func (*Float) <a href="/src/math/big/float.go?s=10259:10287#L329">IsInf</a>
					<a class="permalink" href="#Float.IsInf">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) IsInf() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsInf reports whether x is +Inf or -Inf.

				
				
				
			
				
				<h3 id="Float.IsInt">func (*Float) <a href="/src/math/big/float.go?s=10391:10419#L335">IsInt</a>
					<a class="permalink" href="#Float.IsInt">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) IsInt() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsInt reports whether x is an integer.
±Inf values are not integers.

				
				
				
			
				
				<h3 id="Float.MantExp">func (*Float) <a href="/src/math/big/float.go?s=8786:8832#L256">MantExp</a>
					<a class="permalink" href="#Float.MantExp">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) MantExp(mant *<a href="#Float">Float</a>) (exp <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>MantExp breaks x into its mantissa and exponent components
and returns the exponent. If a non-nil mant argument is
provided its value is set to the mantissa of x, with the
same precision and rounding mode as x. The components
satisfy x == mant × 2**exp, with 0.5 &lt;= |mant| &lt; 1.0.
Calling MantExp with a nil argument is an efficient way to
get the exponent of the receiver.
<p>Special cases are:
<pre>(  ±0).MantExp(mant) = 0, with mant set to   ±0
(±Inf).MantExp(mant) = 0, with mant set to ±Inf
</pre>
<p>x and mant may be the same in which case x is set to its
mantissa value.

				
				
				
			
				
				<h3 id="Float.MarshalText">func (*Float) <a href="/src/math/big/floatmarsh.go?s=3075:3129#L102">MarshalText</a>
					<a class="permalink" href="#Float.MarshalText">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) MarshalText() (text []<a href="/pkg/builtin/#byte">byte</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>MarshalText implements the <a href="/encoding#TextMarshaler">encoding.TextMarshaler</a> interface.
Only the <a href="#Float">Float</a> value is marshaled (in full precision), other
attributes such as precision or accuracy are ignored.

				
				
				
			
				
				<h3 id="Float.MinPrec">func (*Float) <a href="/src/math/big/float.go?s=7545:7575#L205">MinPrec</a>
					<a class="permalink" href="#Float.MinPrec">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) MinPrec() <a href="/pkg/builtin/#uint">uint</a></pre>
				<p>MinPrec returns the minimum precision required to represent x exactly
(i.e., the smallest prec before x.SetPrec(prec) would start rounding x).
The result is 0 for |x| == 0 and |x| == Inf.

				
				
				
			
				
				<h3 id="Float.Mode">func (*Float) <a href="/src/math/big/float.go?s=7715:7750#L213">Mode</a>
					<a class="permalink" href="#Float.Mode">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) Mode() <a href="#RoundingMode">RoundingMode</a></pre>
				<p>Mode returns the rounding mode of x.

				
				
				
			
				
				<h3 id="Float.Mul">func (*Float) <a href="/src/math/big/float.go?s=43130:43169#L1578">Mul</a>
					<a class="permalink" href="#Float.Mul">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) Mul(x, y *<a href="#Float">Float</a>) *<a href="#Float">Float</a></pre>
				<p>Mul sets z to the rounded product x*y and returns z.
Precision, rounding, and accuracy reporting are as for <a href="#Float.Add">Float.Add</a>.
Mul panics with <a href="#ErrNaN">ErrNaN</a> if one operand is zero and the other
operand an infinity. The value of z is undefined in that case.

				
				
				
			
				
				<h3 id="Float.Neg">func (*Float) <a href="/src/math/big/float.go?s=32376:32412#L1178">Neg</a>
					<a class="permalink" href="#Float.Neg">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) Neg(x *<a href="#Float">Float</a>) *<a href="#Float">Float</a></pre>
				<p>Neg sets z to the (possibly rounded) value of x with its sign negated,
and returns z.

				
				
				
			
				
				<h3 id="Float.Parse">func (*Float) <a href="/src/math/big/floatconv.go?s=7219:7289#L249">Parse</a>
					<a class="permalink" href="#Float.Parse">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) Parse(s <a href="/pkg/builtin/#string">string</a>, base <a href="/pkg/builtin/#int">int</a>) (f *<a href="#Float">Float</a>, b <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Parse parses s which must contain a text representation of a floating-
point number with a mantissa in the given conversion base (the exponent
is always a decimal number), or a string representing an infinite value.
<p>For base 0, an underscore character “_” may appear between a base
prefix and an adjacent digit, and between successive digits; such
underscores do not change the value of the number, or the returned
digit count. Incorrect placement of underscores is reported as an
error if there are no other errors. If base != 0, underscores are
not recognized and thus terminate scanning like any other character
that is not a valid radix point or digit.
<p>It sets z to the (possibly rounded) value of the corresponding floating-
point value, and returns z, the actual base b, and an error err, if any.
The entire string (not just a prefix) must be consumed for success.
If z&apos;s precision is 0, it is changed to 64 before rounding takes effect.
The number must be of the form:
<pre>number    = [ sign ] ( float | &quot;inf&quot; | &quot;Inf&quot; ) .
sign      = &quot;+&quot; | &quot;-&quot; .
float     = ( mantissa | prefix pmantissa ) [ exponent ] .
prefix    = &quot;0&quot; [ &quot;b&quot; | &quot;B&quot; | &quot;o&quot; | &quot;O&quot; | &quot;x&quot; | &quot;X&quot; ] .
mantissa  = digits &quot;.&quot; [ digits ] | digits | &quot;.&quot; digits .
pmantissa = [ &quot;_&quot; ] digits &quot;.&quot; [ digits ] | [ &quot;_&quot; ] digits | &quot;.&quot; digits .
exponent  = ( &quot;e&quot; | &quot;E&quot; | &quot;p&quot; | &quot;P&quot; ) [ sign ] digits .
digits    = digit { [ &quot;_&quot; ] digit } .
digit     = &quot;0&quot; ... &quot;9&quot; | &quot;a&quot; ... &quot;z&quot; | &quot;A&quot; ... &quot;Z&quot; .
</pre>
<p>The base argument must be 0, 2, 8, 10, or 16. Providing an invalid base
argument will lead to a run-time panic.
<p>For base 0, the number prefix determines the actual base: A prefix of
“0b” or “0B” selects base 2, “0o” or “0O” selects base 8, and
“0x” or “0X” selects base 16. Otherwise, the actual base is 10 and
no prefix is accepted. The octal prefix &quot;0&quot; is not supported (a leading
&quot;0&quot; is simply considered a &quot;0&quot;).
<p>A &quot;p&quot; or &quot;P&quot; exponent indicates a base 2 (rather than base 10) exponent;
for instance, &quot;0x1.fffffffffffffp1023&quot; (using base 0) represents the
maximum float64 value. For hexadecimal mantissae, the exponent character
must be one of &apos;p&apos; or &apos;P&apos;, if present (an &quot;e&quot; or &quot;E&quot; exponent indicator
cannot be distinguished from a mantissa digit).
<p>The returned *Float f is nil and the value of z is valid but not
defined if an error is reported.

				
				
				
			
				
				<h3 id="Float.Prec">func (*Float) <a href="/src/math/big/float.go?s=7294:7321#L198">Prec</a>
					<a class="permalink" href="#Float.Prec">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) Prec() <a href="/pkg/builtin/#uint">uint</a></pre>
				<p>Prec returns the mantissa precision of x in bits.
The result may be 0 for |x| == 0 and |x| == Inf.

				
				
				
			
				
				<h3 id="Float.Quo">func (*Float) <a href="/src/math/big/float.go?s=44061:44100#L1623">Quo</a>
					<a class="permalink" href="#Float.Quo">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) Quo(x, y *<a href="#Float">Float</a>) *<a href="#Float">Float</a></pre>
				<p>Quo sets z to the rounded quotient x/y and returns z.
Precision, rounding, and accuracy reporting are as for <a href="#Float.Add">Float.Add</a>.
Quo panics with <a href="#ErrNaN">ErrNaN</a> if both operands are zero or infinities.
The value of z is undefined in that case.

				
				
				
			
				
				<h3 id="Float.Rat">func (*Float) <a href="/src/math/big/float.go?s=31273:31317#L1126">Rat</a>
					<a class="permalink" href="#Float.Rat">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) Rat(z *<a href="#Rat">Rat</a>) (*<a href="#Rat">Rat</a>, <a href="#Accuracy">Accuracy</a>)</pre>
				<p>Rat returns the rational number corresponding to x;
or nil if x is an infinity.
The result is <a href="#Exact">Exact</a> if x is not an Inf.
If a non-nil *<a href="#Rat">Rat</a> argument z is provided, <a href="#Rat">Rat</a> stores
the result in z instead of allocating a new <a href="#Rat">Rat</a>.

				
				
				
			
				
				<h3 id="Float.Scan">func (*Float) <a href="/src/math/big/floatconv.go?s=8426:8478#L288">Scan</a>
					<a class="permalink" href="#Float.Scan">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) Scan(s <a href="/pkg/fmt/">fmt</a>.<a href="/pkg/fmt/#ScanState">ScanState</a>, ch <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>Scan is a support routine for <a href="/fmt#Scanner">fmt.Scanner</a>; it sets z to the value of
the scanned number. It accepts formats whose verbs are supported by
<a href="/fmt#Scan">fmt.Scan</a> for floating point values, which are:
&apos;b&apos; (binary), &apos;e&apos;, &apos;E&apos;, &apos;f&apos;, &apos;F&apos;, &apos;g&apos; and &apos;G&apos;.
Scan doesn&apos;t handle ±Inf.

				
				<div id="example_Float_Scan" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// The Scan function is rarely used directly;</span>
<span class="comment">// the fmt package recognizes it as an implementation of fmt.Scanner.</span>
f := new(big.Float)
_, err := fmt.Sscan(&#34;1.19282e99&#34;, f)
if err != nil {
    log.Println(&#34;error scanning value:&#34;, err)
} else {
    fmt.Println(f)
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">1.19282e+99
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Float.Set">func (*Float) <a href="/src/math/big/float.go?s=18653:18689#L643">Set</a>
					<a class="permalink" href="#Float.Set">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) Set(x *<a href="#Float">Float</a>) *<a href="#Float">Float</a></pre>
				<p>Set sets z to the (possibly rounded) value of x and returns z.
If z&apos;s precision is 0, it is changed to the precision of x
before setting z (and rounding will have no effect).
Rounding is performed according to z&apos;s precision and rounding
mode; and z&apos;s accuracy reports the result error relative to the
exact (not rounded) result.

				
				
				
			
				
				<h3 id="Float.SetFloat64">func (*Float) <a href="/src/math/big/float.go?s=16014:16058#L541">SetFloat64</a>
					<a class="permalink" href="#Float.SetFloat64">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) SetFloat64(x <a href="/pkg/builtin/#float64">float64</a>) *<a href="#Float">Float</a></pre>
				<p>SetFloat64 sets z to the (possibly rounded) value of x and returns z.
If z&apos;s precision is 0, it is changed to 53 (and rounding will have
no effect). SetFloat64 panics with <a href="#ErrNaN">ErrNaN</a> if x is a NaN.

				
				
				
			
				
				<h3 id="Float.SetInf">func (*Float) <a href="/src/math/big/float.go?s=18201:18244#L630">SetInf</a>
					<a class="permalink" href="#Float.SetInf">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) SetInf(signbit <a href="/pkg/builtin/#bool">bool</a>) *<a href="#Float">Float</a></pre>
				<p>SetInf sets z to the infinite Float -Inf if signbit is
set, or +Inf if signbit is not set, and returns z. The
precision of z is unchanged and the result is always
<a href="#Exact">Exact</a>.

				
				
				
			
				
				<h3 id="Float.SetInt">func (*Float) <a href="/src/math/big/float.go?s=17190:17227#L589">SetInt</a>
					<a class="permalink" href="#Float.SetInt">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) SetInt(x *<a href="#Int">Int</a>) *<a href="#Float">Float</a></pre>
				<p>SetInt sets z to the (possibly rounded) value of x and returns z.
If z&apos;s precision is 0, it is changed to the larger of x.BitLen()
or 64 (and rounding will have no effect).

				
				
				
			
				
				<h3 id="Float.SetInt64">func (*Float) <a href="/src/math/big/float.go?s=15574:15614#L528">SetInt64</a>
					<a class="permalink" href="#Float.SetInt64">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) SetInt64(x <a href="/pkg/builtin/#int64">int64</a>) *<a href="#Float">Float</a></pre>
				<p>SetInt64 sets z to the (possibly rounded) value of x and returns z.
If z&apos;s precision is 0, it is changed to 64 (and rounding will have
no effect).

				
				
				
			
				
				<h3 id="Float.SetMantExp">func (*Float) <a href="/src/math/big/float.go?s=9871:9926#L309">SetMantExp</a>
					<a class="permalink" href="#Float.SetMantExp">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) SetMantExp(mant *<a href="#Float">Float</a>, exp <a href="/pkg/builtin/#int">int</a>) *<a href="#Float">Float</a></pre>
				<p>SetMantExp sets z to mant × 2**exp and returns z.
The result z has the same precision and rounding mode
as mant. SetMantExp is an inverse of <a href="#Float.MantExp">Float.MantExp</a> but does
not require 0.5 &lt;= |mant| &lt; 1.0. Specifically, for a
given x of type *<a href="#Float">Float</a>, SetMantExp relates to <a href="#Float.MantExp">Float.MantExp</a>
as follows:
<pre>mant := new(Float)
new(Float).SetMantExp(mant, x.MantExp(mant)).Cmp(x) == 0
</pre>
<p>Special cases are:
<pre>z.SetMantExp(  ±0, exp) =   ±0
z.SetMantExp(±Inf, exp) = ±Inf
</pre>
<p>z and mant may be the same in which case z&apos;s exponent
is set to exp.

				
				
				
			
				
				<h3 id="Float.SetMode">func (*Float) <a href="/src/math/big/float.go?s=7094:7143#L190">SetMode</a>
					<a class="permalink" href="#Float.SetMode">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) SetMode(mode <a href="#RoundingMode">RoundingMode</a>) *<a href="#Float">Float</a></pre>
				<p>SetMode sets z&apos;s rounding mode to mode and returns an exact z.
z remains unchanged otherwise.
z.SetMode(z.Mode()) is a cheap way to set z&apos;s accuracy to <a href="#Exact">Exact</a>.

				
				
				
			
				
				<h3 id="Float.SetPrec">func (*Float) <a href="/src/math/big/float.go?s=6436:6477#L154">SetPrec</a>
					<a class="permalink" href="#Float.SetPrec">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) SetPrec(prec <a href="/pkg/builtin/#uint">uint</a>) *<a href="#Float">Float</a></pre>
				<p>SetPrec sets z&apos;s precision to prec and returns the (possibly) rounded
value of z. Rounding occurs according to z&apos;s rounding mode if the mantissa
cannot be represented in prec bits without loss of precision.
SetPrec(0) maps all finite values to ±0; infinite values remain unchanged.
If prec &gt; <a href="#MaxPrec">MaxPrec</a>, it is set to <a href="#MaxPrec">MaxPrec</a>.

				
				
				
			
				
				<h3 id="Float.SetRat">func (*Float) <a href="/src/math/big/float.go?s=17795:17832#L613">SetRat</a>
					<a class="permalink" href="#Float.SetRat">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) SetRat(x *<a href="#Rat">Rat</a>) *<a href="#Float">Float</a></pre>
				<p>SetRat sets z to the (possibly rounded) value of x and returns z.
If z&apos;s precision is 0, it is changed to the largest of a.BitLen(),
b.BitLen(), or 64; with x = a/b.

				
				
				
			
				
				<h3 id="Float.SetString">func (*Float) <a href="/src/math/big/floatconv.go?s=645:695#L12">SetString</a>
					<a class="permalink" href="#Float.SetString">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) SetString(s <a href="/pkg/builtin/#string">string</a>) (*<a href="#Float">Float</a>, <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>SetString sets z to the value of s and returns z and a boolean indicating
success. s must be a floating-point number of the same format as accepted
by <a href="#Float.Parse">Float.Parse</a>, with base argument 0. The entire string (not just a prefix) must
be valid for success. If the operation failed, the value of z is undefined
but the returned value is nil.

				
				<div id="example_Float_SetString" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">f := new(big.Float)
f.SetString(&#34;3.14159&#34;)
fmt.Println(f)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">3.14159
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Float.SetUint64">func (*Float) <a href="/src/math/big/float.go?s=15340:15382#L521">SetUint64</a>
					<a class="permalink" href="#Float.SetUint64">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) SetUint64(x <a href="/pkg/builtin/#uint64">uint64</a>) *<a href="#Float">Float</a></pre>
				<p>SetUint64 sets z to the (possibly rounded) value of x and returns z.
If z&apos;s precision is 0, it is changed to 64 (and rounding will have
no effect).

				
				
				
			
				
				<h3 id="Float.Sign">func (*Float) <a href="/src/math/big/float.go?s=8036:8062#L228">Sign</a>
					<a class="permalink" href="#Float.Sign">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) Sign() <a href="/pkg/builtin/#int">int</a></pre>
				<p>Sign returns:
<ul>
<li>-1 if x &lt; 0;
<li>0 if x is ±0;
<li>+1 if x &gt; 0.
</ul>

				
				
				
			
				
				<h3 id="Float.Signbit">func (*Float) <a href="/src/math/big/float.go?s=10165:10195#L324">Signbit</a>
					<a class="permalink" href="#Float.Signbit">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) Signbit() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Signbit reports whether x is negative or negative zero.

				
				
				
			
				
				<h3 id="Float.Sqrt">func (*Float) <a href="/src/math/big/sqrt.go?s=738:775#L23">Sqrt</a>
					<a class="permalink" href="#Float.Sqrt">&#xb6;</a>
					
					<span title="Added in Go 1.10">1.10</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) Sqrt(x *<a href="#Float">Float</a>) *<a href="#Float">Float</a></pre>
				<p>Sqrt sets z to the rounded square root of x, and returns it.
<p>If z&apos;s precision is 0, it is changed to x&apos;s precision before the
operation. Rounding is performed according to z&apos;s precision and
rounding mode, but z&apos;s accuracy is not computed. Specifically, the
result of z.Acc() is undefined.
<p>The function panics if z &lt; 0. The value of z is undefined in that
case.

				
				
				
			
				
				<h3 id="Float.String">func (*Float) <a href="/src/math/big/ftoa.go?s=2330:2361#L47">String</a>
					<a class="permalink" href="#Float.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>String formats x like x.Text(&apos;g&apos;, 10).
(String must be called explicitly, <a href="#Float.Format">Float.Format</a> does not support %s verb.)

				
				
				
			
				
				<h3 id="Float.Sub">func (*Float) <a href="/src/math/big/float.go?s=41719:41758#L1511">Sub</a>
					<a class="permalink" href="#Float.Sub">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) Sub(x, y *<a href="#Float">Float</a>) *<a href="#Float">Float</a></pre>
				<p>Sub sets z to the rounded difference x-y and returns z.
Precision, rounding, and accuracy reporting are as for <a href="#Float.Add">Float.Add</a>.
Sub panics with <a href="#ErrNaN">ErrNaN</a> if x and y are infinities with equal
signs. The value of z is undefined in that case.

				
				
				
			
				
				<h3 id="Float.Text">func (*Float) <a href="/src/math/big/ftoa.go?s=2000:2050#L37">Text</a>
					<a class="permalink" href="#Float.Text">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) Text(format <a href="/pkg/builtin/#byte">byte</a>, prec <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#string">string</a></pre>
				<p>Text converts the floating-point number x to a string according
to the given format and precision prec. The format is one of:
<pre>&apos;e&apos;	-d.dddde±dd, decimal exponent, at least two (possibly 0) exponent digits
&apos;E&apos;	-d.ddddE±dd, decimal exponent, at least two (possibly 0) exponent digits
&apos;f&apos;	-ddddd.dddd, no exponent
&apos;g&apos;	like &apos;e&apos; for large exponents, like &apos;f&apos; otherwise
&apos;G&apos;	like &apos;E&apos; for large exponents, like &apos;f&apos; otherwise
&apos;x&apos;	-0xd.dddddp±dd, hexadecimal mantissa, decimal power of two exponent
&apos;p&apos;	-0x.dddp±dd, hexadecimal mantissa, decimal power of two exponent (non-standard)
&apos;b&apos;	-ddddddp±dd, decimal mantissa, decimal power of two exponent (non-standard)
</pre>
<p>For the power-of-two exponent formats, the mantissa is printed in normalized form:
<pre>&apos;x&apos;	hexadecimal mantissa in [1, 2), or 0
&apos;p&apos;	hexadecimal mantissa in [½, 1), or 0
&apos;b&apos;	decimal integer mantissa using x.Prec() bits, or 0
</pre>
<p>Note that the &apos;x&apos; form is the one used by most other languages and libraries.
<p>If format is a different character, Text returns a &quot;%&quot; followed by the
unrecognized format character.
<p>The precision prec controls the number of digits (excluding the exponent)
printed by the &apos;e&apos;, &apos;E&apos;, &apos;f&apos;, &apos;g&apos;, &apos;G&apos;, and &apos;x&apos; formats.
For &apos;e&apos;, &apos;E&apos;, &apos;f&apos;, and &apos;x&apos;, it is the number of digits after the decimal point.
For &apos;g&apos; and &apos;G&apos; it is the total number of digits. A negative precision selects
the smallest number of decimal digits necessary to identify the value x uniquely
using x.Prec() mantissa bits.
The prec value is ignored for the &apos;b&apos; and &apos;p&apos; formats.

				
				
				
			
				
				<h3 id="Float.Uint64">func (*Float) <a href="/src/math/big/float.go?s=20320:20363#L729">Uint64</a>
					<a class="permalink" href="#Float.Uint64">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (x *<a href="#Float">Float</a>) Uint64() (<a href="/pkg/builtin/#uint64">uint64</a>, <a href="#Accuracy">Accuracy</a>)</pre>
				<p>Uint64 returns the unsigned integer resulting from truncating x
towards zero. If 0 &lt;= x &lt;= <a href="/math#MaxUint64">math.MaxUint64</a>, the result is <a href="#Exact">Exact</a>
if x is an integer and <a href="#Below">Below</a> otherwise.
The result is (0, <a href="#Above">Above</a>) for x &lt; 0, and (<a href="/math#MaxUint64">math.MaxUint64</a>, <a href="#Below">Below</a>)
for x &gt; <a href="/math#MaxUint64">math.MaxUint64</a>.

				
				
				
			
				
				<h3 id="Float.UnmarshalText">func (*Float) <a href="/src/math/big/floatmarsh.go?s=3451:3499#L114">UnmarshalText</a>
					<a class="permalink" href="#Float.UnmarshalText">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func (z *<a href="#Float">Float</a>) UnmarshalText(text []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>UnmarshalText implements the <a href="/encoding#TextUnmarshaler">encoding.TextUnmarshaler</a> interface.
The result is rounded per the precision and rounding mode of z.
If z&apos;s precision is 0, it is changed to 64 before rounding takes
effect.

				
				
				
			
		
			
			
			<h2 id="Int">type <a href="/src/math/big/int.go?s=1197:1277#L23">Int</a>
				<a class="permalink" href="#Int">&#xb6;</a>
				
				
			</h2>
			<p>An Int represents a signed multi-precision integer.
The zero value for an Int represents the value 0.
<p>Operations always take pointer arguments (*Int) rather
than Int values, and each unique Int value requires
its own unique *Int pointer. To &quot;copy&quot; an Int value,
an existing (or newly allocated) Int must be set to
a new value using the <a href="#Int.Set">Int.Set</a> method; shallow copies
of Ints are not supported and may lead to errors.
<p>Note that methods may leak the Int&apos;s value through timing side-channels.
Because of this and because of the scope and complexity of the
implementation, Int is not well-suited to implement cryptographic operations.
The standard library avoids exposing non-trivial Int methods to
attacker-controlled inputs and the determination of whether a bug in math/big
is considered a security vulnerability might depend on the impact on the
standard library.

			<pre>type Int struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewInt">func <a href="/src/math/big/int.go?s=2070:2095#L67">NewInt</a>
					<a class="permalink" href="#NewInt">&#xb6;</a>
					
					
				</h3>
				<pre>func NewInt(x <a href="/pkg/builtin/#int64">int64</a>) *<a href="#Int">Int</a></pre>
				<p>NewInt allocates and returns a new <a href="#Int">Int</a> set to x.

				
				
			

			
				
				<h3 id="Int.Abs">func (*Int) <a href="/src/math/big/int.go?s=3633:3663#L117">Abs</a>
					<a class="permalink" href="#Int.Abs">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Abs(x *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Abs sets z to |x| (the absolute value of x) and returns z.

				
				
				
			
				
				<h3 id="Int.Add">func (*Int) <a href="/src/math/big/int.go?s=3890:3923#L131">Add</a>
					<a class="permalink" href="#Int.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Add(x, y *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Add sets z to the sum x+y and returns z.

				
				
				
			
				
				<h3 id="Int.And">func (*Int) <a href="/src/math/big/int.go?s=30516:30549#L1161">And</a>
					<a class="permalink" href="#Int.And">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) And(x, y *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>And sets z = x &amp; y and returns z.

				
				
				
			
				
				<h3 id="Int.AndNot">func (*Int) <a href="/src/math/big/int.go?s=31197:31233#L1191">AndNot</a>
					<a class="permalink" href="#Int.AndNot">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) AndNot(x, y *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>AndNot sets z = x &amp;^ y and returns z.

				
				
				
			
				
				<h3 id="Int.Append">func (*Int) <a href="/src/math/big/intconv.go?s=864:913#L20">Append</a>
					<a class="permalink" href="#Int.Append">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) Append(buf []<a href="/pkg/builtin/#byte">byte</a>, base <a href="/pkg/builtin/#int">int</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>Append appends the string representation of x, as generated by
x.Text(base), to buf and returns the extended buffer.

				
				
				
			
				
				<h3 id="Int.Binomial">func (*Int) <a href="/src/math/big/int.go?s=5704:5743#L212">Binomial</a>
					<a class="permalink" href="#Int.Binomial">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Binomial(n, k <a href="/pkg/builtin/#int64">int64</a>) *<a href="#Int">Int</a></pre>
				<p>Binomial sets z to the binomial coefficient C(n, k) and returns z.

				
				
				
			
				
				<h3 id="Int.Bit">func (*Int) <a href="/src/math/big/int.go?s=29611:29640#L1120">Bit</a>
					<a class="permalink" href="#Int.Bit">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) Bit(i <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#uint">uint</a></pre>
				<p>Bit returns the value of the i&apos;th bit of x. That is, it
returns (x&gt;&gt;i)&amp;1. The bit index i must be &gt;= 0.

				
				
				
			
				
				<h3 id="Int.BitLen">func (*Int) <a href="/src/math/big/int.go?s=14566:14592#L531">BitLen</a>
					<a class="permalink" href="#Int.BitLen">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) BitLen() <a href="/pkg/builtin/#int">int</a></pre>
				<p>BitLen returns the length of the absolute value of x in bits.
The bit length of 0 is 0.

				
				
				
			
				
				<h3 id="Int.Bits">func (*Int) <a href="/src/math/big/int.go?s=2882:2909#L98">Bits</a>
					<a class="permalink" href="#Int.Bits">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) Bits() []<a href="#Word">Word</a></pre>
				<p>Bits provides raw (unchecked but fast) access to x by returning its
absolute value as a little-endian <a href="#Word">Word</a> slice. The result and x share
the same underlying array.
Bits is intended to support implementation of missing low-level <a href="#Int">Int</a>
functionality outside this package; it should be avoided otherwise.

				
				
				
			
				
				<h3 id="Int.Bytes">func (*Int) <a href="/src/math/big/int.go?s=13864:13892#L510">Bytes</a>
					<a class="permalink" href="#Int.Bytes">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) Bytes() []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>Bytes returns the absolute value of x as a big-endian byte slice.
<p>To use a fixed length slice, or a preallocated one, use <a href="#Int.FillBytes">Int.FillBytes</a>.

				
				
				
			
				
				<h3 id="Int.Cmp">func (*Int) <a href="/src/math/big/int.go?s=9665:9698#L361">Cmp</a>
					<a class="permalink" href="#Int.Cmp">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) Cmp(y *<a href="#Int">Int</a>) (r <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Cmp compares x and y and returns:
<ul>
<li>-1 if x &lt; y;
<li>0 if x == y;
<li>+1 if x &gt; y.
</ul>

				
				
				
			
				
				<h3 id="Int.CmpAbs">func (*Int) <a href="/src/math/big/int.go?s=10100:10132#L386">CmpAbs</a>
					<a class="permalink" href="#Int.CmpAbs">&#xb6;</a>
					
					<span title="Added in Go 1.10">1.10</span>
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) CmpAbs(y *<a href="#Int">Int</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>CmpAbs compares the absolute values of x and y and returns:
<ul>
<li>-1 if |x| &lt; |y|;
<li>0 if |x| == |y|;
<li>+1 if |x| &gt; |y|.
</ul>

				
				
				
			
				
				<h3 id="Int.Div">func (*Int) <a href="/src/math/big/int.go?s=8070:8103#L291">Div</a>
					<a class="permalink" href="#Int.Div">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Div(x, y *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Div sets z to the quotient x/y for y != 0 and returns z.
If y == 0, a division-by-zero run-time panic occurs.
Div implements Euclidean division (unlike Go); see <a href="#Int.DivMod">Int.DivMod</a> for more details.

				
				
				
			
				
				<h3 id="Int.DivMod">func (*Int) <a href="/src/math/big/int.go?s=9286:9333#L339">DivMod</a>
					<a class="permalink" href="#Int.DivMod">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) DivMod(x, y, m *<a href="#Int">Int</a>) (*<a href="#Int">Int</a>, *<a href="#Int">Int</a>)</pre>
				<p>DivMod sets z to the quotient x div y and m to the modulus x mod y
and returns the pair (z, m) for y != 0.
If y == 0, a division-by-zero run-time panic occurs.
<p>DivMod implements Euclidean division and modulus (unlike Go):
<pre>q = x div y  such that
m = x - y*q  with 0 &lt;= m &lt; |y|
</pre>
<p>(See Raymond T. Boute, “The Euclidean definition of the functions
div and mod”. ACM Transactions on Programming Languages and
Systems (TOPLAS), 14(2):127-144, New York, NY, USA, 4/1992.
ACM press.)
See <a href="#Int.QuoRem">Int.QuoRem</a> for T-division and modulus (like Go).

				
				
				
			
				
				<h3 id="Int.Exp">func (*Int) <a href="/src/math/big/int.go?s=15333:15369#L550">Exp</a>
					<a class="permalink" href="#Int.Exp">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Exp(x, y, m *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Exp sets z = x**y mod |m| (i.e. the sign of m is ignored), and returns z.
If m == nil or m == 0, z = x**y unless y &lt;= 0 then z = 1. If m != 0, y &lt; 0,
and x and m are not relatively prime, z is unchanged and nil is returned.
<p>Modular exponentiation of inputs of a particular size is not a
cryptographically constant-time operation.

				
				
				
			
				
				<h3 id="Int.FillBytes">func (*Int) <a href="/src/math/big/int.go?s=14358:14400#L522">FillBytes</a>
					<a class="permalink" href="#Int.FillBytes">&#xb6;</a>
					
					<span title="Added in Go 1.15">1.15</span>
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) FillBytes(buf []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>FillBytes sets buf to the absolute value of x, storing it as a zero-extended
big-endian byte slice, and returns buf.
<p>If the absolute value of x doesn&apos;t fit in buf, FillBytes will panic.

				
				
				
			
				
				<h3 id="Int.Float64">func (*Int) <a href="/src/math/big/int.go?s=11324:11367#L442">Float64</a>
					<a class="permalink" href="#Int.Float64">&#xb6;</a>
					
					<span title="Added in Go 1.21">1.21</span>
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) Float64() (<a href="/pkg/builtin/#float64">float64</a>, <a href="#Accuracy">Accuracy</a>)</pre>
				<p>Float64 returns the float64 value nearest x,
and an indication of any rounding that occurred.

				
				
				
			
				
				<h3 id="Int.Format">func (*Int) <a href="/src/math/big/intconv.go?s=2003:2045#L56">Format</a>
					<a class="permalink" href="#Int.Format">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) Format(s <a href="/pkg/fmt/">fmt</a>.<a href="/pkg/fmt/#State">State</a>, ch <a href="/pkg/builtin/#rune">rune</a>)</pre>
				<p>Format implements <a href="/fmt#Formatter">fmt.Formatter</a>. It accepts the formats
&apos;b&apos; (binary), &apos;o&apos; (octal with 0 prefix), &apos;O&apos; (octal with 0o prefix),
&apos;d&apos; (decimal), &apos;x&apos; (lowercase hexadecimal), and
&apos;X&apos; (uppercase hexadecimal).
Also supported are the full suite of package fmt&apos;s format
flags for integral types, including &apos;+&apos; and &apos; &apos; for sign
control, &apos;#&apos; for leading zero in octal and for hexadecimal,
a leading &quot;0x&quot; or &quot;0X&quot; for &quot;%#x&quot; and &quot;%#X&quot; respectively,
specification of minimum digits precision, output field
width, space or zero padding, and &apos;-&apos; for left or right
justification.

				
				
				
			
				
				<h3 id="Int.GCD">func (*Int) <a href="/src/math/big/int.go?s=16765:16804#L604">GCD</a>
					<a class="permalink" href="#Int.GCD">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) GCD(x, y, a, b *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>GCD sets z to the greatest common divisor of a and b and returns z.
If x or y are not nil, GCD sets their value such that z = a*x + b*y.
<p>a and b may be positive, zero or negative. (Before Go 1.14 both had
to be &gt; 0.) Regardless of the signs of a and b, z is always &gt;= 0.
<p>If a == b == 0, GCD sets z = x = y = 0.
<p>If a == 0 and b != 0, GCD sets z = |b|, x = 0, y = sign(b) * 1.
<p>If a != 0 and b == 0, GCD sets z = |a|, x = sign(a) * 1, y = 0.

				
				
				
			
				
				<h3 id="Int.GobDecode">func (*Int) <a href="/src/math/big/intmarsh.go?s=818:859#L23">GobDecode</a>
					<a class="permalink" href="#Int.GobDecode">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) GobDecode(buf []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>GobDecode implements the <a href="/encoding/gob#GobDecoder">encoding/gob.GobDecoder</a> interface.

				
				
				
			
				
				<h3 id="Int.GobEncode">func (*Int) <a href="/src/math/big/intmarsh.go?s=423:464#L8">GobEncode</a>
					<a class="permalink" href="#Int.GobEncode">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) GobEncode() ([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>GobEncode implements the <a href="/encoding/gob#GobEncoder">encoding/gob.GobEncoder</a> interface.

				
				
				
			
				
				<h3 id="Int.Int64">func (*Int) <a href="/src/math/big/int.go?s=10621:10648#L412">Int64</a>
					<a class="permalink" href="#Int.Int64">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) Int64() <a href="/pkg/builtin/#int64">int64</a></pre>
				<p>Int64 returns the int64 representation of x.
If x cannot be represented in an int64, the result is undefined.

				
				
				
			
				
				<h3 id="Int.IsInt64">func (*Int) <a href="/src/math/big/int.go?s=10949:10977#L427">IsInt64</a>
					<a class="permalink" href="#Int.IsInt64">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) IsInt64() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsInt64 reports whether x can be represented as an int64.

				
				
				
			
				
				<h3 id="Int.IsUint64">func (*Int) <a href="/src/math/big/int.go?s=11151:11180#L436">IsUint64</a>
					<a class="permalink" href="#Int.IsUint64">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) IsUint64() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsUint64 reports whether x can be represented as a uint64.

				
				
				
			
				
				<h3 id="Int.Lsh">func (*Int) <a href="/src/math/big/int.go?s=29009:29047#L1096">Lsh</a>
					<a class="permalink" href="#Int.Lsh">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Lsh(x *<a href="#Int">Int</a>, n <a href="/pkg/builtin/#uint">uint</a>) *<a href="#Int">Int</a></pre>
				<p>Lsh sets z = x &lt;&lt; n and returns z.

				
				
				
			
				
				<h3 id="Int.MarshalJSON">func (*Int) <a href="/src/math/big/intmarsh.go?s=1868:1911#L59">MarshalJSON</a>
					<a class="permalink" href="#Int.MarshalJSON">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) MarshalJSON() ([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>MarshalJSON implements the <a href="/encoding/json#Marshaler">encoding/json.Marshaler</a> interface.

				
				
				
			
				
				<h3 id="Int.MarshalText">func (*Int) <a href="/src/math/big/intmarsh.go?s=1210:1262#L39">MarshalText</a>
					<a class="permalink" href="#Int.MarshalText">&#xb6;</a>
					
					<span title="Added in Go 1.3">1.3</span>
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) MarshalText() (text []<a href="/pkg/builtin/#byte">byte</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>MarshalText implements the <a href="/encoding#TextMarshaler">encoding.TextMarshaler</a> interface.

				
				
				
			
				
				<h3 id="Int.Mod">func (*Int) <a href="/src/math/big/int.go?s=8475:8508#L308">Mod</a>
					<a class="permalink" href="#Int.Mod">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Mod(x, y *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Mod sets z to the modulus x%y for y != 0 and returns z.
If y == 0, a division-by-zero run-time panic occurs.
Mod implements Euclidean modulus (unlike Go); see <a href="#Int.DivMod">Int.DivMod</a> for more details.

				
				
				
			
				
				<h3 id="Int.ModInverse">func (*Int) <a href="/src/math/big/int.go?s=23913:23953#L887">ModInverse</a>
					<a class="permalink" href="#Int.ModInverse">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) ModInverse(g, n *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>ModInverse sets z to the multiplicative inverse of g in the ring ℤ/nℤ
and returns z. If g and n are not relatively prime, g has no multiplicative
inverse in the ring ℤ/nℤ.  In this case, z is unchanged and the return value
is nil. If n == 0, a division-by-zero run-time panic occurs.

				
				
				
			
				
				<h3 id="Int.ModSqrt">func (*Int) <a href="/src/math/big/int.go?s=28364:28401#L1069">ModSqrt</a>
					<a class="permalink" href="#Int.ModSqrt">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) ModSqrt(x, p *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>ModSqrt sets z to a square root of x mod p if such a square root exists, and
returns z. The modulus p must be an odd prime. If x is not a square mod p,
ModSqrt leaves z unchanged and returns nil. This function panics if p is
not an odd integer, its behavior is undefined if p is odd but not prime.

				
				
				
			
				
				<h3 id="Int.Mul">func (*Int) <a href="/src/math/big/int.go?s=4841:4874#L173">Mul</a>
					<a class="permalink" href="#Int.Mul">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Mul(x, y *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Mul sets z to the product x*y and returns z.

				
				
				
			
				
				<h3 id="Int.MulRange">func (*Int) <a href="/src/math/big/int.go?s=5290:5329#L191">MulRange</a>
					<a class="permalink" href="#Int.MulRange">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) MulRange(a, b <a href="/pkg/builtin/#int64">int64</a>) *<a href="#Int">Int</a></pre>
				<p>MulRange sets z to the product of all integers
in the range [a, b] inclusively and returns z.
If a &gt; b (empty range), the result is 1.

				
				
				
			
				
				<h3 id="Int.Neg">func (*Int) <a href="/src/math/big/int.go?s=3739:3769#L124">Neg</a>
					<a class="permalink" href="#Int.Neg">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Neg(x *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Neg sets z to -x and returns z.

				
				
				
			
				
				<h3 id="Int.Not">func (*Int) <a href="/src/math/big/int.go?s=33458:33488#L1284">Not</a>
					<a class="permalink" href="#Int.Not">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Not(x *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Not sets z = ^x and returns z.

				
				
				
			
				
				<h3 id="Int.Or">func (*Int) <a href="/src/math/big/int.go?s=32011:32043#L1224">Or</a>
					<a class="permalink" href="#Int.Or">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Or(x, y *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Or sets z = x | y and returns z.

				
				
				
			
				
				<h3 id="Int.ProbablyPrime">func (*Int) <a href="/src/math/big/prime.go?s=1085:1124#L16">ProbablyPrime</a>
					<a class="permalink" href="#Int.ProbablyPrime">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) ProbablyPrime(n <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>ProbablyPrime reports whether x is probably prime,
applying the Miller-Rabin test with n pseudorandomly chosen bases
as well as a Baillie-PSW test.
<p>If x is prime, ProbablyPrime returns true.
If x is chosen randomly and not prime, ProbablyPrime probably returns false.
The probability of returning true for a randomly chosen non-prime is at most ¼ⁿ.
<p>ProbablyPrime is 100% accurate for inputs less than 2⁶⁴.
See Menezes et al., Handbook of Applied Cryptography, 1997, pp. 145-149,
and FIPS 186-4 Appendix F for further discussion of the error probabilities.
<p>ProbablyPrime is not suitable for judging primes that an adversary may
have crafted to fool the test.
<p>As of Go 1.8, ProbablyPrime(0) is allowed and applies only a Baillie-PSW test.
Before Go 1.8, ProbablyPrime applied only the Miller-Rabin tests, and ProbablyPrime(0) panicked.

				
				
				
			
				
				<h3 id="Int.Quo">func (*Int) <a href="/src/math/big/int.go?s=6742:6775#L256">Quo</a>
					<a class="permalink" href="#Int.Quo">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Quo(x, y *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Quo sets z to the quotient x/y for y != 0 and returns z.
If y == 0, a division-by-zero run-time panic occurs.
Quo implements truncated division (like Go); see <a href="#Int.QuoRem">Int.QuoRem</a> for more details.

				
				
				
			
				
				<h3 id="Int.QuoRem">func (*Int) <a href="/src/math/big/int.go?s=7665:7712#L282">QuoRem</a>
					<a class="permalink" href="#Int.QuoRem">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) QuoRem(x, y, r *<a href="#Int">Int</a>) (*<a href="#Int">Int</a>, *<a href="#Int">Int</a>)</pre>
				<p>QuoRem sets z to the quotient x/y and r to the remainder x%y
and returns the pair (z, r) for y != 0.
If y == 0, a division-by-zero run-time panic occurs.
<p>QuoRem implements T-division and modulus (like Go):
<pre>q = x/y      with the result truncated to zero
r = x - y*q
</pre>
<p>(See Daan Leijen, “Division and Modulus for Computer Scientists”.)
See [DivMod] for Euclidean division and modulus (unlike Go).

				
				
				
			
				
				<h3 id="Int.Rand">func (*Int) <a href="/src/math/big/int.go?s=23330:23377#L871">Rand</a>
					<a class="permalink" href="#Int.Rand">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Rand(rnd *<a href="/pkg/math/rand/">rand</a>.<a href="/pkg/math/rand/#Rand">Rand</a>, n *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Rand sets z to a pseudo-random number in [0, n) and returns z.
<p>As this uses the <a href="/math/rand">math/rand</a> package, it must not be used for
security-sensitive work. Use <a href="/crypto/rand#Int">crypto/rand.Int</a> instead.

				
				
				
			
				
				<h3 id="Int.Rem">func (*Int) <a href="/src/math/big/int.go?s=7090:7123#L265">Rem</a>
					<a class="permalink" href="#Int.Rem">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Rem(x, y *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Rem sets z to the remainder x%y for y != 0 and returns z.
If y == 0, a division-by-zero run-time panic occurs.
Rem implements truncated modulus (like Go); see <a href="#Int.QuoRem">Int.QuoRem</a> for more details.

				
				
				
			
				
				<h3 id="Int.Rsh">func (*Int) <a href="/src/math/big/int.go?s=29145:29183#L1103">Rsh</a>
					<a class="permalink" href="#Int.Rsh">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Rsh(x *<a href="#Int">Int</a>, n <a href="/pkg/builtin/#uint">uint</a>) *<a href="#Int">Int</a></pre>
				<p>Rsh sets z = x &gt;&gt; n and returns z.

				
				
				
			
				
				<h3 id="Int.Scan">func (*Int) <a href="/src/math/big/intconv.go?s=6472:6522#L226">Scan</a>
					<a class="permalink" href="#Int.Scan">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Scan(s <a href="/pkg/fmt/">fmt</a>.<a href="/pkg/fmt/#ScanState">ScanState</a>, ch <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>Scan is a support routine for <a href="/fmt#Scanner">fmt.Scanner</a>; it sets z to the value of
the scanned number. It accepts the formats &apos;b&apos; (binary), &apos;o&apos; (octal),
&apos;d&apos; (decimal), &apos;x&apos; (lowercase hexadecimal), and &apos;X&apos; (uppercase hexadecimal).

				
				<div id="example_Int_Scan" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// The Scan function is rarely used directly;</span>
<span class="comment">// the fmt package recognizes it as an implementation of fmt.Scanner.</span>
i := new(big.Int)
_, err := fmt.Sscan(&#34;18446744073709551617&#34;, i)
if err != nil {
    log.Println(&#34;error scanning value:&#34;, err)
} else {
    fmt.Println(i)
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">18446744073709551617
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Int.Set">func (*Int) <a href="/src/math/big/int.go?s=2458:2488#L85">Set</a>
					<a class="permalink" href="#Int.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Set(x *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Set sets z to x and returns z.

				
				
				
			
				
				<h3 id="Int.SetBit">func (*Int) <a href="/src/math/big/int.go?s=30172:30220#L1144">SetBit</a>
					<a class="permalink" href="#Int.SetBit">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) SetBit(x *<a href="#Int">Int</a>, i <a href="/pkg/builtin/#int">int</a>, b <a href="/pkg/builtin/#uint">uint</a>) *<a href="#Int">Int</a></pre>
				<p>SetBit sets z to x, with x&apos;s i&apos;th bit set to b (0 or 1).
That is,
<ul>
<li>if b is 1, SetBit sets z = x | (1 &lt;&lt; i);
<li>if b is 0, SetBit sets z = x &amp;^ (1 &lt;&lt; i);
<li>if b is not 0 or 1, SetBit will panic.
</ul>

				
				
				
			
				
				<h3 id="Int.SetBits">func (*Int) <a href="/src/math/big/int.go?s=3477:3515#L110">SetBits</a>
					<a class="permalink" href="#Int.SetBits">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) SetBits(abs []<a href="#Word">Word</a>) *<a href="#Int">Int</a></pre>
				<p>SetBits provides raw (unchecked but fast) access to z by setting its
value to abs, interpreted as a little-endian <a href="#Word">Word</a> slice, and returning
z. The result and abs share the same underlying array.
SetBits is intended to support implementation of missing low-level <a href="#Int">Int</a>
functionality outside this package; it should be avoided otherwise.

				
				
				
			
				
				<h3 id="Int.SetBytes">func (*Int) <a href="/src/math/big/int.go?s=13617:13656#L501">SetBytes</a>
					<a class="permalink" href="#Int.SetBytes">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) SetBytes(buf []<a href="/pkg/builtin/#byte">byte</a>) *<a href="#Int">Int</a></pre>
				<p>SetBytes interprets buf as the bytes of a big-endian unsigned
integer, sets z to that value, and returns z.

				
				
				
			
				
				<h3 id="Int.SetInt64">func (*Int) <a href="/src/math/big/int.go?s=1727:1763#L48">SetInt64</a>
					<a class="permalink" href="#Int.SetInt64">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) SetInt64(x <a href="/pkg/builtin/#int64">int64</a>) *<a href="#Int">Int</a></pre>
				<p>SetInt64 sets z to x and returns z.

				
				
				
			
				
				<h3 id="Int.SetString">func (*Int) <a href="/src/math/big/int.go?s=12954:13010#L482">SetString</a>
					<a class="permalink" href="#Int.SetString">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) SetString(s <a href="/pkg/builtin/#string">string</a>, base <a href="/pkg/builtin/#int">int</a>) (*<a href="#Int">Int</a>, <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>SetString sets z to the value of s, interpreted in the given base,
and returns z and a boolean indicating success. The entire string
(not just a prefix) must be valid for success. If SetString fails,
the value of z is undefined but the returned value is nil.
<p>The base argument must be 0 or a value between 2 and <a href="#MaxBase">MaxBase</a>.
For base 0, the number prefix determines the actual base: A prefix of
“0b” or “0B” selects base 2, “0”, “0o” or “0O” selects base 8,
and “0x” or “0X” selects base 16. Otherwise, the selected base is 10
and no prefix is accepted.
<p>For bases &lt;= 36, lower and upper case letters are considered the same:
The letters &apos;a&apos; to &apos;z&apos; and &apos;A&apos; to &apos;Z&apos; represent digit values 10 to 35.
For bases &gt; 36, the upper case letters &apos;A&apos; to &apos;Z&apos; represent the digit
values 36 to 61.
<p>For base 0, an underscore character “_” may appear between a base
prefix and an adjacent digit, and between successive digits; such
underscores do not change the value of the number.
Incorrect placement of underscores is reported as an error if there
are no other errors. If base != 0, underscores are not recognized
and act like any other character that is not a valid digit.

				
				<div id="example_Int_SetString" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">i := new(big.Int)
i.SetString(&#34;644&#34;, 8) <span class="comment">// octal</span>
fmt.Println(i)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">420
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Int.SetUint64">func (*Int) <a href="/src/math/big/int.go?s=1919:1957#L60">SetUint64</a>
					<a class="permalink" href="#Int.SetUint64">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) SetUint64(x <a href="/pkg/builtin/#uint64">uint64</a>) *<a href="#Int">Int</a></pre>
				<p>SetUint64 sets z to x and returns z.

				
				
				
			
				
				<h3 id="Int.Sign">func (*Int) <a href="/src/math/big/int.go?s=1390:1414#L34">Sign</a>
					<a class="permalink" href="#Int.Sign">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) Sign() <a href="/pkg/builtin/#int">int</a></pre>
				<p>Sign returns:
<ul>
<li>-1 if x &lt; 0;
<li>0 if x == 0;
<li>+1 if x &gt; 0.
</ul>

				
				
				
			
				
				<h3 id="Int.Sqrt">func (*Int) <a href="/src/math/big/int.go?s=33840:33871#L1300">Sqrt</a>
					<a class="permalink" href="#Int.Sqrt">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Sqrt(x *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Sqrt sets z to ⌊√x⌋, the largest integer such that z² ≤ x, and returns z.
It panics if x is negative.

				
				
				
			
				
				<h3 id="Int.String">func (*Int) <a href="/src/math/big/intconv.go?s=1099:1128#L29">String</a>
					<a class="permalink" href="#Int.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>String returns the decimal representation of x as generated by
x.Text(10).

				
				
				
			
				
				<h3 id="Int.Sub">func (*Int) <a href="/src/math/big/int.go?s=4367:4400#L152">Sub</a>
					<a class="permalink" href="#Int.Sub">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Sub(x, y *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Sub sets z to the difference x-y and returns z.

				
				
				
			
				
				<h3 id="Int.Text">func (*Int) <a href="/src/math/big/intconv.go?s=625:660#L11">Text</a>
					<a class="permalink" href="#Int.Text">&#xb6;</a>
					
					<span title="Added in Go 1.6">1.6</span>
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) Text(base <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#string">string</a></pre>
				<p>Text returns the string representation of x in the given base.
Base must be between 2 and 62, inclusive. The result uses the
lower-case letters &apos;a&apos; to &apos;z&apos; for digit values 10 to 35, and
the upper-case letters &apos;A&apos; to &apos;Z&apos; for digit values 36 to 61.
No prefix (such as &quot;0x&quot;) is added to the string. If x is a nil
pointer it returns &quot;&lt;nil&gt;&quot;.

				
				
				
			
				
				<h3 id="Int.TrailingZeroBits">func (*Int) <a href="/src/math/big/int.go?s=14909:14946#L540">TrailingZeroBits</a>
					<a class="permalink" href="#Int.TrailingZeroBits">&#xb6;</a>
					
					<span title="Added in Go 1.13">1.13</span>
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) TrailingZeroBits() <a href="/pkg/builtin/#uint">uint</a></pre>
				<p>TrailingZeroBits returns the number of consecutive least significant zero
bits of |x|.

				
				
				
			
				
				<h3 id="Int.Uint64">func (*Int) <a href="/src/math/big/int.go?s=10832:10861#L422">Uint64</a>
					<a class="permalink" href="#Int.Uint64">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (x *<a href="#Int">Int</a>) Uint64() <a href="/pkg/builtin/#uint64">uint64</a></pre>
				<p>Uint64 returns the uint64 representation of x.
If x cannot be represented in a uint64, the result is undefined.

				
				
				
			
				
				<h3 id="Int.UnmarshalJSON">func (*Int) <a href="/src/math/big/intmarsh.go?s=2070:2116#L67">UnmarshalJSON</a>
					<a class="permalink" href="#Int.UnmarshalJSON">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) UnmarshalJSON(text []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>UnmarshalJSON implements the <a href="/encoding/json#Unmarshaler">encoding/json.Unmarshaler</a> interface.

				
				
				
			
				
				<h3 id="Int.UnmarshalText">func (*Int) <a href="/src/math/big/intmarsh.go?s=1421:1467#L47">UnmarshalText</a>
					<a class="permalink" href="#Int.UnmarshalText">&#xb6;</a>
					
					<span title="Added in Go 1.3">1.3</span>
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) UnmarshalText(text []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>UnmarshalText implements the <a href="/encoding#TextUnmarshaler">encoding.TextUnmarshaler</a> interface.

				
				
				
			
				
				<h3 id="Int.Xor">func (*Int) <a href="/src/math/big/int.go?s=32781:32814#L1254">Xor</a>
					<a class="permalink" href="#Int.Xor">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Int">Int</a>) Xor(x, y *<a href="#Int">Int</a>) *<a href="#Int">Int</a></pre>
				<p>Xor sets z = x ^ y and returns z.

				
				
				
			
		
			
			
			<h2 id="Rat">type <a href="/src/math/big/rat.go?s=707:1030#L13">Rat</a>
				<a class="permalink" href="#Rat">&#xb6;</a>
				
				
			</h2>
			<p>A Rat represents a quotient a/b of arbitrary precision.
The zero value for a Rat represents the value 0.
<p>Operations always take pointer arguments (*Rat) rather
than Rat values, and each unique Rat value requires
its own unique *Rat pointer. To &quot;copy&quot; a Rat value,
an existing (or newly allocated) Rat must be set to
a new value using the <a href="#Rat.Set">Rat.Set</a> method; shallow copies
of Rats are not supported and may lead to errors.

			<pre>type Rat struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewRat">func <a href="/src/math/big/rat.go?s=1098:1126#L23">NewRat</a>
					<a class="permalink" href="#NewRat">&#xb6;</a>
					
					
				</h3>
				<pre>func NewRat(a, b <a href="/pkg/builtin/#int64">int64</a>) *<a href="#Rat">Rat</a></pre>
				<p>NewRat creates a new <a href="#Rat">Rat</a> with numerator a and denominator b.

				
				
			

			
				
				<h3 id="Rat.Abs">func (*Rat) <a href="/src/math/big/rat.go?s=9565:9595#L356">Abs</a>
					<a class="permalink" href="#Rat.Abs">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) Abs(x *<a href="#Rat">Rat</a>) *<a href="#Rat">Rat</a></pre>
				<p>Abs sets z to |x| (the absolute value of x) and returns z.

				
				
				
			
				
				<h3 id="Rat.Add">func (*Rat) <a href="/src/math/big/rat.go?s=12623:12656#L480">Add</a>
					<a class="permalink" href="#Rat.Add">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) Add(x, y *<a href="#Rat">Rat</a>) *<a href="#Rat">Rat</a></pre>
				<p>Add sets z to the sum x+y and returns z.

				
				
				
			
				
				<h3 id="Rat.Cmp">func (*Rat) <a href="/src/math/big/rat.go?s=12454:12483#L472">Cmp</a>
					<a class="permalink" href="#Rat.Cmp">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Rat">Rat</a>) Cmp(y *<a href="#Rat">Rat</a>) <a href="/pkg/builtin/#int">int</a></pre>
				<p>Cmp compares x and y and returns:
<ul>
<li>-1 if x &lt; y;
<li>0 if x == y;
<li>+1 if x &gt; y.
</ul>

				
				
				
			
				
				<h3 id="Rat.Denom">func (*Rat) <a href="/src/math/big/rat.go?s=10933:10959#L408">Denom</a>
					<a class="permalink" href="#Rat.Denom">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Rat">Rat</a>) Denom() *<a href="#Int">Int</a></pre>
				<p>Denom returns the denominator of x; it is always &gt; 0.
The result is a reference to x&apos;s denominator, unless
x is an uninitialized (zero value) <a href="#Rat">Rat</a>, in which case
the result is a new <a href="#Int">Int</a> of value 1. (To initialize x,
any operation that sets x will do, including x.Set(x).)
If the result is a reference to x&apos;s denominator it
may change if a new value is assigned to x, and vice versa.

				
				
				
			
				
				<h3 id="Rat.Float32">func (*Rat) <a href="/src/math/big/rat.go?s=7586:7633#L263">Float32</a>
					<a class="permalink" href="#Rat.Float32">&#xb6;</a>
					
					<span title="Added in Go 1.4">1.4</span>
				</h3>
				<pre>func (x *<a href="#Rat">Rat</a>) Float32() (f <a href="/pkg/builtin/#float32">float32</a>, exact <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>Float32 returns the nearest float32 value for x and a bool indicating
whether f represents x exactly. If the magnitude of x is too large to
be represented by a float32, f is an infinity and exact is false.
The sign of f always matches the sign of x, even if f == 0.

				
				
				
			
				
				<h3 id="Rat.Float64">func (*Rat) <a href="/src/math/big/rat.go?s=8037:8084#L279">Float64</a>
					<a class="permalink" href="#Rat.Float64">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (x *<a href="#Rat">Rat</a>) Float64() (f <a href="/pkg/builtin/#float64">float64</a>, exact <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>Float64 returns the nearest float64 value for x and a bool indicating
whether f represents x exactly. If the magnitude of x is too large to
be represented by a float64, f is an infinity and exact is false.
The sign of f always matches the sign of x, even if f == 0.

				
				
				
			
				
				<h3 id="Rat.FloatPrec">func (*Rat) <a href="/src/math/big/ratconv.go?s=10730:10775#L389">FloatPrec</a>
					<a class="permalink" href="#Rat.FloatPrec">&#xb6;</a>
					
					<span title="Added in Go 1.22">1.22</span>
				</h3>
				<pre>func (x *<a href="#Rat">Rat</a>) FloatPrec() (n <a href="/pkg/builtin/#int">int</a>, exact <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>FloatPrec returns the number n of non-repeating digits immediately
following the decimal point of the decimal representation of x.
The boolean result indicates whether a decimal representation of x
with that many fractional digits is exact or rounded.
<p>Examples:
<pre>x      n    exact    decimal representation n fractional digits
0      0    true     0
1      0    true     1
1/2    1    true     0.5
1/3    0    false    0       (0.333... rounded)
1/4    2    true     0.25
1/6    1    false    0.2     (0.166... rounded)
</pre>

				
				
				
			
				
				<h3 id="Rat.FloatString">func (*Rat) <a href="/src/math/big/ratconv.go?s=9077:9119#L320">FloatString</a>
					<a class="permalink" href="#Rat.FloatString">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Rat">Rat</a>) FloatString(prec <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#string">string</a></pre>
				<p>FloatString returns a string representation of x in decimal form with prec
digits of precision after the radix point. The last digit is rounded to
nearest, with halves rounded away from zero.

				
				
				
			
				
				<h3 id="Rat.GobDecode">func (*Rat) <a href="/src/math/big/ratmarsh.go?s=1086:1127#L33">GobDecode</a>
					<a class="permalink" href="#Rat.GobDecode">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) GobDecode(buf []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>GobDecode implements the <a href="/encoding/gob#GobDecoder">encoding/gob.GobDecoder</a> interface.

				
				
				
			
				
				<h3 id="Rat.GobEncode">func (*Rat) <a href="/src/math/big/ratmarsh.go?s=454:495#L10">GobEncode</a>
					<a class="permalink" href="#Rat.GobEncode">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Rat">Rat</a>) GobEncode() ([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>GobEncode implements the <a href="/encoding/gob#GobEncoder">encoding/gob.GobEncoder</a> interface.

				
				
				
			
				
				<h3 id="Rat.Inv">func (*Rat) <a href="/src/math/big/rat.go?s=9848:9878#L371">Inv</a>
					<a class="permalink" href="#Rat.Inv">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) Inv(x *<a href="#Rat">Rat</a>) *<a href="#Rat">Rat</a></pre>
				<p>Inv sets z to 1/x and returns z.
If x == 0, Inv panics.

				
				
				
			
				
				<h3 id="Rat.IsInt">func (*Rat) <a href="/src/math/big/rat.go?s=10174:10200#L389">IsInt</a>
					<a class="permalink" href="#Rat.IsInt">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Rat">Rat</a>) IsInt() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsInt reports whether the denominator of x is 1.

				
				
				
			
				
				<h3 id="Rat.MarshalText">func (*Rat) <a href="/src/math/big/ratmarsh.go?s=1840:1892#L62">MarshalText</a>
					<a class="permalink" href="#Rat.MarshalText">&#xb6;</a>
					
					<span title="Added in Go 1.3">1.3</span>
				</h3>
				<pre>func (x *<a href="#Rat">Rat</a>) MarshalText() (text []<a href="/pkg/builtin/#byte">byte</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>MarshalText implements the <a href="/encoding#TextMarshaler">encoding.TextMarshaler</a> interface.

				
				
				
			
				
				<h3 id="Rat.Mul">func (*Rat) <a href="/src/math/big/rat.go?s=13118:13151#L500">Mul</a>
					<a class="permalink" href="#Rat.Mul">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) Mul(x, y *<a href="#Rat">Rat</a>) *<a href="#Rat">Rat</a></pre>
				<p>Mul sets z to the product x*y and returns z.

				
				
				
			
				
				<h3 id="Rat.Neg">func (*Rat) <a href="/src/math/big/rat.go?s=9673:9703#L363">Neg</a>
					<a class="permalink" href="#Rat.Neg">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) Neg(x *<a href="#Rat">Rat</a>) *<a href="#Rat">Rat</a></pre>
				<p>Neg sets z to -x and returns z.

				
				
				
			
				
				<h3 id="Rat.Num">func (*Rat) <a href="/src/math/big/rat.go?s=10483:10507#L397">Num</a>
					<a class="permalink" href="#Rat.Num">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Rat">Rat</a>) Num() *<a href="#Int">Int</a></pre>
				<p>Num returns the numerator of x; it may be &lt;= 0.
The result is a reference to x&apos;s numerator; it
may change if a new value is assigned to x, and vice versa.
The sign of the numerator corresponds to the sign of x.

				
				
				
			
				
				<h3 id="Rat.Quo">func (*Rat) <a href="/src/math/big/rat.go?s=13578:13611#L519">Quo</a>
					<a class="permalink" href="#Rat.Quo">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) Quo(x, y *<a href="#Rat">Rat</a>) *<a href="#Rat">Rat</a></pre>
				<p>Quo sets z to the quotient x/y and returns z.
If y == 0, Quo panics.

				
				
				
			
				
				<h3 id="Rat.RatString">func (*Rat) <a href="/src/math/big/ratconv.go?s=8778:8810#L310">RatString</a>
					<a class="permalink" href="#Rat.RatString">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Rat">Rat</a>) RatString() <a href="/pkg/builtin/#string">string</a></pre>
				<p>RatString returns a string representation of x in the form &quot;a/b&quot; if b != 1,
and in the form &quot;a&quot; if b == 1.

				
				
				
			
				
				<h3 id="Rat.Scan">func (*Rat) <a href="/src/math/big/ratconv.go?s=595:645#L16">Scan</a>
					<a class="permalink" href="#Rat.Scan">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) Scan(s <a href="/pkg/fmt/">fmt</a>.<a href="/pkg/fmt/#ScanState">ScanState</a>, ch <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>Scan is a support routine for fmt.Scanner. It accepts the formats
&apos;e&apos;, &apos;E&apos;, &apos;f&apos;, &apos;F&apos;, &apos;g&apos;, &apos;G&apos;, and &apos;v&apos;. All formats are equivalent.

				
				<div id="example_Rat_Scan" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// The Scan function is rarely used directly;</span>
<span class="comment">// the fmt package recognizes it as an implementation of fmt.Scanner.</span>
r := new(big.Rat)
_, err := fmt.Sscan(&#34;1.5000&#34;, r)
if err != nil {
    log.Println(&#34;error scanning value:&#34;, err)
} else {
    fmt.Println(r)
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">3/2
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Rat.Set">func (*Rat) <a href="/src/math/big/rat.go?s=9351:9381#L344">Set</a>
					<a class="permalink" href="#Rat.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) Set(x *<a href="#Rat">Rat</a>) *<a href="#Rat">Rat</a></pre>
				<p>Set sets z to x (by making a copy of x) and returns z.

				
				
				
			
				
				<h3 id="Rat.SetFloat64">func (*Rat) <a href="/src/math/big/rat.go?s=1259:1299#L29">SetFloat64</a>
					<a class="permalink" href="#Rat.SetFloat64">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) SetFloat64(f <a href="/pkg/builtin/#float64">float64</a>) *<a href="#Rat">Rat</a></pre>
				<p>SetFloat64 sets z to exactly f and returns z.
If f is not finite, SetFloat returns nil.

				
				
				
			
				
				<h3 id="Rat.SetFrac">func (*Rat) <a href="/src/math/big/rat.go?s=8280:8317#L293">SetFrac</a>
					<a class="permalink" href="#Rat.SetFrac">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) SetFrac(a, b *<a href="#Int">Int</a>) *<a href="#Rat">Rat</a></pre>
				<p>SetFrac sets z to a/b and returns z.
If b == 0, SetFrac panics.

				
				
				
			
				
				<h3 id="Rat.SetFrac64">func (*Rat) <a href="/src/math/big/rat.go?s=8652:8692#L309">SetFrac64</a>
					<a class="permalink" href="#Rat.SetFrac64">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) SetFrac64(a, b <a href="/pkg/builtin/#int64">int64</a>) *<a href="#Rat">Rat</a></pre>
				<p>SetFrac64 sets z to a/b and returns z.
If b == 0, SetFrac64 panics.

				
				
				
			
				
				<h3 id="Rat.SetInt">func (*Rat) <a href="/src/math/big/rat.go?s=8922:8955#L323">SetInt</a>
					<a class="permalink" href="#Rat.SetInt">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) SetInt(x *<a href="#Int">Int</a>) *<a href="#Rat">Rat</a></pre>
				<p>SetInt sets z to x (by making a copy of x) and returns z.

				
				
				
			
				
				<h3 id="Rat.SetInt64">func (*Rat) <a href="/src/math/big/rat.go?s=9052:9088#L330">SetInt64</a>
					<a class="permalink" href="#Rat.SetInt64">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) SetInt64(x <a href="/pkg/builtin/#int64">int64</a>) *<a href="#Rat">Rat</a></pre>
				<p>SetInt64 sets z to x and returns z.

				
				
				
			
				
				<h3 id="Rat.SetString">func (*Rat) <a href="/src/math/big/ratconv.go?s=2220:2266#L48">SetString</a>
					<a class="permalink" href="#Rat.SetString">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) SetString(s <a href="/pkg/builtin/#string">string</a>) (*<a href="#Rat">Rat</a>, <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>SetString sets z to the value of s and returns z and a boolean indicating
success. s can be given as a (possibly signed) fraction &quot;a/b&quot;, or as a
floating-point number optionally followed by an exponent.
If a fraction is provided, both the dividend and the divisor may be a
decimal integer or independently use a prefix of “0b”, “0” or “0o”,
or “0x” (or their upper-case variants) to denote a binary, octal, or
hexadecimal integer, respectively. The divisor may not be signed.
If a floating-point number is provided, it may be in decimal form or
use any of the same prefixes as above but for “0” to denote a non-decimal
mantissa. A leading “0” is considered a decimal leading 0; it does not
indicate octal representation in this case.
An optional base-10 “e” or base-2 “p” (or their upper-case variants)
exponent may be provided as well, except for hexadecimal floats which
only accept an (optional) “p” exponent (because an “e” or “E” cannot
be distinguished from a mantissa digit). If the exponent&apos;s absolute value
is too large, the operation may fail.
The entire string, not just a prefix, must be valid for success. If the
operation failed, the value of z is undefined but the returned value is nil.

				
				<div id="example_Rat_SetString" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">r := new(big.Rat)
r.SetString(&#34;355/113&#34;)
fmt.Println(r.FloatString(3))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">3.142
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Rat.SetUint64">func (*Rat) <a href="/src/math/big/rat.go?s=9191:9229#L337">SetUint64</a>
					<a class="permalink" href="#Rat.SetUint64">&#xb6;</a>
					
					<span title="Added in Go 1.13">1.13</span>
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) SetUint64(x <a href="/pkg/builtin/#uint64">uint64</a>) *<a href="#Rat">Rat</a></pre>
				<p>SetUint64 sets z to x and returns z.

				
				
				
			
				
				<h3 id="Rat.Sign">func (*Rat) <a href="/src/math/big/rat.go?s=10073:10097#L384">Sign</a>
					<a class="permalink" href="#Rat.Sign">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Rat">Rat</a>) Sign() <a href="/pkg/builtin/#int">int</a></pre>
				<p>Sign returns:
<ul>
<li>-1 if x &lt; 0;
<li>0 if x == 0;
<li>+1 if x &gt; 0.
</ul>

				
				
				
			
				
				<h3 id="Rat.String">func (*Rat) <a href="/src/math/big/ratconv.go?s=8341:8370#L291">String</a>
					<a class="permalink" href="#Rat.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Rat">Rat</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>String returns a string representation of x in the form &quot;a/b&quot; (even if b == 1).

				
				
				
			
				
				<h3 id="Rat.Sub">func (*Rat) <a href="/src/math/big/rat.go?s=12872:12905#L490">Sub</a>
					<a class="permalink" href="#Rat.Sub">&#xb6;</a>
					
					
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) Sub(x, y *<a href="#Rat">Rat</a>) *<a href="#Rat">Rat</a></pre>
				<p>Sub sets z to the difference x-y and returns z.

				
				
				
			
				
				<h3 id="Rat.UnmarshalText">func (*Rat) <a href="/src/math/big/ratmarsh.go?s=2039:2085#L70">UnmarshalText</a>
					<a class="permalink" href="#Rat.UnmarshalText">&#xb6;</a>
					
					<span title="Added in Go 1.3">1.3</span>
				</h3>
				<pre>func (z *<a href="#Rat">Rat</a>) UnmarshalText(text []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>UnmarshalText implements the <a href="/encoding#TextUnmarshaler">encoding.TextUnmarshaler</a> interface.

				
				
				
			
		
			
			
			<h2 id="RoundingMode">type <a href="/src/math/big/float.go?s=5206:5228#L122">RoundingMode</a>
				<a class="permalink" href="#RoundingMode">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<p>RoundingMode determines how a <a href="#Float">Float</a> value is rounded to the
desired precision. Rounding may change the <a href="#Float">Float</a> value; the
rounding error is described by the <a href="#Float">Float</a>&apos;s <a href="#Accuracy">Accuracy</a>.

			<pre>type RoundingMode <a href="/pkg/builtin/#byte">byte</a></pre>

			
				<p>These constants define supported rounding modes.

				<pre>const (
    <span id="ToNearestEven">ToNearestEven</span> <a href="#RoundingMode">RoundingMode</a> = <a href="/pkg/builtin/#iota">iota</a> <span class="comment">// == IEEE 754-2008 roundTiesToEven</span>
    <span id="ToNearestAway">ToNearestAway</span>                     <span class="comment">// == IEEE 754-2008 roundTiesToAway</span>
    <span id="ToZero">ToZero</span>                            <span class="comment">// == IEEE 754-2008 roundTowardZero</span>
    <span id="AwayFromZero">AwayFromZero</span>                      <span class="comment">// no IEEE 754-2008 equivalent</span>
    <span id="ToNegativeInf">ToNegativeInf</span>                     <span class="comment">// == IEEE 754-2008 roundTowardNegative</span>
    <span id="ToPositiveInf">ToPositiveInf</span>                     <span class="comment">// == IEEE 754-2008 roundTowardPositive</span>
)</pre>
			

			

			<div id="example_RoundingMode" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">operands := []float64{2.6, 2.5, 2.1, -2.1, -2.5, -2.6}

fmt.Print(&#34;   x&#34;)
for mode := big.ToNearestEven; mode &lt;= big.ToPositiveInf; mode++ {
    fmt.Printf(&#34;  %s&#34;, mode)
}
fmt.Println()

for _, f64 := range operands {
    fmt.Printf(&#34;%4g&#34;, f64)
    for mode := big.ToNearestEven; mode &lt;= big.ToPositiveInf; mode++ {
        <span class="comment">// sample operands above require 2 bits to represent mantissa</span>
        <span class="comment">// set binary precision to 2 to round them to integer values</span>
        f := new(big.Float).SetPrec(2).SetMode(mode).SetFloat64(f64)
        fmt.Printf(&#34;  %*g&#34;, len(mode.String()), f)
    }
    fmt.Println()
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">   x  ToNearestEven  ToNearestAway  ToZero  AwayFromZero  ToNegativeInf  ToPositiveInf
 2.6              3              3       2             3              2              3
 2.5              2              3       2             3              2              3
 2.1              2              2       2             3              2              3
-2.1             -2             -2      -2            -3             -3             -2
-2.5             -2             -3      -2            -3             -3             -2
-2.6             -3             -3      -2            -3             -3             -2
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="RoundingMode.String">func (RoundingMode) <a href="/src/math/big/roundingmode_string.go?s=581:618#L13">String</a>
					<a class="permalink" href="#RoundingMode.String">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (i <a href="#RoundingMode">RoundingMode</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Word">type <a href="/src/math/big/arith.go?s=602:616#L6">Word</a>
				<a class="permalink" href="#Word">&#xb6;</a>
				
				
			</h2>
			<p>A Word represents a single digit of a multi-precision unsigned integer.

			<pre>type Word <a href="/pkg/builtin/#uint">uint</a></pre>

			

			

			
			
			

			

			
		
	

	







<div id="footer">
Build version go1.23.0.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
