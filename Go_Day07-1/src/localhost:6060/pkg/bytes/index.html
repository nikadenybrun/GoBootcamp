<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>bytes - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.23.0";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package bytes
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "bytes"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package bytes implements functions for the manipulation of byte slices.
It is analogous to the facilities of the <a href="/strings">strings</a> package.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#Clone">func Clone(b []byte) []byte</a></dd>
			
				
				<dd><a href="#Compare">func Compare(a, b []byte) int</a></dd>
			
				
				<dd><a href="#Contains">func Contains(b, subslice []byte) bool</a></dd>
			
				
				<dd><a href="#ContainsAny">func ContainsAny(b []byte, chars string) bool</a></dd>
			
				
				<dd><a href="#ContainsFunc">func ContainsFunc(b []byte, f func(rune) bool) bool</a></dd>
			
				
				<dd><a href="#ContainsRune">func ContainsRune(b []byte, r rune) bool</a></dd>
			
				
				<dd><a href="#Count">func Count(s, sep []byte) int</a></dd>
			
				
				<dd><a href="#Cut">func Cut(s, sep []byte) (before, after []byte, found bool)</a></dd>
			
				
				<dd><a href="#CutPrefix">func CutPrefix(s, prefix []byte) (after []byte, found bool)</a></dd>
			
				
				<dd><a href="#CutSuffix">func CutSuffix(s, suffix []byte) (before []byte, found bool)</a></dd>
			
				
				<dd><a href="#Equal">func Equal(a, b []byte) bool</a></dd>
			
				
				<dd><a href="#EqualFold">func EqualFold(s, t []byte) bool</a></dd>
			
				
				<dd><a href="#Fields">func Fields(s []byte) [][]byte</a></dd>
			
				
				<dd><a href="#FieldsFunc">func FieldsFunc(s []byte, f func(rune) bool) [][]byte</a></dd>
			
				
				<dd><a href="#HasPrefix">func HasPrefix(s, prefix []byte) bool</a></dd>
			
				
				<dd><a href="#HasSuffix">func HasSuffix(s, suffix []byte) bool</a></dd>
			
				
				<dd><a href="#Index">func Index(s, sep []byte) int</a></dd>
			
				
				<dd><a href="#IndexAny">func IndexAny(s []byte, chars string) int</a></dd>
			
				
				<dd><a href="#IndexByte">func IndexByte(b []byte, c byte) int</a></dd>
			
				
				<dd><a href="#IndexFunc">func IndexFunc(s []byte, f func(r rune) bool) int</a></dd>
			
				
				<dd><a href="#IndexRune">func IndexRune(s []byte, r rune) int</a></dd>
			
				
				<dd><a href="#Join">func Join(s [][]byte, sep []byte) []byte</a></dd>
			
				
				<dd><a href="#LastIndex">func LastIndex(s, sep []byte) int</a></dd>
			
				
				<dd><a href="#LastIndexAny">func LastIndexAny(s []byte, chars string) int</a></dd>
			
				
				<dd><a href="#LastIndexByte">func LastIndexByte(s []byte, c byte) int</a></dd>
			
				
				<dd><a href="#LastIndexFunc">func LastIndexFunc(s []byte, f func(r rune) bool) int</a></dd>
			
				
				<dd><a href="#Map">func Map(mapping func(r rune) rune, s []byte) []byte</a></dd>
			
				
				<dd><a href="#Repeat">func Repeat(b []byte, count int) []byte</a></dd>
			
				
				<dd><a href="#Replace">func Replace(s, old, new []byte, n int) []byte</a></dd>
			
				
				<dd><a href="#ReplaceAll">func ReplaceAll(s, old, new []byte) []byte</a></dd>
			
				
				<dd><a href="#Runes">func Runes(s []byte) []rune</a></dd>
			
				
				<dd><a href="#Split">func Split(s, sep []byte) [][]byte</a></dd>
			
				
				<dd><a href="#SplitAfter">func SplitAfter(s, sep []byte) [][]byte</a></dd>
			
				
				<dd><a href="#SplitAfterN">func SplitAfterN(s, sep []byte, n int) [][]byte</a></dd>
			
				
				<dd><a href="#SplitN">func SplitN(s, sep []byte, n int) [][]byte</a></dd>
			
				
				<dd><a href="#Title">func Title(s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToLower">func ToLower(s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToLowerSpecial">func ToLowerSpecial(c unicode.SpecialCase, s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToTitle">func ToTitle(s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToTitleSpecial">func ToTitleSpecial(c unicode.SpecialCase, s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToUpper">func ToUpper(s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToUpperSpecial">func ToUpperSpecial(c unicode.SpecialCase, s []byte) []byte</a></dd>
			
				
				<dd><a href="#ToValidUTF8">func ToValidUTF8(s, replacement []byte) []byte</a></dd>
			
				
				<dd><a href="#Trim">func Trim(s []byte, cutset string) []byte</a></dd>
			
				
				<dd><a href="#TrimFunc">func TrimFunc(s []byte, f func(r rune) bool) []byte</a></dd>
			
				
				<dd><a href="#TrimLeft">func TrimLeft(s []byte, cutset string) []byte</a></dd>
			
				
				<dd><a href="#TrimLeftFunc">func TrimLeftFunc(s []byte, f func(r rune) bool) []byte</a></dd>
			
				
				<dd><a href="#TrimPrefix">func TrimPrefix(s, prefix []byte) []byte</a></dd>
			
				
				<dd><a href="#TrimRight">func TrimRight(s []byte, cutset string) []byte</a></dd>
			
				
				<dd><a href="#TrimRightFunc">func TrimRightFunc(s []byte, f func(r rune) bool) []byte</a></dd>
			
				
				<dd><a href="#TrimSpace">func TrimSpace(s []byte) []byte</a></dd>
			
				
				<dd><a href="#TrimSuffix">func TrimSuffix(s, suffix []byte) []byte</a></dd>
			
			
				
				<dd><a href="#Buffer">type Buffer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewBuffer">func NewBuffer(buf []byte) *Buffer</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewBufferString">func NewBufferString(s string) *Buffer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Available">func (b *Buffer) Available() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.AvailableBuffer">func (b *Buffer) AvailableBuffer() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Bytes">func (b *Buffer) Bytes() []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Cap">func (b *Buffer) Cap() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Grow">func (b *Buffer) Grow(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Len">func (b *Buffer) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Next">func (b *Buffer) Next(n int) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Read">func (b *Buffer) Read(p []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.ReadByte">func (b *Buffer) ReadByte() (byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.ReadBytes">func (b *Buffer) ReadBytes(delim byte) (line []byte, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.ReadFrom">func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.ReadRune">func (b *Buffer) ReadRune() (r rune, size int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.ReadString">func (b *Buffer) ReadString(delim byte) (line string, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Reset">func (b *Buffer) Reset()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.String">func (b *Buffer) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Truncate">func (b *Buffer) Truncate(n int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.UnreadByte">func (b *Buffer) UnreadByte() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.UnreadRune">func (b *Buffer) UnreadRune() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.Write">func (b *Buffer) Write(p []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.WriteByte">func (b *Buffer) WriteByte(c byte) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.WriteRune">func (b *Buffer) WriteRune(r rune) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.WriteString">func (b *Buffer) WriteString(s string) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffer.WriteTo">func (b *Buffer) WriteTo(w io.Writer) (n int64, err error)</a></dd>
				
			
				
				<dd><a href="#Reader">type Reader</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewReader">func NewReader(b []byte) *Reader</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Len">func (r *Reader) Len() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Read">func (r *Reader) Read(b []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadAt">func (r *Reader) ReadAt(b []byte, off int64) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadByte">func (r *Reader) ReadByte() (byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.ReadRune">func (r *Reader) ReadRune() (ch rune, size int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Reset">func (r *Reader) Reset(b []byte)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Seek">func (r *Reader) Seek(offset int64, whence int) (int64, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.Size">func (r *Reader) Size() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.UnreadByte">func (r *Reader) UnreadByte() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.UnreadRune">func (r *Reader) UnreadRune() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Reader.WriteTo">func (r *Reader) WriteTo(w io.Writer) (n int64, err error)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Buffer">Buffer</a></dd>
			
			<dd><a class="exampleLink" href="#example_Buffer_AvailableBuffer">Buffer.AvailableBuffer</a></dd>
			
			<dd><a class="exampleLink" href="#example_Buffer_Bytes">Buffer.Bytes</a></dd>
			
			<dd><a class="exampleLink" href="#example_Buffer_Cap">Buffer.Cap</a></dd>
			
			<dd><a class="exampleLink" href="#example_Buffer_Grow">Buffer.Grow</a></dd>
			
			<dd><a class="exampleLink" href="#example_Buffer_Len">Buffer.Len</a></dd>
			
			<dd><a class="exampleLink" href="#example_Buffer_Next">Buffer.Next</a></dd>
			
			<dd><a class="exampleLink" href="#example_Buffer_Read">Buffer.Read</a></dd>
			
			<dd><a class="exampleLink" href="#example_Buffer_ReadByte">Buffer.ReadByte</a></dd>
			
			<dd><a class="exampleLink" href="#example_Buffer_reader">Buffer (Reader)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Clone">Clone</a></dd>
			
			<dd><a class="exampleLink" href="#example_Compare">Compare</a></dd>
			
			<dd><a class="exampleLink" href="#example_Compare_search">Compare (Search)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Contains">Contains</a></dd>
			
			<dd><a class="exampleLink" href="#example_ContainsAny">ContainsAny</a></dd>
			
			<dd><a class="exampleLink" href="#example_ContainsFunc">ContainsFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_ContainsRune">ContainsRune</a></dd>
			
			<dd><a class="exampleLink" href="#example_Count">Count</a></dd>
			
			<dd><a class="exampleLink" href="#example_Cut">Cut</a></dd>
			
			<dd><a class="exampleLink" href="#example_CutPrefix">CutPrefix</a></dd>
			
			<dd><a class="exampleLink" href="#example_CutSuffix">CutSuffix</a></dd>
			
			<dd><a class="exampleLink" href="#example_Equal">Equal</a></dd>
			
			<dd><a class="exampleLink" href="#example_EqualFold">EqualFold</a></dd>
			
			<dd><a class="exampleLink" href="#example_Fields">Fields</a></dd>
			
			<dd><a class="exampleLink" href="#example_FieldsFunc">FieldsFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_HasPrefix">HasPrefix</a></dd>
			
			<dd><a class="exampleLink" href="#example_HasSuffix">HasSuffix</a></dd>
			
			<dd><a class="exampleLink" href="#example_Index">Index</a></dd>
			
			<dd><a class="exampleLink" href="#example_IndexAny">IndexAny</a></dd>
			
			<dd><a class="exampleLink" href="#example_IndexByte">IndexByte</a></dd>
			
			<dd><a class="exampleLink" href="#example_IndexFunc">IndexFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_IndexRune">IndexRune</a></dd>
			
			<dd><a class="exampleLink" href="#example_Join">Join</a></dd>
			
			<dd><a class="exampleLink" href="#example_LastIndex">LastIndex</a></dd>
			
			<dd><a class="exampleLink" href="#example_LastIndexAny">LastIndexAny</a></dd>
			
			<dd><a class="exampleLink" href="#example_LastIndexByte">LastIndexByte</a></dd>
			
			<dd><a class="exampleLink" href="#example_LastIndexFunc">LastIndexFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_Map">Map</a></dd>
			
			<dd><a class="exampleLink" href="#example_Reader_Len">Reader.Len</a></dd>
			
			<dd><a class="exampleLink" href="#example_Repeat">Repeat</a></dd>
			
			<dd><a class="exampleLink" href="#example_Replace">Replace</a></dd>
			
			<dd><a class="exampleLink" href="#example_ReplaceAll">ReplaceAll</a></dd>
			
			<dd><a class="exampleLink" href="#example_Runes">Runes</a></dd>
			
			<dd><a class="exampleLink" href="#example_Split">Split</a></dd>
			
			<dd><a class="exampleLink" href="#example_SplitAfter">SplitAfter</a></dd>
			
			<dd><a class="exampleLink" href="#example_SplitAfterN">SplitAfterN</a></dd>
			
			<dd><a class="exampleLink" href="#example_SplitN">SplitN</a></dd>
			
			<dd><a class="exampleLink" href="#example_Title">Title</a></dd>
			
			<dd><a class="exampleLink" href="#example_ToLower">ToLower</a></dd>
			
			<dd><a class="exampleLink" href="#example_ToLowerSpecial">ToLowerSpecial</a></dd>
			
			<dd><a class="exampleLink" href="#example_ToTitle">ToTitle</a></dd>
			
			<dd><a class="exampleLink" href="#example_ToTitleSpecial">ToTitleSpecial</a></dd>
			
			<dd><a class="exampleLink" href="#example_ToUpper">ToUpper</a></dd>
			
			<dd><a class="exampleLink" href="#example_ToUpperSpecial">ToUpperSpecial</a></dd>
			
			<dd><a class="exampleLink" href="#example_ToValidUTF8">ToValidUTF8</a></dd>
			
			<dd><a class="exampleLink" href="#example_Trim">Trim</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimFunc">TrimFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimLeft">TrimLeft</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimLeftFunc">TrimLeftFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimPrefix">TrimPrefix</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimRight">TrimRight</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimRightFunc">TrimRightFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimSpace">TrimSpace</a></dd>
			
			<dd><a class="exampleLink" href="#example_TrimSuffix">TrimSuffix</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/bytes/buffer.go">buffer.go</a>
			
				<a href="/src/bytes/bytes.go">bytes.go</a>
			
				<a href="/src/bytes/reader.go">reader.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				<p>MinRead is the minimum slice size passed to a <a href="#Buffer.Read">Buffer.Read</a> call by
<a href="#Buffer.ReadFrom">Buffer.ReadFrom</a>. As long as the <a href="#Buffer">Buffer</a> has at least MinRead bytes beyond
what is required to hold the contents of r, <a href="#Buffer.ReadFrom">Buffer.ReadFrom</a> will not grow the
underlying buffer.

				<pre>const <span id="MinRead">MinRead</span> = 512</pre>
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>ErrTooLarge is passed to panic if memory cannot be allocated to store data in a buffer.

				<pre>var <span id="ErrTooLarge">ErrTooLarge</span> = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;bytes.Buffer: too large&#34;)</pre>
			
		
		
			
			
			<h2 id="Clone">func <a href="/src/bytes/bytes.go?s=33989:34016#L1343">Clone</a>
				<a class="permalink" href="#Clone">&#xb6;</a>
				
				<span title="Added in Go 1.20">1.20</span>
			</h2>
			<pre>func Clone(b []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>Clone returns a copy of b[:len(b)].
The result may have additional unused capacity.
Clone(nil) returns nil.

			<div id="example_Clone" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">b := []byte(&#34;abc&#34;)
clone := bytes.Clone(b)
fmt.Printf(&#34;%s\n&#34;, clone)
clone[0] = &#39;d&#39;
fmt.Printf(&#34;%s\n&#34;, b)
fmt.Printf(&#34;%s\n&#34;, clone)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">abc
abc
dbc
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Compare">func <a href="/src/bytes/bytes.go?s=865:894#L17">Compare</a>
				<a class="permalink" href="#Compare">&#xb6;</a>
				
				
			</h2>
			<pre>func Compare(a, b []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>Compare returns an integer comparing two byte slices lexicographically.
The result will be 0 if a == b, -1 if a &lt; b, and +1 if a &gt; b.
A nil argument is equivalent to an empty slice.

			<div id="example_Compare" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Interpret Compare&#39;s result by comparing it to zero.</span>
var a, b []byte
if bytes.Compare(a, b) &lt; 0 {
    <span class="comment">// a less b</span>
}
if bytes.Compare(a, b) &lt;= 0 {
    <span class="comment">// a less or equal b</span>
}
if bytes.Compare(a, b) &gt; 0 {
    <span class="comment">// a greater b</span>
}
if bytes.Compare(a, b) &gt;= 0 {
    <span class="comment">// a greater or equal b</span>
}

<span class="comment">// Prefer Equal to Compare for equality comparisons.</span>
if bytes.Equal(a, b) {
    <span class="comment">// a equal b</span>
}
if !bytes.Equal(a, b) {
    <span class="comment">// a not equal b</span>
}
</pre>
			
		
	</div>
</div>
<div id="example_Compare_search" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Search)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Search)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Binary search to find a matching byte slice.</span>
var needle []byte
var haystack [][]byte <span class="comment">// Assume sorted</span>
_, found := slices.BinarySearchFunc(haystack, needle, bytes.Compare)
if found {
    <span class="comment">// Found it!</span>
}
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Contains">func <a href="/src/bytes/bytes.go?s=1903:1941#L66">Contains</a>
				<a class="permalink" href="#Contains">&#xb6;</a>
				
				
			</h2>
			<pre>func Contains(b, subslice []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>Contains reports whether subslice is within b.

			<div id="example_Contains" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.Contains([]byte(&#34;seafood&#34;), []byte(&#34;foo&#34;)))
fmt.Println(bytes.Contains([]byte(&#34;seafood&#34;), []byte(&#34;bar&#34;)))
fmt.Println(bytes.Contains([]byte(&#34;seafood&#34;), []byte(&#34;&#34;)))
fmt.Println(bytes.Contains([]byte(&#34;&#34;), []byte(&#34;&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
true
true
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ContainsAny">func <a href="/src/bytes/bytes.go?s=2071:2116#L71">ContainsAny</a>
				<a class="permalink" href="#ContainsAny">&#xb6;</a>
				
				<span title="Added in Go 1.7">1.7</span>
			</h2>
			<pre>func ContainsAny(b []<a href="/pkg/builtin/#byte">byte</a>, chars <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.

			<div id="example_ContainsAny" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.ContainsAny([]byte(&#34;I like seafood.&#34;), &#34;fÄo!&#34;))
fmt.Println(bytes.ContainsAny([]byte(&#34;I like seafood.&#34;), &#34;去是伟大的.&#34;))
fmt.Println(bytes.ContainsAny([]byte(&#34;I like seafood.&#34;), &#34;&#34;))
fmt.Println(bytes.ContainsAny([]byte(&#34;&#34;), &#34;&#34;))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
true
false
false
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ContainsFunc">func <a href="/src/bytes/bytes.go?s=2412:2463#L81">ContainsFunc</a>
				<a class="permalink" href="#ContainsFunc">&#xb6;</a>
				
				<span title="Added in Go 1.21">1.21</span>
			</h2>
			<pre>func ContainsFunc(b []<a href="/pkg/builtin/#byte">byte</a>, f func(<a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>ContainsFunc reports whether any of the UTF-8-encoded code points r within b satisfy f(r).

			<div id="example_ContainsFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">f := func(r rune) bool {
    return r &gt;= &#39;a&#39; &amp;&amp; r &lt;= &#39;z&#39;
}
fmt.Println(bytes.ContainsFunc([]byte(&#34;HELLO&#34;), f))
fmt.Println(bytes.ContainsFunc([]byte(&#34;World&#34;), f))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">false
true
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ContainsRune">func <a href="/src/bytes/bytes.go?s=2243:2283#L76">ContainsRune</a>
				<a class="permalink" href="#ContainsRune">&#xb6;</a>
				
				<span title="Added in Go 1.7">1.7</span>
			</h2>
			<pre>func ContainsRune(b []<a href="/pkg/builtin/#byte">byte</a>, r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.

			<div id="example_ContainsRune" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.ContainsRune([]byte(&#34;I like seafood.&#34;), &#39;f&#39;))
fmt.Println(bytes.ContainsRune([]byte(&#34;I like seafood.&#34;), &#39;ö&#39;))
fmt.Println(bytes.ContainsRune([]byte(&#34;去是伟大的!&#34;), &#39;大&#39;))
fmt.Println(bytes.ContainsRune([]byte(&#34;去是伟大的!&#34;), &#39;!&#39;))
fmt.Println(bytes.ContainsRune([]byte(&#34;&#34;), &#39;@&#39;))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
true
true
false
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Count">func <a href="/src/bytes/bytes.go?s=1593:1622#L46">Count</a>
				<a class="permalink" href="#Count">&#xb6;</a>
				
				
			</h2>
			<pre>func Count(s, sep []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>Count counts the number of non-overlapping instances of sep in s.
If sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.

			<div id="example_Count" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.Count([]byte(&#34;cheese&#34;), []byte(&#34;e&#34;)))
fmt.Println(bytes.Count([]byte(&#34;five&#34;), []byte(&#34;&#34;))) <span class="comment">// before &amp; after each rune</span>
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">3
5
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Cut">func <a href="/src/bytes/bytes.go?s=33713:33771#L1333">Cut</a>
				<a class="permalink" href="#Cut">&#xb6;</a>
				
				<span title="Added in Go 1.18">1.18</span>
			</h2>
			<pre>func Cut(s, sep []<a href="/pkg/builtin/#byte">byte</a>) (before, after []<a href="/pkg/builtin/#byte">byte</a>, found <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>Cut slices s around the first instance of sep,
returning the text before and after sep.
The found result reports whether sep appears in s.
If sep does not appear in s, cut returns s, nil, false.
<p>Cut returns slices of the original slice s, not copies.

			<div id="example_Cut" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">show := func(s, sep string) {
    before, after, found := bytes.Cut([]byte(s), []byte(sep))
    fmt.Printf(&#34;Cut(%q, %q) = %q, %q, %v\n&#34;, s, sep, before, after, found)
}
show(&#34;Gopher&#34;, &#34;Go&#34;)
show(&#34;Gopher&#34;, &#34;ph&#34;)
show(&#34;Gopher&#34;, &#34;er&#34;)
show(&#34;Gopher&#34;, &#34;Badger&#34;)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Cut(&#34;Gopher&#34;, &#34;Go&#34;) = &#34;&#34;, &#34;pher&#34;, true
Cut(&#34;Gopher&#34;, &#34;ph&#34;) = &#34;Go&#34;, &#34;er&#34;, true
Cut(&#34;Gopher&#34;, &#34;er&#34;) = &#34;Goph&#34;, &#34;&#34;, true
Cut(&#34;Gopher&#34;, &#34;Badger&#34;) = &#34;Gopher&#34;, &#34;&#34;, false
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="CutPrefix">func <a href="/src/bytes/bytes.go?s=34394:34453#L1356">CutPrefix</a>
				<a class="permalink" href="#CutPrefix">&#xb6;</a>
				
				<span title="Added in Go 1.20">1.20</span>
			</h2>
			<pre>func CutPrefix(s, prefix []<a href="/pkg/builtin/#byte">byte</a>) (after []<a href="/pkg/builtin/#byte">byte</a>, found <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>CutPrefix returns s without the provided leading prefix byte slice
and reports whether it found the prefix.
If s doesn&apos;t start with prefix, CutPrefix returns s, false.
If prefix is the empty byte slice, CutPrefix returns s, true.
<p>CutPrefix returns slices of the original slice s, not copies.

			<div id="example_CutPrefix" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">show := func(s, sep string) {
    after, found := bytes.CutPrefix([]byte(s), []byte(sep))
    fmt.Printf(&#34;CutPrefix(%q, %q) = %q, %v\n&#34;, s, sep, after, found)
}
show(&#34;Gopher&#34;, &#34;Go&#34;)
show(&#34;Gopher&#34;, &#34;ph&#34;)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">CutPrefix(&#34;Gopher&#34;, &#34;Go&#34;) = &#34;pher&#34;, true
CutPrefix(&#34;Gopher&#34;, &#34;ph&#34;) = &#34;Gopher&#34;, false
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="CutSuffix">func <a href="/src/bytes/bytes.go?s=34845:34905#L1369">CutSuffix</a>
				<a class="permalink" href="#CutSuffix">&#xb6;</a>
				
				<span title="Added in Go 1.20">1.20</span>
			</h2>
			<pre>func CutSuffix(s, suffix []<a href="/pkg/builtin/#byte">byte</a>) (before []<a href="/pkg/builtin/#byte">byte</a>, found <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>CutSuffix returns s without the provided ending suffix byte slice
and reports whether it found the suffix.
If s doesn&apos;t end with suffix, CutSuffix returns s, false.
If suffix is the empty byte slice, CutSuffix returns s, true.
<p>CutSuffix returns slices of the original slice s, not copies.

			<div id="example_CutSuffix" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">show := func(s, sep string) {
    before, found := bytes.CutSuffix([]byte(s), []byte(sep))
    fmt.Printf(&#34;CutSuffix(%q, %q) = %q, %v\n&#34;, s, sep, before, found)
}
show(&#34;Gopher&#34;, &#34;Go&#34;)
show(&#34;Gopher&#34;, &#34;er&#34;)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">CutSuffix(&#34;Gopher&#34;, &#34;Go&#34;) = &#34;Gopher&#34;, false
CutSuffix(&#34;Gopher&#34;, &#34;er&#34;) = &#34;Goph&#34;, true
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Equal">func <a href="/src/bytes/bytes.go?s=535:563#L9">Equal</a>
				<a class="permalink" href="#Equal">&#xb6;</a>
				
				
			</h2>
			<pre>func Equal(a, b []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>Equal reports whether a and b
are the same length and contain the same bytes.
A nil argument is equivalent to an empty slice.

			<div id="example_Equal" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.Equal([]byte(&#34;Go&#34;), []byte(&#34;Go&#34;)))
fmt.Println(bytes.Equal([]byte(&#34;Go&#34;), []byte(&#34;C++&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="EqualFold">func <a href="/src/bytes/bytes.go?s=29963:29995#L1156">EqualFold</a>
				<a class="permalink" href="#EqualFold">&#xb6;</a>
				
				
			</h2>
			<pre>func EqualFold(s, t []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>EqualFold reports whether s and t, interpreted as UTF-8 strings,
are equal under simple Unicode case-folding, which is a more general
form of case-insensitivity.

			<div id="example_EqualFold" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.EqualFold([]byte(&#34;Go&#34;), []byte(&#34;go&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Fields">func <a href="/src/bytes/bytes.go?s=9886:9916#L388">Fields</a>
				<a class="permalink" href="#Fields">&#xb6;</a>
				
				
			</h2>
			<pre>func Fields(s []<a href="/pkg/builtin/#byte">byte</a>) [][]<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>Fields interprets s as a sequence of UTF-8-encoded code points.
It splits the slice s around each instance of one or more consecutive white space
characters, as defined by <a href="/unicode#IsSpace">unicode.IsSpace</a>, returning a slice of subslices of s or an
empty slice if s contains only white space.

			<div id="example_Fields" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Printf(&#34;Fields are: %q&#34;, bytes.Fields([]byte(&#34;  foo bar  baz   &#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Fields are: [&#34;foo&#34; &#34;bar&#34; &#34;baz&#34;]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="FieldsFunc">func <a href="/src/bytes/bytes.go?s=11335:11388#L445">FieldsFunc</a>
				<a class="permalink" href="#FieldsFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func FieldsFunc(s []<a href="/pkg/builtin/#byte">byte</a>, f func(<a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#bool">bool</a>) [][]<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>FieldsFunc interprets s as a sequence of UTF-8-encoded code points.
It splits the slice s at each run of code points c satisfying f(c) and
returns a slice of subslices of s. If all code points in s satisfy f(c), or
len(s) == 0, an empty slice is returned.
<p>FieldsFunc makes no guarantees about the order in which it calls f(c)
and assumes that f always returns the same value for a given c.

			<div id="example_FieldsFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">f := func(c rune) bool {
    return !unicode.IsLetter(c) &amp;&amp; !unicode.IsNumber(c)
}
fmt.Printf(&#34;Fields are: %q&#34;, bytes.FieldsFunc([]byte(&#34;  foo1;bar2,baz3...&#34;), f))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Fields are: [&#34;foo1&#34; &#34;bar2&#34; &#34;baz3&#34;]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="HasPrefix">func <a href="/src/bytes/bytes.go?s=13217:13254#L527">HasPrefix</a>
				<a class="permalink" href="#HasPrefix">&#xb6;</a>
				
				
			</h2>
			<pre>func HasPrefix(s, prefix []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>HasPrefix reports whether the byte slice s begins with prefix.

			<div id="example_HasPrefix" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.HasPrefix([]byte(&#34;Gopher&#34;), []byte(&#34;Go&#34;)))
fmt.Println(bytes.HasPrefix([]byte(&#34;Gopher&#34;), []byte(&#34;C&#34;)))
fmt.Println(bytes.HasPrefix([]byte(&#34;Gopher&#34;), []byte(&#34;&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
true
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="HasSuffix">func <a href="/src/bytes/bytes.go?s=13389:13426#L532">HasSuffix</a>
				<a class="permalink" href="#HasSuffix">&#xb6;</a>
				
				
			</h2>
			<pre>func HasSuffix(s, suffix []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>HasSuffix reports whether the byte slice s ends with suffix.

			<div id="example_HasSuffix" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.HasSuffix([]byte(&#34;Amigo&#34;), []byte(&#34;go&#34;)))
fmt.Println(bytes.HasSuffix([]byte(&#34;Amigo&#34;), []byte(&#34;O&#34;)))
fmt.Println(bytes.HasSuffix([]byte(&#34;Amigo&#34;), []byte(&#34;Ami&#34;)))
fmt.Println(bytes.HasSuffix([]byte(&#34;Amigo&#34;), []byte(&#34;&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
false
true
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Index">func <a href="/src/bytes/bytes.go?s=31641:31670#L1240">Index</a>
				<a class="permalink" href="#Index">&#xb6;</a>
				
				
			</h2>
			<pre>func Index(s, sep []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.

			<div id="example_Index" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.Index([]byte(&#34;chicken&#34;), []byte(&#34;ken&#34;)))
fmt.Println(bytes.Index([]byte(&#34;chicken&#34;), []byte(&#34;dmr&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">4
-1
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="IndexAny">func <a href="/src/bytes/bytes.go?s=4322:4363#L154">IndexAny</a>
				<a class="permalink" href="#IndexAny">&#xb6;</a>
				
				
			</h2>
			<pre>func IndexAny(s []<a href="/pkg/builtin/#byte">byte</a>, chars <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.
It returns the byte index of the first occurrence in s of any of the Unicode
code points in chars. It returns -1 if chars is empty or if there is no code
point in common.

			<div id="example_IndexAny" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.IndexAny([]byte(&#34;chicken&#34;), &#34;aeiouy&#34;))
fmt.Println(bytes.IndexAny([]byte(&#34;crwth&#34;), &#34;aeiouy&#34;))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">2
-1
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="IndexByte">func <a href="/src/bytes/bytes.go?s=2594:2630#L86">IndexByte</a>
				<a class="permalink" href="#IndexByte">&#xb6;</a>
				
				
			</h2>
			<pre>func IndexByte(b []<a href="/pkg/builtin/#byte">byte</a>, c <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.

			<div id="example_IndexByte" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.IndexByte([]byte(&#34;chicken&#34;), byte(&#39;k&#39;)))
fmt.Println(bytes.IndexByte([]byte(&#34;chicken&#34;), byte(&#39;g&#39;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">4
-1
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="IndexFunc">func <a href="/src/bytes/bytes.go?s=21927:21976#L834">IndexFunc</a>
				<a class="permalink" href="#IndexFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func IndexFunc(s []<a href="/pkg/builtin/#byte">byte</a>, f func(r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>IndexFunc interprets s as a sequence of UTF-8-encoded code points.
It returns the byte index in s of the first Unicode
code point satisfying f(c), or -1 if none do.

			<div id="example_IndexFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">f := func(c rune) bool {
    return unicode.Is(unicode.Han, c)
}
fmt.Println(bytes.IndexFunc([]byte(&#34;Hello, 世界&#34;), f))
fmt.Println(bytes.IndexFunc([]byte(&#34;Hello, world&#34;), f))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">7
-1
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="IndexRune">func <a href="/src/bytes/bytes.go?s=3650:3686#L128">IndexRune</a>
				<a class="permalink" href="#IndexRune">&#xb6;</a>
				
				
			</h2>
			<pre>func IndexRune(s []<a href="/pkg/builtin/#byte">byte</a>, r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>IndexRune interprets s as a sequence of UTF-8-encoded code points.
It returns the byte index of the first occurrence in s of the given rune.
It returns -1 if rune is not present in s.
If r is <a href="/unicode/utf8#RuneError">utf8.RuneError</a>, it returns the first instance of any
invalid UTF-8 byte sequence.

			<div id="example_IndexRune" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.IndexRune([]byte(&#34;chicken&#34;), &#39;k&#39;))
fmt.Println(bytes.IndexRune([]byte(&#34;chicken&#34;), &#39;d&#39;))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">4
-1
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Join">func <a href="/src/bytes/bytes.go?s=12567:12607#L494">Join</a>
				<a class="permalink" href="#Join">&#xb6;</a>
				
				
			</h2>
			<pre>func Join(s [][]<a href="/pkg/builtin/#byte">byte</a>, sep []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>Join concatenates the elements of s to create a new byte slice. The separator
sep is placed between elements in the resulting slice.

			<div id="example_Join" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">s := [][]byte{[]byte(&#34;foo&#34;), []byte(&#34;bar&#34;), []byte(&#34;baz&#34;)}
fmt.Printf(&#34;%s&#34;, bytes.Join(s, []byte(&#34;, &#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">foo, bar, baz
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="LastIndex">func <a href="/src/bytes/bytes.go?s=2884:2917#L100">LastIndex</a>
				<a class="permalink" href="#LastIndex">&#xb6;</a>
				
				
			</h2>
			<pre>func LastIndex(s, sep []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.

			<div id="example_LastIndex" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.Index([]byte(&#34;go gopher&#34;), []byte(&#34;go&#34;)))
fmt.Println(bytes.LastIndex([]byte(&#34;go gopher&#34;), []byte(&#34;go&#34;)))
fmt.Println(bytes.LastIndex([]byte(&#34;go gopher&#34;), []byte(&#34;rodent&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">0
3
-1
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="LastIndexAny">func <a href="/src/bytes/bytes.go?s=5889:5934#L232">LastIndexAny</a>
				<a class="permalink" href="#LastIndexAny">&#xb6;</a>
				
				
			</h2>
			<pre>func LastIndexAny(s []<a href="/pkg/builtin/#byte">byte</a>, chars <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code
points. It returns the byte index of the last occurrence in s of any of
the Unicode code points in chars. It returns -1 if chars is empty or if
there is no code point in common.

			<div id="example_LastIndexAny" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.LastIndexAny([]byte(&#34;go gopher&#34;), &#34;MüQp&#34;))
fmt.Println(bytes.LastIndexAny([]byte(&#34;go 地鼠&#34;), &#34;地大&#34;))
fmt.Println(bytes.LastIndexAny([]byte(&#34;go gopher&#34;), &#34;z,!.&#34;))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">5
3
-1
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="LastIndexByte">func <a href="/src/bytes/bytes.go?s=3277:3317#L119">LastIndexByte</a>
				<a class="permalink" href="#LastIndexByte">&#xb6;</a>
				
				<span title="Added in Go 1.5">1.5</span>
			</h2>
			<pre>func LastIndexByte(s []<a href="/pkg/builtin/#byte">byte</a>, c <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.

			<div id="example_LastIndexByte" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.LastIndexByte([]byte(&#34;go gopher&#34;), byte(&#39;g&#39;)))
fmt.Println(bytes.LastIndexByte([]byte(&#34;go gopher&#34;), byte(&#39;r&#39;)))
fmt.Println(bytes.LastIndexByte([]byte(&#34;go gopher&#34;), byte(&#39;z&#39;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">3
8
-1
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="LastIndexFunc">func <a href="/src/bytes/bytes.go?s=22189:22242#L841">LastIndexFunc</a>
				<a class="permalink" href="#LastIndexFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func LastIndexFunc(s []<a href="/pkg/builtin/#byte">byte</a>, f func(r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>LastIndexFunc interprets s as a sequence of UTF-8-encoded code points.
It returns the byte index in s of the last Unicode
code point satisfying f(c), or -1 if none do.

			<div id="example_LastIndexFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.LastIndexFunc([]byte(&#34;go gopher!&#34;), unicode.IsLetter))
fmt.Println(bytes.LastIndexFunc([]byte(&#34;go gopher!&#34;), unicode.IsPunct))
fmt.Println(bytes.LastIndexFunc([]byte(&#34;go gopher!&#34;), unicode.IsNumber))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">8
9
-1
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Map">func <a href="/src/bytes/bytes.go?s=13806:13858#L540">Map</a>
				<a class="permalink" href="#Map">&#xb6;</a>
				
				
			</h2>
			<pre>func Map(mapping func(r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#rune">rune</a>, s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>Map returns a copy of the byte slice s with all its characters modified
according to the mapping function. If mapping returns a negative value, the character is
dropped from the byte slice with no replacement. The characters in s and the
output are interpreted as UTF-8-encoded code points.

			<div id="example_Map" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">rot13 := func(r rune) rune {
    switch {
    case r &gt;= &#39;A&#39; &amp;&amp; r &lt;= &#39;Z&#39;:
        return &#39;A&#39; + (r-&#39;A&#39;+13)%26
    case r &gt;= &#39;a&#39; &amp;&amp; r &lt;= &#39;z&#39;:
        return &#39;a&#39; + (r-&#39;a&#39;+13)%26
    }
    return r
}
fmt.Printf(&#34;%s\n&#34;, bytes.Map(rot13, []byte(&#34;&#39;Twas brillig and the slithy gopher...&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">&#39;Gjnf oevyyvt naq gur fyvgul tbcure...
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Repeat">func <a href="/src/bytes/bytes.go?s=14774:14813#L576">Repeat</a>
				<a class="permalink" href="#Repeat">&#xb6;</a>
				
				
			</h2>
			<pre>func Repeat(b []<a href="/pkg/builtin/#byte">byte</a>, count <a href="/pkg/builtin/#int">int</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>Repeat returns a new byte slice consisting of count copies of b.
<p>It panics if count is negative or if the result of (len(b) * count)
overflows.

			<div id="example_Repeat" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Printf(&#34;ba%s&#34;, bytes.Repeat([]byte(&#34;na&#34;), 2))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">banana
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Replace">func <a href="/src/bytes/bytes.go?s=28807:28853#L1108">Replace</a>
				<a class="permalink" href="#Replace">&#xb6;</a>
				
				
			</h2>
			<pre>func Replace(s, old, new []<a href="/pkg/builtin/#byte">byte</a>, n <a href="/pkg/builtin/#int">int</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>Replace returns a copy of the slice s with the first n
non-overlapping instances of old replaced by new.
If old is empty, it matches at the beginning of the slice
and after each UTF-8 sequence, yielding up to k+1 replacements
for a k-rune slice.
If n &lt; 0, there is no limit on the number of replacements.

			<div id="example_Replace" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Printf(&#34;%s\n&#34;, bytes.Replace([]byte(&#34;oink oink oink&#34;), []byte(&#34;k&#34;), []byte(&#34;ky&#34;), 2))
fmt.Printf(&#34;%s\n&#34;, bytes.Replace([]byte(&#34;oink oink oink&#34;), []byte(&#34;oink&#34;), []byte(&#34;moo&#34;), -1))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">oinky oinky oink
moo moo moo
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ReplaceAll">func <a href="/src/bytes/bytes.go?s=29711:29753#L1149">ReplaceAll</a>
				<a class="permalink" href="#ReplaceAll">&#xb6;</a>
				
				<span title="Added in Go 1.12">1.12</span>
			</h2>
			<pre>func ReplaceAll(s, old, new []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>ReplaceAll returns a copy of the slice s with all
non-overlapping instances of old replaced by new.
If old is empty, it matches at the beginning of the slice
and after each UTF-8 sequence, yielding up to k+1 replacements
for a k-rune slice.

			<div id="example_ReplaceAll" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Printf(&#34;%s\n&#34;, bytes.ReplaceAll([]byte(&#34;oink oink oink&#34;), []byte(&#34;oink&#34;), []byte(&#34;moo&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">moo moo moo
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Runes">func <a href="/src/bytes/bytes.go?s=28316:28343#L1090">Runes</a>
				<a class="permalink" href="#Runes">&#xb6;</a>
				
				
			</h2>
			<pre>func Runes(s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#rune">rune</a></pre>
			<p>Runes interprets s as a sequence of UTF-8-encoded code points.
It returns a slice of runes (Unicode code points) equivalent to s.

			<div id="example_Runes" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">rs := bytes.Runes([]byte(&#34;go gopher&#34;))
for _, r := range rs {
    fmt.Printf(&#34;%#U\n&#34;, r)
}
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">U+0067 &#39;g&#39;
U+006F &#39;o&#39;
U+0020 &#39; &#39;
U+0067 &#39;g&#39;
U+006F &#39;o&#39;
U+0070 &#39;p&#39;
U+0068 &#39;h&#39;
U+0065 &#39;e&#39;
U+0072 &#39;r&#39;
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Split">func <a href="/src/bytes/bytes.go?s=9128:9162#L372">Split</a>
				<a class="permalink" href="#Split">&#xb6;</a>
				
				
			</h2>
			<pre>func Split(s, sep []<a href="/pkg/builtin/#byte">byte</a>) [][]<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>Split slices s into all subslices separated by sep and returns a slice of
the subslices between those separators.
If sep is empty, Split splits after each UTF-8 sequence.
It is equivalent to SplitN with a count of -1.
<p>To split around the first instance of a separator, see <a href="#Cut">Cut</a>.

			<div id="example_Split" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Printf(&#34;%q\n&#34;, bytes.Split([]byte(&#34;a,b,c&#34;), []byte(&#34;,&#34;)))
fmt.Printf(&#34;%q\n&#34;, bytes.Split([]byte(&#34;a man a plan a canal panama&#34;), []byte(&#34;a &#34;)))
fmt.Printf(&#34;%q\n&#34;, bytes.Split([]byte(&#34; xyz &#34;), []byte(&#34;&#34;)))
fmt.Printf(&#34;%q\n&#34;, bytes.Split([]byte(&#34;&#34;), []byte(&#34;Bernardo O&#39;Higgins&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[&#34;a&#34; &#34;b&#34; &#34;c&#34;]
[&#34;&#34; &#34;man &#34; &#34;plan &#34; &#34;canal panama&#34;]
[&#34; &#34; &#34;x&#34; &#34;y&#34; &#34;z&#34; &#34; &#34;]
[&#34;&#34;]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="SplitAfter">func <a href="/src/bytes/bytes.go?s=9431:9470#L378">SplitAfter</a>
				<a class="permalink" href="#SplitAfter">&#xb6;</a>
				
				
			</h2>
			<pre>func SplitAfter(s, sep []<a href="/pkg/builtin/#byte">byte</a>) [][]<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>SplitAfter slices s into all subslices after each instance of sep and
returns a slice of those subslices.
If sep is empty, SplitAfter splits after each UTF-8 sequence.
It is equivalent to SplitAfterN with a count of -1.

			<div id="example_SplitAfter" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Printf(&#34;%q\n&#34;, bytes.SplitAfter([]byte(&#34;a,b,c&#34;), []byte(&#34;,&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[&#34;a,&#34; &#34;b,&#34; &#34;c&#34;]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="SplitAfterN">func <a href="/src/bytes/bytes.go?s=8739:8786#L362">SplitAfterN</a>
				<a class="permalink" href="#SplitAfterN">&#xb6;</a>
				
				
			</h2>
			<pre>func SplitAfterN(s, sep []<a href="/pkg/builtin/#byte">byte</a>, n <a href="/pkg/builtin/#int">int</a>) [][]<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>SplitAfterN slices s into subslices after each instance of sep and
returns a slice of those subslices.
If sep is empty, SplitAfterN splits after each UTF-8 sequence.
The count determines the number of subslices to return:
<ul>
<li>n &gt; 0: at most n subslices; the last subslice will be the unsplit remainder;
<li>n == 0: the result is nil (zero subslices);
<li>n &lt; 0: all subslices.
</ul>

			<div id="example_SplitAfterN" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Printf(&#34;%q\n&#34;, bytes.SplitAfterN([]byte(&#34;a,b,c&#34;), []byte(&#34;,&#34;), 2))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[&#34;a,&#34; &#34;b,c&#34;]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="SplitN">func <a href="/src/bytes/bytes.go?s=8263:8305#L353">SplitN</a>
				<a class="permalink" href="#SplitN">&#xb6;</a>
				
				
			</h2>
			<pre>func SplitN(s, sep []<a href="/pkg/builtin/#byte">byte</a>, n <a href="/pkg/builtin/#int">int</a>) [][]<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>SplitN slices s into subslices separated by sep and returns a slice of
the subslices between those separators.
If sep is empty, SplitN splits after each UTF-8 sequence.
The count determines the number of subslices to return:
<ul>
<li>n &gt; 0: at most n subslices; the last subslice will be the unsplit remainder;
<li>n == 0: the result is nil (zero subslices);
<li>n &lt; 0: all subslices.
</ul>
<p>To split around the first instance of a separator, see <a href="#Cut">Cut</a>.

			<div id="example_SplitN" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Printf(&#34;%q\n&#34;, bytes.SplitN([]byte(&#34;a,b,c&#34;), []byte(&#34;,&#34;), 2))
z := bytes.SplitN([]byte(&#34;a,b,c&#34;), []byte(&#34;,&#34;), 0)
fmt.Printf(&#34;%q (nil = %v)\n&#34;, z, z == nil)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[&#34;a&#34; &#34;b,c&#34;]
[] (nil = true)
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Title">func <a href="/src/bytes/bytes.go?s=20088:20115#L767">Title</a>
				<a class="permalink" href="#Title">&#xb6;</a>
				
				
			</h2>
			<pre>func Title(s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin
words mapped to their title case.
<p>Deprecated: The rule Title uses for word boundaries does not handle Unicode
punctuation properly. Use golang.org/x/text/cases instead.

			<div id="example_Title" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Printf(&#34;%s&#34;, bytes.Title([]byte(&#34;her royal highness&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Her Royal Highness
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ToLower">func <a href="/src/bytes/bytes.go?s=16943:16972#L659">ToLower</a>
				<a class="permalink" href="#ToLower">&#xb6;</a>
				
				
			</h2>
			<pre>func ToLower(s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>ToLower returns a copy of the byte slice s with all Unicode letters mapped to
their lower case.

			<div id="example_ToLower" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Printf(&#34;%s&#34;, bytes.ToLower([]byte(&#34;Gopher&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">gopher
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ToLowerSpecial">func <a href="/src/bytes/bytes.go?s=18109:18168#L698">ToLowerSpecial</a>
				<a class="permalink" href="#ToLowerSpecial">&#xb6;</a>
				
				
			</h2>
			<pre>func ToLowerSpecial(c <a href="/pkg/unicode/">unicode</a>.<a href="/pkg/unicode/#SpecialCase">SpecialCase</a>, s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their
lower case, giving priority to the special casing rules.

			<div id="example_ToLowerSpecial" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">str := []byte(&#34;AHOJ VÝVOJÁRİ GOLANG&#34;)
totitle := bytes.ToLowerSpecial(unicode.AzeriCase, str)
fmt.Println(&#34;Original : &#34; + string(str))
fmt.Println(&#34;ToLower : &#34; + string(totitle))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Original : AHOJ VÝVOJÁRİ GOLANG
ToLower : ahoj vývojári golang
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ToTitle">func <a href="/src/bytes/bytes.go?s=17604:17633#L688">ToTitle</a>
				<a class="permalink" href="#ToTitle">&#xb6;</a>
				
				
			</h2>
			<pre>func ToTitle(s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.

			<div id="example_ToTitle" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Printf(&#34;%s\n&#34;, bytes.ToTitle([]byte(&#34;loud noises&#34;)))
fmt.Printf(&#34;%s\n&#34;, bytes.ToTitle([]byte(&#34;хлеб&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">LOUD NOISES
ХЛЕБ
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ToTitleSpecial">func <a href="/src/bytes/bytes.go?s=18374:18433#L704">ToTitleSpecial</a>
				<a class="permalink" href="#ToTitleSpecial">&#xb6;</a>
				
				
			</h2>
			<pre>func ToTitleSpecial(c <a href="/pkg/unicode/">unicode</a>.<a href="/pkg/unicode/#SpecialCase">SpecialCase</a>, s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their
title case, giving priority to the special casing rules.

			<div id="example_ToTitleSpecial" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">str := []byte(&#34;ahoj vývojári golang&#34;)
totitle := bytes.ToTitleSpecial(unicode.AzeriCase, str)
fmt.Println(&#34;Original : &#34; + string(str))
fmt.Println(&#34;ToTitle : &#34; + string(totitle))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Original : ahoj vývojári golang
ToTitle : AHOJ VÝVOJÁRİ GOLANG
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ToUpper">func <a href="/src/bytes/bytes.go?s=16273:16302#L628">ToUpper</a>
				<a class="permalink" href="#ToUpper">&#xb6;</a>
				
				
			</h2>
			<pre>func ToUpper(s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>ToUpper returns a copy of the byte slice s with all Unicode letters mapped to
their upper case.

			<div id="example_ToUpper" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Printf(&#34;%s&#34;, bytes.ToUpper([]byte(&#34;Gopher&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">GOPHER
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ToUpperSpecial">func <a href="/src/bytes/bytes.go?s=17844:17903#L692">ToUpperSpecial</a>
				<a class="permalink" href="#ToUpperSpecial">&#xb6;</a>
				
				
			</h2>
			<pre>func ToUpperSpecial(c <a href="/pkg/unicode/">unicode</a>.<a href="/pkg/unicode/#SpecialCase">SpecialCase</a>, s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their
upper case, giving priority to the special casing rules.

			<div id="example_ToUpperSpecial" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">str := []byte(&#34;ahoj vývojári golang&#34;)
totitle := bytes.ToUpperSpecial(unicode.AzeriCase, str)
fmt.Println(&#34;Original : &#34; + string(str))
fmt.Println(&#34;ToUpper : &#34; + string(totitle))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Original : ahoj vývojári golang
ToUpper : AHOJ VÝVOJÁRİ GOLANG
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ToValidUTF8">func <a href="/src/bytes/bytes.go?s=18644:18690#L710">ToValidUTF8</a>
				<a class="permalink" href="#ToValidUTF8">&#xb6;</a>
				
				<span title="Added in Go 1.13">1.13</span>
			</h2>
			<pre>func ToValidUTF8(s, replacement []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>ToValidUTF8 treats s as UTF-8-encoded bytes and returns a copy with each run of bytes
representing invalid UTF-8 replaced with the bytes in replacement, which may be empty.

			<div id="example_ToValidUTF8" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Printf(&#34;%s\n&#34;, bytes.ToValidUTF8([]byte(&#34;abc&#34;), []byte(&#34;\uFFFD&#34;)))
fmt.Printf(&#34;%s\n&#34;, bytes.ToValidUTF8([]byte(&#34;a\xffb\xC0\xAFc\xff&#34;), []byte(&#34;&#34;)))
fmt.Printf(&#34;%s\n&#34;, bytes.ToValidUTF8([]byte(&#34;\xed\xa0\x80&#34;), []byte(&#34;abc&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">abc
abc
abc
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Trim">func <a href="/src/bytes/bytes.go?s=24538:24579#L923">Trim</a>
				<a class="permalink" href="#Trim">&#xb6;</a>
				
				
			</h2>
			<pre>func Trim(s []<a href="/pkg/builtin/#byte">byte</a>, cutset <a href="/pkg/builtin/#string">string</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>Trim returns a subslice of s by slicing off all leading and
trailing UTF-8-encoded code points contained in cutset.

			<div id="example_Trim" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Printf(&#34;[%q]&#34;, bytes.Trim([]byte(&#34; !!! Achtung! Achtung! !!! &#34;), &#34;! &#34;))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[&#34;Achtung! Achtung&#34;]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimFunc">func <a href="/src/bytes/bytes.go?s=21167:21218#L809">TrimFunc</a>
				<a class="permalink" href="#TrimFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func TrimFunc(s []<a href="/pkg/builtin/#byte">byte</a>, f func(r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#bool">bool</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>TrimFunc returns a subslice of s by slicing off all leading and trailing
UTF-8-encoded code points c that satisfy f(c).

			<div id="example_TrimFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(string(bytes.TrimFunc([]byte(&#34;go-gopher!&#34;), unicode.IsLetter)))
fmt.Println(string(bytes.TrimFunc([]byte(&#34;\&#34;go-gopher!\&#34;&#34;), unicode.IsLetter)))
fmt.Println(string(bytes.TrimFunc([]byte(&#34;go-gopher!&#34;), unicode.IsPunct)))
fmt.Println(string(bytes.TrimFunc([]byte(&#34;1234go-gopher!567&#34;), unicode.IsNumber)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">-gopher!
&#34;go-gopher!&#34;
go-gopher
go-gopher!
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimLeft">func <a href="/src/bytes/bytes.go?s=25082:25127#L942">TrimLeft</a>
				<a class="permalink" href="#TrimLeft">&#xb6;</a>
				
				
			</h2>
			<pre>func TrimLeft(s []<a href="/pkg/builtin/#byte">byte</a>, cutset <a href="/pkg/builtin/#string">string</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>TrimLeft returns a subslice of s by slicing off all leading
UTF-8-encoded code points contained in cutset.

			<div id="example_TrimLeft" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Print(string(bytes.TrimLeft([]byte(&#34;453gopher8257&#34;), &#34;0123456789&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">gopher8257
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimLeftFunc">func <a href="/src/bytes/bytes.go?s=20575:20630#L786">TrimLeftFunc</a>
				<a class="permalink" href="#TrimLeftFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func TrimLeftFunc(s []<a href="/pkg/builtin/#byte">byte</a>, f func(r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#bool">bool</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off
all leading UTF-8-encoded code points c that satisfy f(c).

			<div id="example_TrimLeftFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(string(bytes.TrimLeftFunc([]byte(&#34;go-gopher&#34;), unicode.IsLetter)))
fmt.Println(string(bytes.TrimLeftFunc([]byte(&#34;go-gopher!&#34;), unicode.IsPunct)))
fmt.Println(string(bytes.TrimLeftFunc([]byte(&#34;1234go-gopher!567&#34;), unicode.IsNumber)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">-gopher
go-gopher!
go-gopher!567
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimPrefix">func <a href="/src/bytes/bytes.go?s=21397:21437#L815">TrimPrefix</a>
				<a class="permalink" href="#TrimPrefix">&#xb6;</a>
				
				<span title="Added in Go 1.1">1.1</span>
			</h2>
			<pre>func TrimPrefix(s, prefix []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>TrimPrefix returns s without the provided leading prefix string.
If s doesn&apos;t start with prefix, s is returned unchanged.

			<div id="example_TrimPrefix" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">var b = []byte(&#34;Goodbye,, world!&#34;)
b = bytes.TrimPrefix(b, []byte(&#34;Goodbye,&#34;))
b = bytes.TrimPrefix(b, []byte(&#34;See ya,&#34;))
fmt.Printf(&#34;Hello%s&#34;, b)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Hello, world!
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimRight">func <a href="/src/bytes/bytes.go?s=26269:26315#L1004">TrimRight</a>
				<a class="permalink" href="#TrimRight">&#xb6;</a>
				
				
			</h2>
			<pre>func TrimRight(s []<a href="/pkg/builtin/#byte">byte</a>, cutset <a href="/pkg/builtin/#string">string</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>TrimRight returns a subslice of s by slicing off all trailing
UTF-8-encoded code points that are contained in cutset.

			<div id="example_TrimRight" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Print(string(bytes.TrimRight([]byte(&#34;453gopher8257&#34;), &#34;0123456789&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">453gopher
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimRightFunc">func <a href="/src/bytes/bytes.go?s=20828:20884#L796">TrimRightFunc</a>
				<a class="permalink" href="#TrimRightFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func TrimRightFunc(s []<a href="/pkg/builtin/#byte">byte</a>, f func(r <a href="/pkg/builtin/#rune">rune</a>) <a href="/pkg/builtin/#bool">bool</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>TrimRightFunc returns a subslice of s by slicing off all trailing
UTF-8-encoded code points c that satisfy f(c).

			<div id="example_TrimRightFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(string(bytes.TrimRightFunc([]byte(&#34;go-gopher&#34;), unicode.IsLetter)))
fmt.Println(string(bytes.TrimRightFunc([]byte(&#34;go-gopher!&#34;), unicode.IsPunct)))
fmt.Println(string(bytes.TrimRightFunc([]byte(&#34;1234go-gopher!567&#34;), unicode.IsNumber)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">go-
go-gopher
1234go-gopher!
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimSpace">func <a href="/src/bytes/bytes.go?s=27208:27239#L1050">TrimSpace</a>
				<a class="permalink" href="#TrimSpace">&#xb6;</a>
				
				
			</h2>
			<pre>func TrimSpace(s []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>TrimSpace returns a subslice of s by slicing off all leading and
trailing white space, as defined by Unicode.

			<div id="example_TrimSpace" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Printf(&#34;%s&#34;, bytes.TrimSpace([]byte(&#34; \t\n a lone gopher \n\t\r\n&#34;)))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">a lone gopher
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="TrimSuffix">func <a href="/src/bytes/bytes.go?s=21635:21675#L824">TrimSuffix</a>
				<a class="permalink" href="#TrimSuffix">&#xb6;</a>
				
				<span title="Added in Go 1.1">1.1</span>
			</h2>
			<pre>func TrimSuffix(s, suffix []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
			<p>TrimSuffix returns s without the provided trailing suffix string.
If s doesn&apos;t end with suffix, s is returned unchanged.

			<div id="example_TrimSuffix" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">var b = []byte(&#34;Hello, goodbye, etc!&#34;)
b = bytes.TrimSuffix(b, []byte(&#34;goodbye, etc!&#34;))
b = bytes.TrimSuffix(b, []byte(&#34;gopher&#34;))
b = append(b, bytes.TrimSuffix([]byte(&#34;world!&#34;), []byte(&#34;x!&#34;))...)
os.Stdout.Write(b)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Hello, world!
</pre>
			
		
	</div>
</div>

			

		
		
			
			
			<h2 id="Buffer">type <a href="/src/bytes/buffer.go?s=510:735#L10">Buffer</a>
				<a class="permalink" href="#Buffer">&#xb6;</a>
				
				
			</h2>
			<p>A Buffer is a variable-sized buffer of bytes with <a href="#Buffer.Read">Buffer.Read</a> and <a href="#Buffer.Write">Buffer.Write</a> methods.
The zero value for Buffer is an empty buffer ready to use.

			<pre>type Buffer struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Buffer" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">var b bytes.Buffer <span class="comment">// A Buffer needs no initialization.</span>
b.Write([]byte(&#34;Hello &#34;))
fmt.Fprintf(&amp;b, &#34;world!&#34;)
b.WriteTo(os.Stdout)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Hello world!
</pre>
			
		
	</div>
</div>
<div id="example_Buffer_reader" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Reader)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Reader)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// A Buffer can turn a string or a []byte into an io.Reader.</span>
buf := bytes.NewBufferString(&#34;R29waGVycyBydWxlIQ==&#34;)
dec := base64.NewDecoder(base64.StdEncoding, buf)
io.Copy(os.Stdout, dec)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Gophers rule!
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="NewBuffer">func <a href="/src/bytes/buffer.go?s=15681:15715#L462">NewBuffer</a>
					<a class="permalink" href="#NewBuffer">&#xb6;</a>
					
					
				</h3>
				<pre>func NewBuffer(buf []<a href="/pkg/builtin/#byte">byte</a>) *<a href="#Buffer">Buffer</a></pre>
				<p>NewBuffer creates and initializes a new <a href="#Buffer">Buffer</a> using buf as its
initial contents. The new <a href="#Buffer">Buffer</a> takes ownership of buf, and the
caller should not use buf after this call. NewBuffer is intended to
prepare a <a href="#Buffer">Buffer</a> to read existing data. It can also be used to set
the initial size of the internal buffer for writing. To do that,
buf should have the desired capacity but a length of zero.
<p>In most cases, new(<a href="#Buffer">Buffer</a>) (or just declaring a <a href="#Buffer">Buffer</a> variable) is
sufficient to initialize a <a href="#Buffer">Buffer</a>.

				
				
			
				
				<h3 id="NewBufferString">func <a href="/src/bytes/buffer.go?s=16031:16069#L470">NewBufferString</a>
					<a class="permalink" href="#NewBufferString">&#xb6;</a>
					
					
				</h3>
				<pre>func NewBufferString(s <a href="/pkg/builtin/#string">string</a>) *<a href="#Buffer">Buffer</a></pre>
				<p>NewBufferString creates and initializes a new <a href="#Buffer">Buffer</a> using string s as its
initial contents. It is intended to prepare a buffer to read an existing
string.
<p>In most cases, new(<a href="#Buffer">Buffer</a>) (or just declaring a <a href="#Buffer">Buffer</a> variable) is
sufficient to initialize a <a href="#Buffer">Buffer</a>.

				
				
			

			
				
				<h3 id="Buffer.Available">func (*Buffer) <a href="/src/bytes/buffer.go?s=3432:3464#L76">Available</a>
					<a class="permalink" href="#Buffer.Available">&#xb6;</a>
					
					<span title="Added in Go 1.21">1.21</span>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Available() <a href="/pkg/builtin/#int">int</a></pre>
				<p>Available returns how many bytes are unused in the buffer.

				
				
				
			
				
				<h3 id="Buffer.AvailableBuffer">func (*Buffer) <a href="/src/bytes/buffer.go?s=2476:2517#L50">AvailableBuffer</a>
					<a class="permalink" href="#Buffer.AvailableBuffer">&#xb6;</a>
					
					<span title="Added in Go 1.21">1.21</span>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) AvailableBuffer() []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>AvailableBuffer returns an empty buffer with b.Available() capacity.
This buffer is intended to be appended to and
passed to an immediately succeeding <a href="#Buffer.Write">Buffer.Write</a> call.
The buffer is only valid until the next write operation on b.

				
				<div id="example_Buffer_AvailableBuffer" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">var buf bytes.Buffer
for i := 0; i &lt; 4; i++ {
    b := buf.AvailableBuffer()
    b = strconv.AppendInt(b, int64(i), 10)
    b = append(b, &#39; &#39;)
    buf.Write(b)
}
os.Stdout.Write(buf.Bytes())
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">0 1 2 3
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Buffer.Bytes">func (*Buffer) <a href="/src/bytes/buffer.go?s=2172:2203#L44">Bytes</a>
					<a class="permalink" href="#Buffer.Bytes">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Bytes() []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>Bytes returns a slice of length b.Len() holding the unread portion of the buffer.
The slice is valid for use only until the next buffer modification (that is,
only until the next call to a method like <a href="#Buffer.Read">Buffer.Read</a>, <a href="#Buffer.Write">Buffer.Write</a>, <a href="#Buffer.Reset">Buffer.Reset</a>, or <a href="#Buffer.Truncate">Buffer.Truncate</a>).
The slice aliases the buffer content at least until the next buffer modification,
so immediate changes to the slice will affect the result of future reads.

				
				<div id="example_Buffer_Bytes" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">buf := bytes.Buffer{}
buf.Write([]byte{&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;})
os.Stdout.Write(buf.Bytes())
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">hello world
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Buffer.Cap">func (*Buffer) <a href="/src/bytes/buffer.go?s=3320:3346#L73">Cap</a>
					<a class="permalink" href="#Buffer.Cap">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Cap() <a href="/pkg/builtin/#int">int</a></pre>
				<p>Cap returns the capacity of the buffer&apos;s underlying byte slice, that is, the
total space allocated for the buffer&apos;s data.

				
				<div id="example_Buffer_Cap" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">buf1 := bytes.NewBuffer(make([]byte, 10))
buf2 := bytes.NewBuffer(make([]byte, 0, 10))
fmt.Println(buf1.Cap())
fmt.Println(buf2.Cap())
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">10
10
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Buffer.Grow">func (*Buffer) <a href="/src/bytes/buffer.go?s=5815:5843#L154">Grow</a>
					<a class="permalink" href="#Buffer.Grow">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Grow(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Grow grows the buffer&apos;s capacity, if necessary, to guarantee space for
another n bytes. After Grow(n), at least n bytes can be written to the
buffer without another allocation.
If n is negative, Grow will panic.
If the buffer can&apos;t grow it will panic with <a href="#ErrTooLarge">ErrTooLarge</a>.

				
				<div id="example_Buffer_Grow" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">var b bytes.Buffer
b.Grow(64)
bb := b.Bytes()
b.Write([]byte(&#34;64 bytes or fewer&#34;))
fmt.Printf(&#34;%q&#34;, bb[:b.Len()])
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">&#34;64 bytes or fewer&#34;
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Buffer.Len">func (*Buffer) <a href="/src/bytes/buffer.go?s=3134:3160#L69">Len</a>
					<a class="permalink" href="#Buffer.Len">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Len() <a href="/pkg/builtin/#int">int</a></pre>
				<p>Len returns the number of bytes of the unread portion of the buffer;
b.Len() == len(b.Bytes()).

				
				<div id="example_Buffer_Len" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">var b bytes.Buffer
b.Grow(64)
b.Write([]byte(&#34;abcde&#34;))
fmt.Printf(&#34;%d&#34;, b.Len())
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">5
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Buffer.Next">func (*Buffer) <a href="/src/bytes/buffer.go?s=11408:11443#L330">Next</a>
					<a class="permalink" href="#Buffer.Next">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Next(n <a href="/pkg/builtin/#int">int</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>Next returns a slice containing the next n bytes from the buffer,
advancing the buffer as if the bytes had been returned by <a href="#Buffer.Read">Buffer.Read</a>.
If there are fewer than n bytes in the buffer, Next returns the entire buffer.
The slice is only valid until the next call to a read or write method.

				
				<div id="example_Buffer_Next" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">var b bytes.Buffer
b.Grow(64)
b.Write([]byte(&#34;abcde&#34;))
fmt.Printf(&#34;%s\n&#34;, b.Next(2))
fmt.Printf(&#34;%s\n&#34;, b.Next(2))
fmt.Printf(&#34;%s&#34;, b.Next(2))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">ab
cd
e
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Buffer.Read">func (*Buffer) <a href="/src/bytes/buffer.go?s=10799:10849#L308">Read</a>
					<a class="permalink" href="#Buffer.Read">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Read(p []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Read reads the next len(p) bytes from the buffer or until the buffer
is drained. The return value n is the number of bytes read. If the
buffer has no data to return, err is <a href="/io#EOF">io.EOF</a> (unless len(p) is zero);
otherwise it is nil.

				
				<div id="example_Buffer_Read" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">var b bytes.Buffer
b.Grow(64)
b.Write([]byte(&#34;abcde&#34;))
rdbuf := make([]byte, 1)
n, err := b.Read(rdbuf)
if err != nil {
    panic(err)
}
fmt.Println(n)
fmt.Println(b.String())
fmt.Println(string(rdbuf))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">1
bcde
a
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Buffer.ReadByte">func (*Buffer) <a href="/src/bytes/buffer.go?s=11720:11761#L346">ReadByte</a>
					<a class="permalink" href="#Buffer.ReadByte">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) ReadByte() (<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadByte reads and returns the next byte from the buffer.
If no byte is available, it returns error <a href="/io#EOF">io.EOF</a>.

				
				<div id="example_Buffer_ReadByte" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">var b bytes.Buffer
b.Grow(64)
b.Write([]byte(&#34;abcde&#34;))
c, err := b.ReadByte()
if err != nil {
    panic(err)
}
fmt.Println(c)
fmt.Println(b.String())
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">97
bcde
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Buffer.ReadBytes">func (*Buffer) <a href="/src/bytes/buffer.go?s=14051:14114#L420">ReadBytes</a>
					<a class="permalink" href="#Buffer.ReadBytes">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) ReadBytes(delim <a href="/pkg/builtin/#byte">byte</a>) (line []<a href="/pkg/builtin/#byte">byte</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadBytes reads until the first occurrence of delim in the input,
returning a slice containing the data up to and including the delimiter.
If ReadBytes encounters an error before finding a delimiter,
it returns the data read before the error and the error itself (often <a href="/io#EOF">io.EOF</a>).
ReadBytes returns err != nil if and only if the returned data does not end in
delim.

				
				
				
			
				
				<h3 id="Buffer.ReadFrom">func (*Buffer) <a href="/src/bytes/buffer.go?s=7335:7394#L196">ReadFrom</a>
					<a class="permalink" href="#Buffer.ReadFrom">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) ReadFrom(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>) (n <a href="/pkg/builtin/#int64">int64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadFrom reads data from r until EOF and appends it to the buffer, growing
the buffer as needed. The return value n is the number of bytes read. Any
error except io.EOF encountered during the read is also returned. If the
buffer becomes too large, ReadFrom will panic with <a href="#ErrTooLarge">ErrTooLarge</a>.

				
				
				
			
				
				<h3 id="Buffer.ReadRune">func (*Buffer) <a href="/src/bytes/buffer.go?s=12175:12232#L363">ReadRune</a>
					<a class="permalink" href="#Buffer.ReadRune">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) ReadRune() (r <a href="/pkg/builtin/#rune">rune</a>, size <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadRune reads and returns the next UTF-8-encoded
Unicode code point from the buffer.
If no bytes are available, the error returned is io.EOF.
If the bytes are an erroneous UTF-8 encoding, it
consumes one byte and returns U+FFFD, 1.

				
				
				
			
				
				<h3 id="Buffer.ReadString">func (*Buffer) <a href="/src/bytes/buffer.go?s=15020:15084#L448">ReadString</a>
					<a class="permalink" href="#Buffer.ReadString">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) ReadString(delim <a href="/pkg/builtin/#byte">byte</a>) (line <a href="/pkg/builtin/#string">string</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadString reads until the first occurrence of delim in the input,
returning a string containing the data up to and including the delimiter.
If ReadString encounters an error before finding a delimiter,
it returns the data read before the error and the error itself (often <a href="/io#EOF">io.EOF</a>).
ReadString returns err != nil if and only if the returned data does not end
in delim.

				
				
				
			
				
				<h3 id="Buffer.Reset">func (*Buffer) <a href="/src/bytes/buffer.go?s=4051:4075#L96">Reset</a>
					<a class="permalink" href="#Buffer.Reset">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Reset()</pre>
				<p>Reset resets the buffer to be empty,
but it retains the underlying storage for use by future writes.
Reset is the same as <a href="#Buffer.Truncate">Buffer.Truncate</a>(0).

				
				
				
			
				
				<h3 id="Buffer.String">func (*Buffer) <a href="/src/bytes/buffer.go?s=2759:2791#L56">String</a>
					<a class="permalink" href="#Buffer.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>String returns the contents of the unread portion of the buffer
as a string. If the <a href="#Buffer">Buffer</a> is a nil pointer, it returns &quot;&lt;nil&gt;&quot;.
<p>To build strings more efficiently, see the <a href="/strings#Builder">strings.Builder</a> type.

				
				
				
			
				
				<h3 id="Buffer.Truncate">func (*Buffer) <a href="/src/bytes/buffer.go?s=3695:3727#L81">Truncate</a>
					<a class="permalink" href="#Buffer.Truncate">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Truncate(n <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Truncate discards all but the first n unread bytes from the buffer
but continues to use the same allocated storage.
It panics if n is negative or greater than the length of the buffer.

				
				
				
			
				
				<h3 id="Buffer.UnreadByte">func (*Buffer) <a href="/src/bytes/buffer.go?s=13505:13540#L403">UnreadByte</a>
					<a class="permalink" href="#Buffer.UnreadByte">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) UnreadByte() <a href="/pkg/builtin/#error">error</a></pre>
				<p>UnreadByte unreads the last byte returned by the most recent successful
read operation that read at least one byte. If a write has happened since
the last read, if the last read returned an error, or if the read read zero
bytes, UnreadByte returns an error.

				
				
				
			
				
				<h3 id="Buffer.UnreadRune">func (*Buffer) <a href="/src/bytes/buffer.go?s=12860:12895#L386">UnreadRune</a>
					<a class="permalink" href="#Buffer.UnreadRune">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) UnreadRune() <a href="/pkg/builtin/#error">error</a></pre>
				<p>UnreadRune unreads the last rune returned by <a href="#Buffer.ReadRune">Buffer.ReadRune</a>.
If the most recent read or write operation on the buffer was
not a successful <a href="#Buffer.ReadRune">Buffer.ReadRune</a>, UnreadRune returns an error.  (In this regard
it is stricter than <a href="#Buffer.UnreadByte">Buffer.UnreadByte</a>, which will unread the last byte
from any read operation.)

				
				
				
			
				
				<h3 id="Buffer.Write">func (*Buffer) <a href="/src/bytes/buffer.go?s=6158:6209#L165">Write</a>
					<a class="permalink" href="#Buffer.Write">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) Write(p []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Write appends the contents of p to the buffer, growing the buffer as
needed. The return value n is the length of p; err is always nil. If the
buffer becomes too large, Write will panic with <a href="#ErrTooLarge">ErrTooLarge</a>.

				
				
				
			
				
				<h3 id="Buffer.WriteByte">func (*Buffer) <a href="/src/bytes/buffer.go?s=9746:9786#L275">WriteByte</a>
					<a class="permalink" href="#Buffer.WriteByte">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) WriteByte(c <a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>WriteByte appends the byte c to the buffer, growing the buffer as needed.
The returned error is always nil, but is included to match <a href="/bufio#Writer">bufio.Writer</a>&apos;s
WriteByte. If the buffer becomes too large, WriteByte will panic with
<a href="#ErrTooLarge">ErrTooLarge</a>.

				
				
				
			
				
				<h3 id="Buffer.WriteRune">func (*Buffer) <a href="/src/bytes/buffer.go?s=10196:10249#L289">WriteRune</a>
					<a class="permalink" href="#Buffer.WriteRune">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) WriteRune(r <a href="/pkg/builtin/#rune">rune</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteRune appends the UTF-8 encoding of Unicode code point r to the
buffer, returning its length and an error, which is always nil but is
included to match <a href="/bufio#Writer">bufio.Writer</a>&apos;s WriteRune. The buffer is grown as needed;
if it becomes too large, WriteRune will panic with <a href="#ErrTooLarge">ErrTooLarge</a>.

				
				
				
			
				
				<h3 id="Buffer.WriteString">func (*Buffer) <a href="/src/bytes/buffer.go?s=6568:6625#L177">WriteString</a>
					<a class="permalink" href="#Buffer.WriteString">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) WriteString(s <a href="/pkg/builtin/#string">string</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteString appends the contents of s to the buffer, growing the buffer as
needed. The return value n is the length of s; err is always nil. If the
buffer becomes too large, WriteString will panic with <a href="#ErrTooLarge">ErrTooLarge</a>.

				
				
				
			
				
				<h3 id="Buffer.WriteTo">func (*Buffer) <a href="/src/bytes/buffer.go?s=9000:9058#L248">WriteTo</a>
					<a class="permalink" href="#Buffer.WriteTo">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#Buffer">Buffer</a>) WriteTo(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>) (n <a href="/pkg/builtin/#int64">int64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteTo writes data to w until the buffer is drained or an error occurs.
The return value n is the number of bytes written; it always fits into an
int, but it is int64 to match the <a href="/io#WriterTo">io.WriterTo</a> interface. Any error
encountered during the write is also returned.

				
				
				
			
		
			
			
			<h2 id="Reader">type <a href="/src/bytes/reader.go?s=525:655#L8">Reader</a>
				<a class="permalink" href="#Reader">&#xb6;</a>
				
				
			</h2>
			<p>A Reader implements the <a href="/io#Reader">io.Reader</a>, <a href="/io#ReaderAt">io.ReaderAt</a>, <a href="/io#WriterTo">io.WriterTo</a>, <a href="/io#Seeker">io.Seeker</a>,
<a href="/io#ByteScanner">io.ByteScanner</a>, and <a href="/io#RuneScanner">io.RuneScanner</a> interfaces by reading from
a byte slice.
Unlike a <a href="#Buffer">Buffer</a>, a Reader is read-only and supports seeking.
The zero value for Reader operates like a Reader of an empty slice.

			<pre>type Reader struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewReader">func <a href="/src/bytes/reader.go?s=3915:3947#L149">NewReader</a>
					<a class="permalink" href="#NewReader">&#xb6;</a>
					
					
				</h3>
				<pre>func NewReader(b []<a href="/pkg/builtin/#byte">byte</a>) *<a href="#Reader">Reader</a></pre>
				<p>NewReader returns a new <a href="#Reader">Reader</a> reading from b.

				
				
			

			
				
				<h3 id="Reader.Len">func (*Reader) <a href="/src/bytes/reader.go?s=731:757#L16">Len</a>
					<a class="permalink" href="#Reader.Len">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) Len() <a href="/pkg/builtin/#int">int</a></pre>
				<p>Len returns the number of bytes of the unread portion of the
slice.

				
				<div id="example_Reader_Len" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(bytes.NewReader([]byte(&#34;Hi!&#34;)).Len())
fmt.Println(bytes.NewReader([]byte(&#34;こんにちは!&#34;)).Len())
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">3
16
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="Reader.Read">func (*Reader) <a href="/src/bytes/reader.go?s=1156:1206#L29">Read</a>
					<a class="permalink" href="#Reader.Read">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) Read(b []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Read implements the <a href="/io#Reader">io.Reader</a> interface.

				
				
				
			
				
				<h3 id="Reader.ReadAt">func (*Reader) <a href="/src/bytes/reader.go?s=1379:1442#L40">ReadAt</a>
					<a class="permalink" href="#Reader.ReadAt">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) ReadAt(b []<a href="/pkg/builtin/#byte">byte</a>, off <a href="/pkg/builtin/#int64">int64</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadAt implements the <a href="/io#ReaderAt">io.ReaderAt</a> interface.

				
				
				
			
				
				<h3 id="Reader.ReadByte">func (*Reader) <a href="/src/bytes/reader.go?s=1742:1783#L56">ReadByte</a>
					<a class="permalink" href="#Reader.ReadByte">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) ReadByte() (<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadByte implements the <a href="/io#ByteReader">io.ByteReader</a> interface.

				
				
				
			
				
				<h3 id="Reader.ReadRune">func (*Reader) <a href="/src/bytes/reader.go?s=2205:2263#L77">ReadRune</a>
					<a class="permalink" href="#Reader.ReadRune">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) ReadRune() (ch <a href="/pkg/builtin/#rune">rune</a>, size <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadRune implements the <a href="/io#RuneReader">io.RuneReader</a> interface.

				
				
				
			
				
				<h3 id="Reader.Reset">func (*Reader) <a href="/src/bytes/reader.go?s=3803:3835#L146">Reset</a>
					<a class="permalink" href="#Reader.Reset">&#xb6;</a>
					
					<span title="Added in Go 1.7">1.7</span>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) Reset(b []<a href="/pkg/builtin/#byte">byte</a>)</pre>
				<p>Reset resets the <a href="#Reader">Reader</a> to be reading from b.

				
				
				
			
				
				<h3 id="Reader.Seek">func (*Reader) <a href="/src/bytes/reader.go?s=2935:2997#L106">Seek</a>
					<a class="permalink" href="#Reader.Seek">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) Seek(offset <a href="/pkg/builtin/#int64">int64</a>, whence <a href="/pkg/builtin/#int">int</a>) (<a href="/pkg/builtin/#int64">int64</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Seek implements the <a href="/io#Seeker">io.Seeker</a> interface.

				
				
				
			
				
				<h3 id="Reader.Size">func (*Reader) <a href="/src/bytes/reader.go?s=1052:1081#L26">Size</a>
					<a class="permalink" href="#Reader.Size">&#xb6;</a>
					
					<span title="Added in Go 1.5">1.5</span>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) Size() <a href="/pkg/builtin/#int64">int64</a></pre>
				<p>Size returns the original length of the underlying byte slice.
Size is the number of bytes available for reading via <a href="#Reader.ReadAt">Reader.ReadAt</a>.
The result is unaffected by any method calls except <a href="#Reader.Reset">Reader.Reset</a>.

				
				
				
			
				
				<h3 id="Reader.UnreadByte">func (*Reader) <a href="/src/bytes/reader.go?s=1986:2021#L67">UnreadByte</a>
					<a class="permalink" href="#Reader.UnreadByte">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) UnreadByte() <a href="/pkg/builtin/#error">error</a></pre>
				<p>UnreadByte complements <a href="#Reader.ReadByte">Reader.ReadByte</a> in implementing the <a href="/io#ByteScanner">io.ByteScanner</a> interface.

				
				
				
			
				
				<h3 id="Reader.UnreadRune">func (*Reader) <a href="/src/bytes/reader.go?s=2598:2633#L93">UnreadRune</a>
					<a class="permalink" href="#Reader.UnreadRune">&#xb6;</a>
					
					
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) UnreadRune() <a href="/pkg/builtin/#error">error</a></pre>
				<p>UnreadRune complements <a href="#Reader.ReadRune">Reader.ReadRune</a> in implementing the <a href="/io#RuneScanner">io.RuneScanner</a> interface.

				
				
				
			
				
				<h3 id="Reader.WriteTo">func (*Reader) <a href="/src/bytes/reader.go?s=3413:3471#L127">WriteTo</a>
					<a class="permalink" href="#Reader.WriteTo">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (r *<a href="#Reader">Reader</a>) WriteTo(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>) (n <a href="/pkg/builtin/#int64">int64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteTo implements the <a href="/io#WriterTo">io.WriterTo</a> interface.

				
				
				
			
		
	

	







<div id="footer">
Build version go1.23.0.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
