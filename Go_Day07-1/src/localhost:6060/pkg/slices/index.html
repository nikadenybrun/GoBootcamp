<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>slices - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.23.0";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package slices
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "slices"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package slices defines various functions useful with slices of any type.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#All">func All[Slice ~[]E, E any](s Slice) iter.Seq2[int, E]</a></dd>
			
				
				<dd><a href="#AppendSeq">func AppendSeq[Slice ~[]E, E any](s Slice, seq iter.Seq[E]) Slice</a></dd>
			
				
				<dd><a href="#Backward">func Backward[Slice ~[]E, E any](s Slice) iter.Seq2[int, E]</a></dd>
			
				
				<dd><a href="#BinarySearch">func BinarySearch[S ~[]E, E cmp.Ordered](x S, target E) (int, bool)</a></dd>
			
				
				<dd><a href="#BinarySearchFunc">func BinarySearchFunc[S ~[]E, E, T any](x S, target T, cmp func(E, T) int) (int, bool)</a></dd>
			
				
				<dd><a href="#Chunk">func Chunk[Slice ~[]E, E any](s Slice, n int) iter.Seq[Slice]</a></dd>
			
				
				<dd><a href="#Clip">func Clip[S ~[]E, E any](s S) S</a></dd>
			
				
				<dd><a href="#Clone">func Clone[S ~[]E, E any](s S) S</a></dd>
			
				
				<dd><a href="#Collect">func Collect[E any](seq iter.Seq[E]) []E</a></dd>
			
				
				<dd><a href="#Compact">func Compact[S ~[]E, E comparable](s S) S</a></dd>
			
				
				<dd><a href="#CompactFunc">func CompactFunc[S ~[]E, E any](s S, eq func(E, E) bool) S</a></dd>
			
				
				<dd><a href="#Compare">func Compare[S ~[]E, E cmp.Ordered](s1, s2 S) int</a></dd>
			
				
				<dd><a href="#CompareFunc">func CompareFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, cmp func(E1, E2) int) int</a></dd>
			
				
				<dd><a href="#Concat">func Concat[S ~[]E, E any](slices ...S) S</a></dd>
			
				
				<dd><a href="#Contains">func Contains[S ~[]E, E comparable](s S, v E) bool</a></dd>
			
				
				<dd><a href="#ContainsFunc">func ContainsFunc[S ~[]E, E any](s S, f func(E) bool) bool</a></dd>
			
				
				<dd><a href="#Delete">func Delete[S ~[]E, E any](s S, i, j int) S</a></dd>
			
				
				<dd><a href="#DeleteFunc">func DeleteFunc[S ~[]E, E any](s S, del func(E) bool) S</a></dd>
			
				
				<dd><a href="#Equal">func Equal[S ~[]E, E comparable](s1, s2 S) bool</a></dd>
			
				
				<dd><a href="#EqualFunc">func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool</a></dd>
			
				
				<dd><a href="#Grow">func Grow[S ~[]E, E any](s S, n int) S</a></dd>
			
				
				<dd><a href="#Index">func Index[S ~[]E, E comparable](s S, v E) int</a></dd>
			
				
				<dd><a href="#IndexFunc">func IndexFunc[S ~[]E, E any](s S, f func(E) bool) int</a></dd>
			
				
				<dd><a href="#Insert">func Insert[S ~[]E, E any](s S, i int, v ...E) S</a></dd>
			
				
				<dd><a href="#IsSorted">func IsSorted[S ~[]E, E cmp.Ordered](x S) bool</a></dd>
			
				
				<dd><a href="#IsSortedFunc">func IsSortedFunc[S ~[]E, E any](x S, cmp func(a, b E) int) bool</a></dd>
			
				
				<dd><a href="#Max">func Max[S ~[]E, E cmp.Ordered](x S) E</a></dd>
			
				
				<dd><a href="#MaxFunc">func MaxFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E</a></dd>
			
				
				<dd><a href="#Min">func Min[S ~[]E, E cmp.Ordered](x S) E</a></dd>
			
				
				<dd><a href="#MinFunc">func MinFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E</a></dd>
			
				
				<dd><a href="#Repeat">func Repeat[S ~[]E, E any](x S, count int) S</a></dd>
			
				
				<dd><a href="#Replace">func Replace[S ~[]E, E any](s S, i, j int, v ...E) S</a></dd>
			
				
				<dd><a href="#Reverse">func Reverse[S ~[]E, E any](s S)</a></dd>
			
				
				<dd><a href="#Sort">func Sort[S ~[]E, E cmp.Ordered](x S)</a></dd>
			
				
				<dd><a href="#SortFunc">func SortFunc[S ~[]E, E any](x S, cmp func(a, b E) int)</a></dd>
			
				
				<dd><a href="#SortStableFunc">func SortStableFunc[S ~[]E, E any](x S, cmp func(a, b E) int)</a></dd>
			
				
				<dd><a href="#Sorted">func Sorted[E cmp.Ordered](seq iter.Seq[E]) []E</a></dd>
			
				
				<dd><a href="#SortedFunc">func SortedFunc[E any](seq iter.Seq[E], cmp func(E, E) int) []E</a></dd>
			
				
				<dd><a href="#SortedStableFunc">func SortedStableFunc[E any](seq iter.Seq[E], cmp func(E, E) int) []E</a></dd>
			
				
				<dd><a href="#Values">func Values[Slice ~[]E, E any](s Slice) iter.Seq[E]</a></dd>
			
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="#example_BinarySearch">BinarySearch</a></dd>
			
			<dd><a class="exampleLink" href="#example_BinarySearchFunc">BinarySearchFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_Chunk">Chunk</a></dd>
			
			<dd><a class="exampleLink" href="#example_Clip">Clip</a></dd>
			
			<dd><a class="exampleLink" href="#example_Clone">Clone</a></dd>
			
			<dd><a class="exampleLink" href="#example_Compact">Compact</a></dd>
			
			<dd><a class="exampleLink" href="#example_CompactFunc">CompactFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_Compare">Compare</a></dd>
			
			<dd><a class="exampleLink" href="#example_CompareFunc">CompareFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_Concat">Concat</a></dd>
			
			<dd><a class="exampleLink" href="#example_Contains">Contains</a></dd>
			
			<dd><a class="exampleLink" href="#example_ContainsFunc">ContainsFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_Delete">Delete</a></dd>
			
			<dd><a class="exampleLink" href="#example_DeleteFunc">DeleteFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_Equal">Equal</a></dd>
			
			<dd><a class="exampleLink" href="#example_EqualFunc">EqualFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_Grow">Grow</a></dd>
			
			<dd><a class="exampleLink" href="#example_Index">Index</a></dd>
			
			<dd><a class="exampleLink" href="#example_IndexFunc">IndexFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_Insert">Insert</a></dd>
			
			<dd><a class="exampleLink" href="#example_IsSorted">IsSorted</a></dd>
			
			<dd><a class="exampleLink" href="#example_IsSortedFunc">IsSortedFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_Max">Max</a></dd>
			
			<dd><a class="exampleLink" href="#example_MaxFunc">MaxFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_Min">Min</a></dd>
			
			<dd><a class="exampleLink" href="#example_MinFunc">MinFunc</a></dd>
			
			<dd><a class="exampleLink" href="#example_Repeat">Repeat</a></dd>
			
			<dd><a class="exampleLink" href="#example_Replace">Replace</a></dd>
			
			<dd><a class="exampleLink" href="#example_Reverse">Reverse</a></dd>
			
			<dd><a class="exampleLink" href="#example_Sort">Sort</a></dd>
			
			<dd><a class="exampleLink" href="#example_SortFunc_caseInsensitive">SortFunc (CaseInsensitive)</a></dd>
			
			<dd><a class="exampleLink" href="#example_SortFunc_multiField">SortFunc (MultiField)</a></dd>
			
			<dd><a class="exampleLink" href="#example_SortStableFunc">SortStableFunc</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/slices/iter.go">iter.go</a>
			
				<a href="/src/slices/slices.go">slices.go</a>
			
				<a href="/src/slices/sort.go">sort.go</a>
			
				<a href="/src/slices/zsortanyfunc.go">zsortanyfunc.go</a>
			
				<a href="/src/slices/zsortordered.go">zsortordered.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
		
			
			
			<h2 id="All">func <a href="/src/slices/iter.go?s=289:343#L4">All</a>
				<a class="permalink" href="#All">&#xb6;</a>
				
				
			</h2>
			<pre>func All[Slice ~[]E, E <a href="/pkg/builtin/#any">any</a>](s Slice) <a href="/pkg/iter/">iter</a>.<a href="/pkg/iter/#Seq2">Seq2</a>[<a href="/pkg/builtin/#int">int</a>, E]</pre>
			<p>All returns an iterator over index-value pairs in the slice
in the usual order.

			
			

		
			
			
			<h2 id="AppendSeq">func <a href="/src/slices/iter.go?s=1083:1148#L39">AppendSeq</a>
				<a class="permalink" href="#AppendSeq">&#xb6;</a>
				
				
			</h2>
			<pre>func AppendSeq[Slice ~[]E, E <a href="/pkg/builtin/#any">any</a>](s Slice, seq <a href="/pkg/iter/">iter</a>.<a href="/pkg/iter/#Seq">Seq</a>[E]) Slice</pre>
			<p>AppendSeq appends the values from seq to the slice and
returns the extended slice.

			
			

		
			
			
			<h2 id="Backward">func <a href="/src/slices/iter.go?s=577:636#L16">Backward</a>
				<a class="permalink" href="#Backward">&#xb6;</a>
				
				
			</h2>
			<pre>func Backward[Slice ~[]E, E <a href="/pkg/builtin/#any">any</a>](s Slice) <a href="/pkg/iter/">iter</a>.<a href="/pkg/iter/#Seq2">Seq2</a>[<a href="/pkg/builtin/#int">int</a>, E]</pre>
			<p>Backward returns an iterator over index-value pairs in the slice,
traversing it backward with descending indices.

			
			

		
			
			
			<h2 id="BinarySearch">func <a href="/src/slices/sort.go?s=3730:3797#L116">BinarySearch</a>
				<a class="permalink" href="#BinarySearch">&#xb6;</a>
				
				
			</h2>
			<pre>func BinarySearch[S ~[]E, E <a href="/pkg/cmp/">cmp</a>.<a href="/pkg/cmp/#Ordered">Ordered</a>](x S, target E) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>BinarySearch searches for target in a sorted slice and returns the earliest
position where target is found, or the position where target would appear
in the sort order; it also returns a bool saying whether the target is
really found in the slice. The slice must be sorted in increasing order.

			<div id="example_BinarySearch" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">names := []string{&#34;Alice&#34;, &#34;Bob&#34;, &#34;Vera&#34;}
n, found := slices.BinarySearch(names, &#34;Vera&#34;)
fmt.Println(&#34;Vera:&#34;, n, found)
n, found = slices.BinarySearch(names, &#34;Bill&#34;)
fmt.Println(&#34;Bill:&#34;, n, found)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Vera: 2 true
Bill: 1 false
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="BinarySearchFunc">func <a href="/src/slices/sort.go?s=4862:4948#L142">BinarySearchFunc</a>
				<a class="permalink" href="#BinarySearchFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func BinarySearchFunc[S ~[]E, E, T <a href="/pkg/builtin/#any">any</a>](x S, target T, cmp func(E, T) <a href="/pkg/builtin/#int">int</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>BinarySearchFunc works like <a href="#BinarySearch">BinarySearch</a>, but uses a custom comparison
function. The slice must be sorted in increasing order, where &quot;increasing&quot;
is defined by cmp. cmp should return 0 if the slice element matches
the target, a negative number if the slice element precedes the target,
or a positive number if the slice element follows the target.
cmp must implement the same ordering as the slice, such that if
cmp(a, t) &lt; 0 and cmp(b, t) &gt;= 0, then a must precede b in the slice.

			<div id="example_BinarySearchFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">type Person struct {
    Name string
    Age  int
}
people := []Person{
    {&#34;Alice&#34;, 55},
    {&#34;Bob&#34;, 24},
    {&#34;Gopher&#34;, 13},
}
n, found := slices.BinarySearchFunc(people, Person{&#34;Bob&#34;, 0}, func(a, b Person) int {
    return strings.Compare(a.Name, b.Name)
})
fmt.Println(&#34;Bob:&#34;, n, found)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Bob: 1 true
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Chunk">func <a href="/src/slices/iter.go?s=2447:2508#L82">Chunk</a>
				<a class="permalink" href="#Chunk">&#xb6;</a>
				
				
			</h2>
			<pre>func Chunk[Slice ~[]E, E <a href="/pkg/builtin/#any">any</a>](s Slice, n <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/iter/">iter</a>.<a href="/pkg/iter/#Seq">Seq</a>[Slice]</pre>
			<p>Chunk returns an iterator over consecutive sub-slices of up to n elements of s.
All but the last sub-slice will have size n.
All sub-slices are clipped to have no capacity beyond the length.
If s is empty, the sequence is empty: there is no empty slice in the sequence.
Chunk panics if n is less than 1.

			<div id="example_Chunk" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">type Person struct {
    Name string
    Age  int
}

type People []Person

people := People{
    {&#34;Gopher&#34;, 13},
    {&#34;Alice&#34;, 20},
    {&#34;Bob&#34;, 5},
    {&#34;Vera&#34;, 24},
    {&#34;Zac&#34;, 15},
}

<span class="comment">// Chunk people into []Person 2 elements at a time.</span>
for c := range slices.Chunk(people, 2) {
    fmt.Println(c)
}

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[{Gopher 13} {Alice 20}]
[{Bob 5} {Vera 24}]
[{Zac 15}]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Clip">func <a href="/src/slices/slices.go?s=11339:11370#L408">Clip</a>
				<a class="permalink" href="#Clip">&#xb6;</a>
				
				
			</h2>
			<pre>func Clip[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](s S) S</pre>
			<p>Clip removes unused capacity from the slice, returning s[:len(s):len(s)].

			<div id="example_Clip" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">a := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
s := a[:4:10]
clip := slices.Clip(s)
fmt.Println(cap(s))
fmt.Println(clip)
fmt.Println(len(clip))
fmt.Println(cap(clip))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">10
[0 1 2 3]
4
4
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Clone">func <a href="/src/slices/slices.go?s=9416:9448#L338">Clone</a>
				<a class="permalink" href="#Clone">&#xb6;</a>
				
				
			</h2>
			<pre>func Clone[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](s S) S</pre>
			<p>Clone returns a copy of the slice.
The elements are copied using assignment, so this is a shallow clone.
The result may have additional unused capacity.

			<div id="example_Clone" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">numbers := []int{0, 42, -10, 8}
clone := slices.Clone(numbers)
fmt.Println(clone)
clone[2] = 10
fmt.Println(numbers)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[0 42 -10 8]
[0 42 -10 8]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Collect">func <a href="/src/slices/iter.go?s=1277:1317#L47">Collect</a>
				<a class="permalink" href="#Collect">&#xb6;</a>
				
				
			</h2>
			<pre>func Collect[E <a href="/pkg/builtin/#any">any</a>](seq <a href="/pkg/iter/">iter</a>.<a href="/pkg/iter/#Seq">Seq</a>[E]) []E</pre>
			<p>Collect collects values from seq into a new slice and returns it.

			
			

		
			
			
			<h2 id="Compact">func <a href="/src/slices/slices.go?s=9852:9893#L348">Compact</a>
				<a class="permalink" href="#Compact">&#xb6;</a>
				
				
			</h2>
			<pre>func Compact[S ~[]E, E <a href="/pkg/builtin/#comparable">comparable</a>](s S) S</pre>
			<p>Compact replaces consecutive runs of equal elements with a single copy.
This is like the uniq command found on Unix.
Compact modifies the contents of the slice s and returns the modified slice,
which may have a smaller length.
Compact zeroes the elements between the new length and the original length.

			<div id="example_Compact" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">seq := []int{0, 1, 1, 2, 3, 5, 8}
seq = slices.Compact(seq)
fmt.Println(seq)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[0 1 2 3 5 8]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="CompactFunc">func <a href="/src/slices/slices.go?s=10442:10500#L372">CompactFunc</a>
				<a class="permalink" href="#CompactFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func CompactFunc[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](s S, eq func(E, E) <a href="/pkg/builtin/#bool">bool</a>) S</pre>
			<p>CompactFunc is like <a href="#Compact">Compact</a> but uses an equality function to compare elements.
For runs of elements that compare equal, CompactFunc keeps the first one.
CompactFunc zeroes the elements between the new length and the original length.

			<div id="example_CompactFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">names := []string{&#34;bob&#34;, &#34;Bob&#34;, &#34;alice&#34;, &#34;Vera&#34;, &#34;VERA&#34;}
names = slices.CompactFunc(names, strings.EqualFold)
fmt.Println(names)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[bob alice Vera]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Compare">func <a href="/src/slices/slices.go?s=1819:1868#L47">Compare</a>
				<a class="permalink" href="#Compare">&#xb6;</a>
				
				
			</h2>
			<pre>func Compare[S ~[]E, E <a href="/pkg/cmp/">cmp</a>.<a href="/pkg/cmp/#Ordered">Ordered</a>](s1, s2 S) <a href="/pkg/builtin/#int">int</a></pre>
			<p>Compare compares the elements of s1 and s2, using <a href="/cmp#Compare">cmp.Compare</a> on each pair
of elements. The elements are compared sequentially, starting at index 0,
until one element is not equal to the other.
The result of comparing the first non-matching elements is returned.
If both slices are equal until one of them ends, the shorter slice is
considered less than the longer one.
The result is 0 if s1 == s2, -1 if s1 &lt; s2, and +1 if s1 &gt; s2.

			<div id="example_Compare" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">names := []string{&#34;Alice&#34;, &#34;Bob&#34;, &#34;Vera&#34;}
fmt.Println(&#34;Equal:&#34;, slices.Compare(names, []string{&#34;Alice&#34;, &#34;Bob&#34;, &#34;Vera&#34;}))
fmt.Println(&#34;V &lt; X:&#34;, slices.Compare(names, []string{&#34;Alice&#34;, &#34;Bob&#34;, &#34;Xena&#34;}))
fmt.Println(&#34;V &gt; C:&#34;, slices.Compare(names, []string{&#34;Alice&#34;, &#34;Bob&#34;, &#34;Cat&#34;}))
fmt.Println(&#34;3 &gt; 2:&#34;, slices.Compare(names, []string{&#34;Alice&#34;, &#34;Bob&#34;}))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Equal: 0
V &lt; X: -1
V &gt; C: 1
3 &gt; 2: 1
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="CompareFunc">func <a href="/src/slices/slices.go?s=2332:2420#L68">CompareFunc</a>
				<a class="permalink" href="#CompareFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 <a href="/pkg/builtin/#any">any</a>](s1 S1, s2 S2, cmp func(E1, E2) <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>CompareFunc is like <a href="#Compare">Compare</a> but uses a custom comparison function on each
pair of elements.
The result is the first non-zero result of cmp; if cmp always
returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) &lt; len(s2),
and +1 if len(s1) &gt; len(s2).

			<div id="example_CompareFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">numbers := []int{0, 43, 8}
strings := []string{&#34;0&#34;, &#34;0&#34;, &#34;8&#34;}
result := slices.CompareFunc(numbers, strings, func(n int, s string) int {
    sn, err := strconv.Atoi(s)
    if err != nil {
        return 1
    }
    return cmp.Compare(n, sn)
})
fmt.Println(result)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">1
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Concat">func <a href="/src/slices/slices.go?s=13038:13079#L463">Concat</a>
				<a class="permalink" href="#Concat">&#xb6;</a>
				
				
			</h2>
			<pre>func Concat[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](slices ...S) S</pre>
			<p>Concat returns a new slice concatenating the passed in slices.

			<div id="example_Concat" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">s1 := []int{0, 1, 2, 3}
s2 := []int{4, 5, 6}
concat := slices.Concat(s1, s2)
fmt.Println(concat)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[0 1 2 3 4 5 6]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Contains">func <a href="/src/slices/slices.go?s=3060:3110#L107">Contains</a>
				<a class="permalink" href="#Contains">&#xb6;</a>
				
				
			</h2>
			<pre>func Contains[S ~[]E, E <a href="/pkg/builtin/#comparable">comparable</a>](s S, v E) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>Contains reports whether v is present in s.

			<div id="example_Contains" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">numbers := []int{0, 1, 2, 3}
fmt.Println(slices.Contains(numbers, 2))
fmt.Println(slices.Contains(numbers, 4))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="ContainsFunc">func <a href="/src/slices/slices.go?s=3220:3278#L113">ContainsFunc</a>
				<a class="permalink" href="#ContainsFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func ContainsFunc[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](s S, f func(E) <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>ContainsFunc reports whether at least one
element e of s satisfies f(e).

			<div id="example_ContainsFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">numbers := []int{0, 42, -10, 8}
hasNegative := slices.ContainsFunc(numbers, func(n int) bool {
    return n &lt; 0
})
fmt.Println(&#34;Has a negative:&#34;, hasNegative)
hasOdd := slices.ContainsFunc(numbers, func(n int) bool {
    return n%2 != 0
})
fmt.Println(&#34;Has an odd number:&#34;, hasOdd)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Has a negative: true
Has an odd number: false
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Delete">func <a href="/src/slices/slices.go?s=6018:6061#L210">Delete</a>
				<a class="permalink" href="#Delete">&#xb6;</a>
				
				
			</h2>
			<pre>func Delete[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](s S, i, j <a href="/pkg/builtin/#int">int</a>) S</pre>
			<p>Delete removes the elements s[i:j] from s, returning the modified slice.
Delete panics if j &gt; len(s) or s[i:j] is not a valid slice of s.
Delete is O(len(s)-i), so if many items must be deleted, it is better to
make a single call deleting them all together than to delete one at a time.
Delete zeroes the elements s[len(s)-(j-i):len(s)].

			<div id="example_Delete" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">letters := []string{&#34;a&#34;, &#34;b&#34;, &#34;c&#34;, &#34;d&#34;, &#34;e&#34;}
letters = slices.Delete(letters, 1, 4)
fmt.Println(letters)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[a e]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="DeleteFunc">func <a href="/src/slices/slices.go?s=6444:6499#L226">DeleteFunc</a>
				<a class="permalink" href="#DeleteFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func DeleteFunc[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](s S, del func(E) <a href="/pkg/builtin/#bool">bool</a>) S</pre>
			<p>DeleteFunc removes any elements from s for which del returns true,
returning the modified slice.
DeleteFunc zeroes the elements between the new length and the original length.

			<div id="example_DeleteFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">seq := []int{0, 1, 1, 2, 3, 5, 8}
seq = slices.DeleteFunc(seq, func(n int) bool {
    return n%2 != 0 <span class="comment">// delete the odd numbers</span>
})
fmt.Println(seq)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[0 2 8]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Equal">func <a href="/src/slices/slices.go?s=652:699#L10">Equal</a>
				<a class="permalink" href="#Equal">&#xb6;</a>
				
				
			</h2>
			<pre>func Equal[S ~[]E, E <a href="/pkg/builtin/#comparable">comparable</a>](s1, s2 S) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>Equal reports whether two slices are equal: the same length and all
elements equal. If the lengths are different, Equal returns false.
Otherwise, the elements are compared in increasing index order, and the
comparison stops at the first unequal pair.
Empty and nil slices are considered equal.
Floating point NaNs are not considered equal.

			<div id="example_Equal" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">numbers := []int{0, 42, 8}
fmt.Println(slices.Equal(numbers, []int{0, 42, 8}))
fmt.Println(slices.Equal(numbers, []int{10}))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="EqualFunc">func <a href="/src/slices/slices.go?s=1133:1220#L27">EqualFunc</a>
				<a class="permalink" href="#EqualFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 <a href="/pkg/builtin/#any">any</a>](s1 S1, s2 S2, eq func(E1, E2) <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>EqualFunc reports whether two slices are equal using an equality
function on each pair of elements. If the lengths are different,
EqualFunc returns false. Otherwise, the elements are compared in
increasing index order, and the comparison stops at the first index
for which eq returns false.

			<div id="example_EqualFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">numbers := []int{0, 42, 8}
strings := []string{&#34;000&#34;, &#34;42&#34;, &#34;0o10&#34;}
equal := slices.EqualFunc(numbers, strings, func(n int, s string) bool {
    sn, err := strconv.ParseInt(s, 0, 64)
    if err != nil {
        return false
    }
    return n == int(sn)
})
fmt.Println(equal)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Grow">func <a href="/src/slices/slices.go?s=11075:11113#L397">Grow</a>
				<a class="permalink" href="#Grow">&#xb6;</a>
				
				
			</h2>
			<pre>func Grow[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](s S, n <a href="/pkg/builtin/#int">int</a>) S</pre>
			<p>Grow increases the slice&apos;s capacity, if necessary, to guarantee space for
another n elements. After Grow(n), at least n elements can be appended
to the slice without another allocation. If n is negative or too large to
allocate the memory, Grow panics.

			<div id="example_Grow" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">numbers := []int{0, 42, -10, 8}
grow := slices.Grow(numbers, 2)
fmt.Println(cap(numbers))
fmt.Println(grow)
fmt.Println(len(grow))
fmt.Println(cap(grow))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">4
[0 42 -10 8]
4
8
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Index">func <a href="/src/slices/slices.go?s=2689:2735#L86">Index</a>
				<a class="permalink" href="#Index">&#xb6;</a>
				
				
			</h2>
			<pre>func Index[S ~[]E, E <a href="/pkg/builtin/#comparable">comparable</a>](s S, v E) <a href="/pkg/builtin/#int">int</a></pre>
			<p>Index returns the index of the first occurrence of v in s,
or -1 if not present.

			<div id="example_Index" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">numbers := []int{0, 42, 8}
fmt.Println(slices.Index(numbers, 8))
fmt.Println(slices.Index(numbers, 7))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">2
-1
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="IndexFunc">func <a href="/src/slices/slices.go?s=2888:2942#L97">IndexFunc</a>
				<a class="permalink" href="#IndexFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func IndexFunc[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](s S, f func(E) <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#int">int</a></pre>
			<p>IndexFunc returns the first index i satisfying f(s[i]),
or -1 if none do.

			<div id="example_IndexFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">numbers := []int{0, 42, -10, 8}
i := slices.IndexFunc(numbers, func(n int) bool {
    return n &lt; 0
})
fmt.Println(&#34;First negative at index&#34;, i)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">First negative at index 2
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Insert">func <a href="/src/slices/slices.go?s=3622:3670#L124">Insert</a>
				<a class="permalink" href="#Insert">&#xb6;</a>
				
				
			</h2>
			<pre>func Insert[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](s S, i <a href="/pkg/builtin/#int">int</a>, v ...E) S</pre>
			<p>Insert inserts the values v... into s at index i,
returning the modified slice.
The elements at s[i:] are shifted up to make room.
In the returned slice r, r[i] == v[0],
and r[i+len(v)] == value originally at r[i].
Insert panics if i is out of range.
This function is O(len(s) + len(v)).

			<div id="example_Insert" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">names := []string{&#34;Alice&#34;, &#34;Bob&#34;, &#34;Vera&#34;}
names = slices.Insert(names, 1, &#34;Bill&#34;, &#34;Billie&#34;)
names = slices.Insert(names, len(names), &#34;Zac&#34;)
fmt.Println(names)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[Alice Bill Billie Bob Vera Zac]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="IsSorted">func <a href="/src/slices/sort.go?s=1450:1496#L32">IsSorted</a>
				<a class="permalink" href="#IsSorted">&#xb6;</a>
				
				
			</h2>
			<pre>func IsSorted[S ~[]E, E <a href="/pkg/cmp/">cmp</a>.<a href="/pkg/cmp/#Ordered">Ordered</a>](x S) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>IsSorted reports whether x is sorted in ascending order.

			<div id="example_IsSorted" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(slices.IsSorted([]string{&#34;Alice&#34;, &#34;Bob&#34;, &#34;Vera&#34;}))
fmt.Println(slices.IsSorted([]int{0, 2, 1}))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="IsSortedFunc">func <a href="/src/slices/sort.go?s=1732:1796#L43">IsSortedFunc</a>
				<a class="permalink" href="#IsSortedFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func IsSortedFunc[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](x S, cmp func(a, b E) <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>IsSortedFunc reports whether x is sorted in ascending order, with cmp as the
comparison function as defined by <a href="#SortFunc">SortFunc</a>.

			<div id="example_IsSortedFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">names := []string{&#34;alice&#34;, &#34;Bob&#34;, &#34;VERA&#34;}
isSortedInsensitive := slices.IsSortedFunc(names, func(a, b string) int {
    return strings.Compare(strings.ToLower(a), strings.ToLower(b))
})
fmt.Println(isSortedInsensitive)
fmt.Println(slices.IsSorted(names))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Max">func <a href="/src/slices/sort.go?s=2828:2866#L85">Max</a>
				<a class="permalink" href="#Max">&#xb6;</a>
				
				
			</h2>
			<pre>func Max[S ~[]E, E <a href="/pkg/cmp/">cmp</a>.<a href="/pkg/cmp/#Ordered">Ordered</a>](x S) E</pre>
			<p>Max returns the maximal value in x. It panics if x is empty.
For floating-point E, Max propagates NaNs (any NaN value in x
forces the output to be NaN).

			<div id="example_Max" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">numbers := []int{0, 42, -10, 8}
fmt.Println(slices.Max(numbers))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">42
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="MaxFunc">func <a href="/src/slices/sort.go?s=3209:3265#L99">MaxFunc</a>
				<a class="permalink" href="#MaxFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func MaxFunc[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](x S, cmp func(a, b E) <a href="/pkg/builtin/#int">int</a>) E</pre>
			<p>MaxFunc returns the maximal value in x, using cmp to compare elements.
It panics if x is empty. If there is more than one maximal element
according to the cmp function, MaxFunc returns the first one.

			<div id="example_MaxFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">type Person struct {
    Name string
    Age  int
}
people := []Person{
    {&#34;Gopher&#34;, 13},
    {&#34;Alice&#34;, 55},
    {&#34;Vera&#34;, 24},
    {&#34;Bob&#34;, 55},
}
firstOldest := slices.MaxFunc(people, func(a, b Person) int {
    return cmp.Compare(a.Age, b.Age)
})
fmt.Println(firstOldest.Name)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Alice
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Min">func <a href="/src/slices/sort.go?s=2070:2108#L55">Min</a>
				<a class="permalink" href="#Min">&#xb6;</a>
				
				
			</h2>
			<pre>func Min[S ~[]E, E <a href="/pkg/cmp/">cmp</a>.<a href="/pkg/cmp/#Ordered">Ordered</a>](x S) E</pre>
			<p>Min returns the minimal value in x. It panics if x is empty.
For floating-point numbers, Min propagates NaNs (any NaN value in x
forces the output to be NaN).

			<div id="example_Min" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">numbers := []int{0, 42, -10, 8}
fmt.Println(slices.Min(numbers))
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">-10
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="MinFunc">func <a href="/src/slices/sort.go?s=2451:2507#L69">MinFunc</a>
				<a class="permalink" href="#MinFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func MinFunc[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](x S, cmp func(a, b E) <a href="/pkg/builtin/#int">int</a>) E</pre>
			<p>MinFunc returns the minimal value in x, using cmp to compare elements.
It panics if x is empty. If there is more than one minimal element
according to the cmp function, MinFunc returns the first one.

			<div id="example_MinFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">type Person struct {
    Name string
    Age  int
}
people := []Person{
    {&#34;Gopher&#34;, 13},
    {&#34;Bob&#34;, 5},
    {&#34;Vera&#34;, 24},
    {&#34;Bill&#34;, 5},
}
firstYoungest := slices.MinFunc(people, func(a, b Person) int {
    return cmp.Compare(a.Age, b.Age)
})
fmt.Println(firstYoungest.Name)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">Bob
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Repeat">func <a href="/src/slices/slices.go?s=13571:13615#L483">Repeat</a>
				<a class="permalink" href="#Repeat">&#xb6;</a>
				
				
			</h2>
			<pre>func Repeat[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](x S, count <a href="/pkg/builtin/#int">int</a>) S</pre>
			<p>Repeat returns a new slice that repeats the provided slice the given number of times.
The result has length and capacity (len(x) * count).
The result is never nil.
Repeat panics if count is negative or if the result of (len(x) * count)
overflows.

			<div id="example_Repeat" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">numbers := []int{0, 1, 2, 3}
repeat := slices.Repeat(numbers, 2)
fmt.Println(repeat)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[0 1 2 3 0 1 2 3]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Replace">func <a href="/src/slices/slices.go?s=7040:7092#L246">Replace</a>
				<a class="permalink" href="#Replace">&#xb6;</a>
				
				
			</h2>
			<pre>func Replace[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](s S, i, j <a href="/pkg/builtin/#int">int</a>, v ...E) S</pre>
			<p>Replace replaces the elements s[i:j] by the given v, and returns the
modified slice.
Replace panics if j &gt; len(s) or s[i:j] is not a valid slice of s.
When len(v) &lt; (j-i), Replace zeroes the elements between the new length and the original length.

			<div id="example_Replace" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">names := []string{&#34;Alice&#34;, &#34;Bob&#34;, &#34;Vera&#34;, &#34;Zac&#34;}
names = slices.Replace(names, 1, 3, &#34;Bill&#34;, &#34;Billie&#34;, &#34;Cat&#34;)
fmt.Println(names)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[Alice Bill Billie Cat Zac]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Reverse">func <a href="/src/slices/slices.go?s=12854:12886#L456">Reverse</a>
				<a class="permalink" href="#Reverse">&#xb6;</a>
				
				
			</h2>
			<pre>func Reverse[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](s S)</pre>
			<p>Reverse reverses the elements of the slice in place.

			<div id="example_Reverse" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">names := []string{&#34;alice&#34;, &#34;Bob&#34;, &#34;VERA&#34;}
slices.Reverse(names)
fmt.Println(names)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[VERA Bob alice]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Sort">func <a href="/src/slices/sort.go?s=417:454#L6">Sort</a>
				<a class="permalink" href="#Sort">&#xb6;</a>
				
				
			</h2>
			<pre>func Sort[S ~[]E, E <a href="/pkg/cmp/">cmp</a>.<a href="/pkg/cmp/#Ordered">Ordered</a>](x S)</pre>
			<p>Sort sorts a slice of any ordered type in ascending order.
When sorting floating-point numbers, NaNs are ordered before other values.

			<div id="example_Sort" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">smallInts := []int8{0, 42, -10, 8}
slices.Sort(smallInts)
fmt.Println(smallInts)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[-10 0 8 42]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="SortFunc">func <a href="/src/slices/sort.go?s=1017:1072#L20">SortFunc</a>
				<a class="permalink" href="#SortFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func SortFunc[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](x S, cmp func(a, b E) <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>SortFunc sorts the slice x in ascending order as determined by the cmp
function. This sort is not guaranteed to be stable.
cmp(a, b) should return a negative number when a &lt; b, a positive number when
a &gt; b and zero when a == b or a and b are incomparable in the sense of
a strict weak ordering.
<p>SortFunc requires that cmp is a strict weak ordering.
See <a href="https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings">https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings</a>.
The function should return 0 for incomparable items.

			<div id="example_SortFunc_caseInsensitive" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (CaseInsensitive)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (CaseInsensitive)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">names := []string{&#34;Bob&#34;, &#34;alice&#34;, &#34;VERA&#34;}
slices.SortFunc(names, func(a, b string) int {
    return strings.Compare(strings.ToLower(a), strings.ToLower(b))
})
fmt.Println(names)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[alice Bob VERA]
</pre>
			
		
	</div>
</div>
<div id="example_SortFunc_multiField" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (MultiField)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (MultiField)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">type Person struct {
    Name string
    Age  int
}
people := []Person{
    {&#34;Gopher&#34;, 13},
    {&#34;Alice&#34;, 55},
    {&#34;Bob&#34;, 24},
    {&#34;Alice&#34;, 20},
}
slices.SortFunc(people, func(a, b Person) int {
    if n := strings.Compare(a.Name, b.Name); n != 0 {
        return n
    }
    <span class="comment">// If names are equal, order by age</span>
    return cmp.Compare(a.Age, b.Age)
})
fmt.Println(people)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[{Alice 20} {Alice 55} {Bob 24} {Gopher 13}]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="SortStableFunc">func <a href="/src/slices/sort.go?s=1292:1353#L27">SortStableFunc</a>
				<a class="permalink" href="#SortStableFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func SortStableFunc[S ~[]E, E <a href="/pkg/builtin/#any">any</a>](x S, cmp func(a, b E) <a href="/pkg/builtin/#int">int</a>)</pre>
			<p>SortStableFunc sorts the slice x while keeping the original order of equal
elements, using cmp to compare elements in the same way as <a href="#SortFunc">SortFunc</a>.

			<div id="example_SortStableFunc" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">type Person struct {
    Name string
    Age  int
}
people := []Person{
    {&#34;Gopher&#34;, 13},
    {&#34;Alice&#34;, 20},
    {&#34;Bob&#34;, 24},
    {&#34;Alice&#34;, 55},
}
<span class="comment">// Stable sort by name, keeping age ordering of Alices intact</span>
slices.SortStableFunc(people, func(a, b Person) int {
    return strings.Compare(a.Name, b.Name)
})
fmt.Println(people)
<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">[{Alice 20} {Alice 55} {Bob 24} {Gopher 13}]
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Sorted">func <a href="/src/slices/iter.go?s=1445:1492#L53">Sorted</a>
				<a class="permalink" href="#Sorted">&#xb6;</a>
				
				
			</h2>
			<pre>func Sorted[E <a href="/pkg/cmp/">cmp</a>.<a href="/pkg/cmp/#Ordered">Ordered</a>](seq <a href="/pkg/iter/">iter</a>.<a href="/pkg/iter/#Seq">Seq</a>[E]) []E</pre>
			<p>Sorted collects values from seq into a new slice, sorts the slice,
and returns it.

			
			

		
			
			
			<h2 id="SortedFunc">func <a href="/src/slices/iter.go?s=1659:1722#L61">SortedFunc</a>
				<a class="permalink" href="#SortedFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func SortedFunc[E <a href="/pkg/builtin/#any">any</a>](seq <a href="/pkg/iter/">iter</a>.<a href="/pkg/iter/#Seq">Seq</a>[E], cmp func(E, E) <a href="/pkg/builtin/#int">int</a>) []E</pre>
			<p>SortedFunc collects values from seq into a new slice, sorts the slice
using the comparison function, and returns it.

			
			

		
			
			
			<h2 id="SortedStableFunc">func <a href="/src/slices/iter.go?s=2000:2069#L71">SortedStableFunc</a>
				<a class="permalink" href="#SortedStableFunc">&#xb6;</a>
				
				
			</h2>
			<pre>func SortedStableFunc[E <a href="/pkg/builtin/#any">any</a>](seq <a href="/pkg/iter/">iter</a>.<a href="/pkg/iter/#Seq">Seq</a>[E], cmp func(E, E) <a href="/pkg/builtin/#int">int</a>) []E</pre>
			<p>SortedStableFunc collects values from seq into a new slice.
It then sorts the slice while keeping the original order of equal elements,
using the comparison function to compare elements.
It returns the new slice.

			
			

		
			
			
			<h2 id="Values">func <a href="/src/slices/iter.go?s=837:888#L27">Values</a>
				<a class="permalink" href="#Values">&#xb6;</a>
				
				
			</h2>
			<pre>func Values[Slice ~[]E, E <a href="/pkg/builtin/#any">any</a>](s Slice) <a href="/pkg/iter/">iter</a>.<a href="/pkg/iter/#Seq">Seq</a>[E]</pre>
			<p>Values returns an iterator that yields the slice elements in order.

			
			

		
		
	

	







<div id="footer">
Build version go1.23.0.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
