<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>atomic - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.23.0";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package atomic
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "sync/atomic"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package atomic provides low-level atomic memory primitives
useful for implementing synchronization algorithms.
<p>These functions require great care to be used correctly.
Except for special, low-level applications, synchronization is better
done with channels or the facilities of the <a href="/sync">sync</a> package.
Share memory by communicating;
don&apos;t communicate by sharing memory.
<p>The swap operation, implemented by the SwapT functions, is the atomic
equivalent of:
<pre>old = *addr
*addr = new
return old
</pre>
<p>The compare-and-swap operation, implemented by the CompareAndSwapT
functions, is the atomic equivalent of:
<pre>if *addr == old {
	*addr = new
	return true
}
return false
</pre>
<p>The add operation, implemented by the AddT functions, is the atomic
equivalent of:
<pre>*addr += delta
return *addr
</pre>
<p>The load and store operations, implemented by the LoadT and StoreT
functions, are the atomic equivalents of &quot;return *addr&quot; and
&quot;*addr = val&quot;.
<p>In the terminology of <a href="https://go.dev/ref/mem">the Go memory model</a>, if the effect of
an atomic operation A is observed by atomic operation B,
then A “synchronizes before” B.
Additionally, all the atomic operations executed in a program
behave as though executed in some sequentially consistent order.
This definition provides the same semantics as
C++&apos;s sequentially consistent atomics and Java&apos;s volatile variables.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
			
				
				<dd><a href="#AddInt32">func AddInt32(addr *int32, delta int32) (new int32)</a></dd>
			
				
				<dd><a href="#AddInt64">func AddInt64(addr *int64, delta int64) (new int64)</a></dd>
			
				
				<dd><a href="#AddUint32">func AddUint32(addr *uint32, delta uint32) (new uint32)</a></dd>
			
				
				<dd><a href="#AddUint64">func AddUint64(addr *uint64, delta uint64) (new uint64)</a></dd>
			
				
				<dd><a href="#AddUintptr">func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)</a></dd>
			
				
				<dd><a href="#AndInt32">func AndInt32(addr *int32, mask int32) (old int32)</a></dd>
			
				
				<dd><a href="#AndInt64">func AndInt64(addr *int64, mask int64) (old int64)</a></dd>
			
				
				<dd><a href="#AndUint32">func AndUint32(addr *uint32, mask uint32) (old uint32)</a></dd>
			
				
				<dd><a href="#AndUint64">func AndUint64(addr *uint64, mask uint64) (old uint64)</a></dd>
			
				
				<dd><a href="#AndUintptr">func AndUintptr(addr *uintptr, mask uintptr) (old uintptr)</a></dd>
			
				
				<dd><a href="#CompareAndSwapInt32">func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)</a></dd>
			
				
				<dd><a href="#CompareAndSwapInt64">func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)</a></dd>
			
				
				<dd><a href="#CompareAndSwapPointer">func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)</a></dd>
			
				
				<dd><a href="#CompareAndSwapUint32">func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)</a></dd>
			
				
				<dd><a href="#CompareAndSwapUint64">func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)</a></dd>
			
				
				<dd><a href="#CompareAndSwapUintptr">func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)</a></dd>
			
				
				<dd><a href="#LoadInt32">func LoadInt32(addr *int32) (val int32)</a></dd>
			
				
				<dd><a href="#LoadInt64">func LoadInt64(addr *int64) (val int64)</a></dd>
			
				
				<dd><a href="#LoadPointer">func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)</a></dd>
			
				
				<dd><a href="#LoadUint32">func LoadUint32(addr *uint32) (val uint32)</a></dd>
			
				
				<dd><a href="#LoadUint64">func LoadUint64(addr *uint64) (val uint64)</a></dd>
			
				
				<dd><a href="#LoadUintptr">func LoadUintptr(addr *uintptr) (val uintptr)</a></dd>
			
				
				<dd><a href="#OrInt32">func OrInt32(addr *int32, mask int32) (old int32)</a></dd>
			
				
				<dd><a href="#OrInt64">func OrInt64(addr *int64, mask int64) (old int64)</a></dd>
			
				
				<dd><a href="#OrUint32">func OrUint32(addr *uint32, mask uint32) (old uint32)</a></dd>
			
				
				<dd><a href="#OrUint64">func OrUint64(addr *uint64, mask uint64) (old uint64)</a></dd>
			
				
				<dd><a href="#OrUintptr">func OrUintptr(addr *uintptr, mask uintptr) (old uintptr)</a></dd>
			
				
				<dd><a href="#StoreInt32">func StoreInt32(addr *int32, val int32)</a></dd>
			
				
				<dd><a href="#StoreInt64">func StoreInt64(addr *int64, val int64)</a></dd>
			
				
				<dd><a href="#StorePointer">func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)</a></dd>
			
				
				<dd><a href="#StoreUint32">func StoreUint32(addr *uint32, val uint32)</a></dd>
			
				
				<dd><a href="#StoreUint64">func StoreUint64(addr *uint64, val uint64)</a></dd>
			
				
				<dd><a href="#StoreUintptr">func StoreUintptr(addr *uintptr, val uintptr)</a></dd>
			
				
				<dd><a href="#SwapInt32">func SwapInt32(addr *int32, new int32) (old int32)</a></dd>
			
				
				<dd><a href="#SwapInt64">func SwapInt64(addr *int64, new int64) (old int64)</a></dd>
			
				
				<dd><a href="#SwapPointer">func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)</a></dd>
			
				
				<dd><a href="#SwapUint32">func SwapUint32(addr *uint32, new uint32) (old uint32)</a></dd>
			
				
				<dd><a href="#SwapUint64">func SwapUint64(addr *uint64, new uint64) (old uint64)</a></dd>
			
				
				<dd><a href="#SwapUintptr">func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)</a></dd>
			
			
				
				<dd><a href="#Bool">type Bool</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Bool.CompareAndSwap">func (x *Bool) CompareAndSwap(old, new bool) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Bool.Load">func (x *Bool) Load() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Bool.Store">func (x *Bool) Store(val bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Bool.Swap">func (x *Bool) Swap(new bool) (old bool)</a></dd>
				
			
				
				<dd><a href="#Int32">type Int32</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Int32.Add">func (x *Int32) Add(delta int32) (new int32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int32.And">func (x *Int32) And(mask int32) (old int32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int32.CompareAndSwap">func (x *Int32) CompareAndSwap(old, new int32) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int32.Load">func (x *Int32) Load() int32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int32.Or">func (x *Int32) Or(mask int32) (old int32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int32.Store">func (x *Int32) Store(val int32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int32.Swap">func (x *Int32) Swap(new int32) (old int32)</a></dd>
				
			
				
				<dd><a href="#Int64">type Int64</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Int64.Add">func (x *Int64) Add(delta int64) (new int64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int64.And">func (x *Int64) And(mask int64) (old int64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int64.CompareAndSwap">func (x *Int64) CompareAndSwap(old, new int64) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int64.Load">func (x *Int64) Load() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int64.Or">func (x *Int64) Or(mask int64) (old int64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int64.Store">func (x *Int64) Store(val int64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Int64.Swap">func (x *Int64) Swap(new int64) (old int64)</a></dd>
				
			
				
				<dd><a href="#Pointer">type Pointer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Pointer.CompareAndSwap">func (x *Pointer[T]) CompareAndSwap(old, new *T) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Pointer.Load">func (x *Pointer[T]) Load() *T</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Pointer.Store">func (x *Pointer[T]) Store(val *T)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Pointer.Swap">func (x *Pointer[T]) Swap(new *T) (old *T)</a></dd>
				
			
				
				<dd><a href="#Uint32">type Uint32</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Uint32.Add">func (x *Uint32) Add(delta uint32) (new uint32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uint32.And">func (x *Uint32) And(mask uint32) (old uint32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uint32.CompareAndSwap">func (x *Uint32) CompareAndSwap(old, new uint32) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uint32.Load">func (x *Uint32) Load() uint32</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uint32.Or">func (x *Uint32) Or(mask uint32) (old uint32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uint32.Store">func (x *Uint32) Store(val uint32)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uint32.Swap">func (x *Uint32) Swap(new uint32) (old uint32)</a></dd>
				
			
				
				<dd><a href="#Uint64">type Uint64</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Uint64.Add">func (x *Uint64) Add(delta uint64) (new uint64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uint64.And">func (x *Uint64) And(mask uint64) (old uint64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uint64.CompareAndSwap">func (x *Uint64) CompareAndSwap(old, new uint64) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uint64.Load">func (x *Uint64) Load() uint64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uint64.Or">func (x *Uint64) Or(mask uint64) (old uint64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uint64.Store">func (x *Uint64) Store(val uint64)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uint64.Swap">func (x *Uint64) Swap(new uint64) (old uint64)</a></dd>
				
			
				
				<dd><a href="#Uintptr">type Uintptr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Uintptr.Add">func (x *Uintptr) Add(delta uintptr) (new uintptr)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uintptr.And">func (x *Uintptr) And(mask uintptr) (old uintptr)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uintptr.CompareAndSwap">func (x *Uintptr) CompareAndSwap(old, new uintptr) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uintptr.Load">func (x *Uintptr) Load() uintptr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uintptr.Or">func (x *Uintptr) Or(mask uintptr) (old uintptr)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uintptr.Store">func (x *Uintptr) Store(val uintptr)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Uintptr.Swap">func (x *Uintptr) Swap(new uintptr) (old uintptr)</a></dd>
				
			
				
				<dd><a href="#Value">type Value</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.CompareAndSwap">func (v *Value) CompareAndSwap(old, new any) (swapped bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Load">func (v *Value) Load() (val any)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Store">func (v *Value) Store(val any)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Value.Swap">func (v *Value) Swap(new any) (old any)</a></dd>
				
			
			
				
				<dd><a href="#pkg-note-BUG">Bugs</a></dd>
				
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="#example_Value_config">Value (Config)</a></dd>
			
			<dd><a class="exampleLink" href="#example_Value_readMostly">Value (ReadMostly)</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/sync/atomic/doc.go">doc.go</a>
			
				<a href="/src/sync/atomic/type.go">type.go</a>
			
				<a href="/src/sync/atomic/value.go">value.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
		
			
			
			<h2 id="AddInt32">func <a href="/src/sync/atomic/doc.go?s=5627:5678#L110">AddInt32</a>
				<a class="permalink" href="#AddInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func AddInt32(addr *<a href="/pkg/builtin/#int32">int32</a>, delta <a href="/pkg/builtin/#int32">int32</a>) (new <a href="/pkg/builtin/#int32">int32</a>)</pre>
			<p>AddInt32 atomically adds delta to *addr and returns the new value.
Consider using the more ergonomic and less error-prone <a href="#Int32.Add">Int32.Add</a> instead.

			
			

		
			
			
			<h2 id="AddInt64">func <a href="/src/sync/atomic/doc.go?s=6262:6313#L121">AddInt64</a>
				<a class="permalink" href="#AddInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func AddInt64(addr *<a href="/pkg/builtin/#int64">int64</a>, delta <a href="/pkg/builtin/#int64">int64</a>) (new <a href="/pkg/builtin/#int64">int64</a>)</pre>
			<p>AddInt64 atomically adds delta to *addr and returns the new value.
Consider using the more ergonomic and less error-prone <a href="#Int64.Add">Int64.Add</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="AddUint32">func <a href="/src/sync/atomic/doc.go?s=5985:6040#L116">AddUint32</a>
				<a class="permalink" href="#AddUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func AddUint32(addr *<a href="/pkg/builtin/#uint32">uint32</a>, delta <a href="/pkg/builtin/#uint32">uint32</a>) (new <a href="/pkg/builtin/#uint32">uint32</a>)</pre>
			<p>AddUint32 atomically adds delta to *addr and returns the new value.
To subtract a signed positive constant value c from x, do AddUint32(&amp;x, ^uint32(c-1)).
In particular, to decrement x, do AddUint32(&amp;x, ^uint32(0)).
Consider using the more ergonomic and less error-prone <a href="#Uint32.Add">Uint32.Add</a> instead.

			
			

		
			
			
			<h2 id="AddUint64">func <a href="/src/sync/atomic/doc.go?s=6691:6746#L128">AddUint64</a>
				<a class="permalink" href="#AddUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func AddUint64(addr *<a href="/pkg/builtin/#uint64">uint64</a>, delta <a href="/pkg/builtin/#uint64">uint64</a>) (new <a href="/pkg/builtin/#uint64">uint64</a>)</pre>
			<p>AddUint64 atomically adds delta to *addr and returns the new value.
To subtract a signed positive constant value c from x, do AddUint64(&amp;x, ^uint64(c-1)).
In particular, to decrement x, do AddUint64(&amp;x, ^uint64(0)).
Consider using the more ergonomic and less error-prone <a href="#Uint64.Add">Uint64.Add</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="AddUintptr">func <a href="/src/sync/atomic/doc.go?s=6901:6960#L132">AddUintptr</a>
				<a class="permalink" href="#AddUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func AddUintptr(addr *<a href="/pkg/builtin/#uintptr">uintptr</a>, delta <a href="/pkg/builtin/#uintptr">uintptr</a>) (new <a href="/pkg/builtin/#uintptr">uintptr</a>)</pre>
			<p>AddUintptr atomically adds delta to *addr and returns the new value.
Consider using the more ergonomic and less error-prone <a href="#Uintptr.Add">Uintptr.Add</a> instead.

			
			

		
			
			
			<h2 id="AndInt32">func <a href="/src/sync/atomic/doc.go?s=7171:7221#L137">AndInt32</a>
				<a class="permalink" href="#AndInt32">&#xb6;</a>
				
				<span title="Added in Go 1.23">1.23</span>
			</h2>
			<pre>func AndInt32(addr *<a href="/pkg/builtin/#int32">int32</a>, mask <a href="/pkg/builtin/#int32">int32</a>) (old <a href="/pkg/builtin/#int32">int32</a>)</pre>
			<p>AndInt32 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone <a href="#Int32.And">Int32.And</a> instead.

			
			

		
			
			
			<h2 id="AndInt64">func <a href="/src/sync/atomic/doc.go?s=7699:7749#L147">AndInt64</a>
				<a class="permalink" href="#AndInt64">&#xb6;</a>
				
				<span title="Added in Go 1.23">1.23</span>
			</h2>
			<pre>func AndInt64(addr *<a href="/pkg/builtin/#int64">int64</a>, mask <a href="/pkg/builtin/#int64">int64</a>) (old <a href="/pkg/builtin/#int64">int64</a>)</pre>
			<p>AndInt64 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone <a href="#Int64.And">Int64.And</a> instead.

			
			

		
			
			
			<h2 id="AndUint32">func <a href="/src/sync/atomic/doc.go?s=7434:7488#L142">AndUint32</a>
				<a class="permalink" href="#AndUint32">&#xb6;</a>
				
				<span title="Added in Go 1.23">1.23</span>
			</h2>
			<pre>func AndUint32(addr *<a href="/pkg/builtin/#uint32">uint32</a>, mask <a href="/pkg/builtin/#uint32">uint32</a>) (old <a href="/pkg/builtin/#uint32">uint32</a>)</pre>
			<p>AndUint32 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone <a href="#Uint32.And">Uint32.And</a> instead.

			
			

		
			
			
			<h2 id="AndUint64">func <a href="/src/sync/atomic/doc.go?s=7956:8010#L152">AndUint64</a>
				<a class="permalink" href="#AndUint64">&#xb6;</a>
				
				<span title="Added in Go 1.23">1.23</span>
			</h2>
			<pre>func AndUint64(addr *<a href="/pkg/builtin/#uint64">uint64</a>, mask <a href="/pkg/builtin/#uint64">uint64</a>) (old <a href="/pkg/builtin/#uint64">uint64</a>)</pre>
			<p>AndUint64 atomically performs a bitwise AND operation on *addr using the bitmask provided as mask
and returns the old.
Consider using the more ergonomic and less error-prone <a href="#Uint64.And">Uint64.And</a> instead.

			
			

		
			
			
			<h2 id="AndUintptr">func <a href="/src/sync/atomic/doc.go?s=8225:8283#L157">AndUintptr</a>
				<a class="permalink" href="#AndUintptr">&#xb6;</a>
				
				<span title="Added in Go 1.23">1.23</span>
			</h2>
			<pre>func AndUintptr(addr *<a href="/pkg/builtin/#uintptr">uintptr</a>, mask <a href="/pkg/builtin/#uintptr">uintptr</a>) (old <a href="/pkg/builtin/#uintptr">uintptr</a>)</pre>
			<p>AndUintptr atomically performs a bitwise AND operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone <a href="#Uintptr.And">Uintptr.And</a> instead.

			
			

		
			
			
			<h2 id="CompareAndSwapInt32">func <a href="/src/sync/atomic/doc.go?s=3998:4066#L84">CompareAndSwapInt32</a>
				<a class="permalink" href="#CompareAndSwapInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapInt32(addr *<a href="/pkg/builtin/#int32">int32</a>, old, new <a href="/pkg/builtin/#int32">int32</a>) (swapped <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.
Consider using the more ergonomic and less error-prone <a href="#Int32.CompareAndSwap">Int32.CompareAndSwap</a> instead.

			
			

		
			
			
			<h2 id="CompareAndSwapInt64">func <a href="/src/sync/atomic/doc.go?s=4312:4380#L89">CompareAndSwapInt64</a>
				<a class="permalink" href="#CompareAndSwapInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapInt64(addr *<a href="/pkg/builtin/#int64">int64</a>, old, new <a href="/pkg/builtin/#int64">int64</a>) (swapped <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.
Consider using the more ergonomic and less error-prone <a href="#Int64.CompareAndSwap">Int64.CompareAndSwap</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="CompareAndSwapPointer">func <a href="/src/sync/atomic/doc.go?s=5388:5476#L106">CompareAndSwapPointer</a>
				<a class="permalink" href="#CompareAndSwapPointer">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapPointer(addr *<a href="/pkg/unsafe/">unsafe</a>.<a href="/pkg/unsafe/#Pointer">Pointer</a>, old, new <a href="/pkg/unsafe/">unsafe</a>.<a href="/pkg/unsafe/#Pointer">Pointer</a>) (swapped <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.
Consider using the more ergonomic and less error-prone <a href="#Pointer.CompareAndSwap">Pointer.CompareAndSwap</a> instead.

			
			

		
			
			
			<h2 id="CompareAndSwapUint32">func <a href="/src/sync/atomic/doc.go?s=4557:4628#L93">CompareAndSwapUint32</a>
				<a class="permalink" href="#CompareAndSwapUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapUint32(addr *<a href="/pkg/builtin/#uint32">uint32</a>, old, new <a href="/pkg/builtin/#uint32">uint32</a>) (swapped <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.
Consider using the more ergonomic and less error-prone <a href="#Uint32.CompareAndSwap">Uint32.CompareAndSwap</a> instead.

			
			

		
			
			
			<h2 id="CompareAndSwapUint64">func <a href="/src/sync/atomic/doc.go?s=4876:4947#L98">CompareAndSwapUint64</a>
				<a class="permalink" href="#CompareAndSwapUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapUint64(addr *<a href="/pkg/builtin/#uint64">uint64</a>, old, new <a href="/pkg/builtin/#uint64">uint64</a>) (swapped <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.
Consider using the more ergonomic and less error-prone <a href="#Uint64.CompareAndSwap">Uint64.CompareAndSwap</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="CompareAndSwapUintptr">func <a href="/src/sync/atomic/doc.go?s=5127:5201#L102">CompareAndSwapUintptr</a>
				<a class="permalink" href="#CompareAndSwapUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func CompareAndSwapUintptr(addr *<a href="/pkg/builtin/#uintptr">uintptr</a>, old, new <a href="/pkg/builtin/#uintptr">uintptr</a>) (swapped <a href="/pkg/builtin/#bool">bool</a>)</pre>
			<p>CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.
Consider using the more ergonomic and less error-prone <a href="#Uintptr.CompareAndSwap">Uintptr.CompareAndSwap</a> instead.

			
			

		
			
			
			<h2 id="LoadInt32">func <a href="/src/sync/atomic/doc.go?s=9711:9750#L186">LoadInt32</a>
				<a class="permalink" href="#LoadInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadInt32(addr *<a href="/pkg/builtin/#int32">int32</a>) (val <a href="/pkg/builtin/#int32">int32</a>)</pre>
			<p>LoadInt32 atomically loads *addr.
Consider using the more ergonomic and less error-prone <a href="#Int32.Load">Int32.Load</a> instead.

			
			

		
			
			
			<h2 id="LoadInt64">func <a href="/src/sync/atomic/doc.go?s=9940:9979#L191">LoadInt64</a>
				<a class="permalink" href="#LoadInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadInt64(addr *<a href="/pkg/builtin/#int64">int64</a>) (val <a href="/pkg/builtin/#int64">int64</a>)</pre>
			<p>LoadInt64 atomically loads *addr.
Consider using the more ergonomic and less error-prone <a href="#Int64.Load">Int64.Load</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="LoadPointer">func <a href="/src/sync/atomic/doc.go?s=10667:10726#L208">LoadPointer</a>
				<a class="permalink" href="#LoadPointer">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadPointer(addr *<a href="/pkg/unsafe/">unsafe</a>.<a href="/pkg/unsafe/#Pointer">Pointer</a>) (val <a href="/pkg/unsafe/">unsafe</a>.<a href="/pkg/unsafe/#Pointer">Pointer</a>)</pre>
			<p>LoadPointer atomically loads *addr.
Consider using the more ergonomic and less error-prone <a href="#Pointer.Load">Pointer.Load</a> instead.

			
			

		
			
			
			<h2 id="LoadUint32">func <a href="/src/sync/atomic/doc.go?s=10100:10142#L195">LoadUint32</a>
				<a class="permalink" href="#LoadUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadUint32(addr *<a href="/pkg/builtin/#uint32">uint32</a>) (val <a href="/pkg/builtin/#uint32">uint32</a>)</pre>
			<p>LoadUint32 atomically loads *addr.
Consider using the more ergonomic and less error-prone <a href="#Uint32.Load">Uint32.Load</a> instead.

			
			

		
			
			
			<h2 id="LoadUint64">func <a href="/src/sync/atomic/doc.go?s=10334:10376#L200">LoadUint64</a>
				<a class="permalink" href="#LoadUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadUint64(addr *<a href="/pkg/builtin/#uint64">uint64</a>) (val <a href="/pkg/builtin/#uint64">uint64</a>)</pre>
			<p>LoadUint64 atomically loads *addr.
Consider using the more ergonomic and less error-prone <a href="#Uint64.Load">Uint64.Load</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="LoadUintptr">func <a href="/src/sync/atomic/doc.go?s=10499:10544#L204">LoadUintptr</a>
				<a class="permalink" href="#LoadUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func LoadUintptr(addr *<a href="/pkg/builtin/#uintptr">uintptr</a>) (val <a href="/pkg/builtin/#uintptr">uintptr</a>)</pre>
			<p>LoadUintptr atomically loads *addr.
Consider using the more ergonomic and less error-prone <a href="#Uintptr.Load">Uintptr.Load</a> instead.

			
			

		
			
			
			<h2 id="OrInt32">func <a href="/src/sync/atomic/doc.go?s=8491:8540#L162">OrInt32</a>
				<a class="permalink" href="#OrInt32">&#xb6;</a>
				
				<span title="Added in Go 1.23">1.23</span>
			</h2>
			<pre>func OrInt32(addr *<a href="/pkg/builtin/#int32">int32</a>, mask <a href="/pkg/builtin/#int32">int32</a>) (old <a href="/pkg/builtin/#int32">int32</a>)</pre>
			<p>OrInt32 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone <a href="#Int32.Or">Int32.Or</a> instead.

			
			

		
			
			
			<h2 id="OrInt64">func <a href="/src/sync/atomic/doc.go?s=9011:9060#L172">OrInt64</a>
				<a class="permalink" href="#OrInt64">&#xb6;</a>
				
				<span title="Added in Go 1.23">1.23</span>
			</h2>
			<pre>func OrInt64(addr *<a href="/pkg/builtin/#int64">int64</a>, mask <a href="/pkg/builtin/#int64">int64</a>) (old <a href="/pkg/builtin/#int64">int64</a>)</pre>
			<p>OrInt64 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone <a href="#Int64.Or">Int64.Or</a> instead.

			
			

		
			
			
			<h2 id="OrUint32">func <a href="/src/sync/atomic/doc.go?s=8750:8803#L167">OrUint32</a>
				<a class="permalink" href="#OrUint32">&#xb6;</a>
				
				<span title="Added in Go 1.23">1.23</span>
			</h2>
			<pre>func OrUint32(addr *<a href="/pkg/builtin/#uint32">uint32</a>, mask <a href="/pkg/builtin/#uint32">uint32</a>) (old <a href="/pkg/builtin/#uint32">uint32</a>)</pre>
			<p>OrUint32 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone <a href="#Uint32.Or">Uint32.Or</a> instead.

			
			

		
			
			
			<h2 id="OrUint64">func <a href="/src/sync/atomic/doc.go?s=9270:9323#L177">OrUint64</a>
				<a class="permalink" href="#OrUint64">&#xb6;</a>
				
				<span title="Added in Go 1.23">1.23</span>
			</h2>
			<pre>func OrUint64(addr *<a href="/pkg/builtin/#uint64">uint64</a>, mask <a href="/pkg/builtin/#uint64">uint64</a>) (old <a href="/pkg/builtin/#uint64">uint64</a>)</pre>
			<p>OrUint64 atomically performs a bitwise OR operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone <a href="#Uint64.Or">Uint64.Or</a> instead.

			
			

		
			
			
			<h2 id="OrUintptr">func <a href="/src/sync/atomic/doc.go?s=9535:9592#L182">OrUintptr</a>
				<a class="permalink" href="#OrUintptr">&#xb6;</a>
				
				<span title="Added in Go 1.23">1.23</span>
			</h2>
			<pre>func OrUintptr(addr *<a href="/pkg/builtin/#uintptr">uintptr</a>, mask <a href="/pkg/builtin/#uintptr">uintptr</a>) (old <a href="/pkg/builtin/#uintptr">uintptr</a>)</pre>
			<p>OrUintptr atomically performs a bitwise OR operation on *addr using the bitmask provided as mask
and returns the old value.
Consider using the more ergonomic and less error-prone <a href="#Uintptr.Or">Uintptr.Or</a> instead.

			
			

		
			
			
			<h2 id="StoreInt32">func <a href="/src/sync/atomic/doc.go?s=10857:10896#L212">StoreInt32</a>
				<a class="permalink" href="#StoreInt32">&#xb6;</a>
				
				
			</h2>
			<pre>func StoreInt32(addr *<a href="/pkg/builtin/#int32">int32</a>, val <a href="/pkg/builtin/#int32">int32</a>)</pre>
			<p>StoreInt32 atomically stores val into *addr.
Consider using the more ergonomic and less error-prone <a href="#Int32.Store">Int32.Store</a> instead.

			
			

		
			
			
			<h2 id="StoreInt64">func <a href="/src/sync/atomic/doc.go?s=11098:11137#L217">StoreInt64</a>
				<a class="permalink" href="#StoreInt64">&#xb6;</a>
				
				
			</h2>
			<pre>func StoreInt64(addr *<a href="/pkg/builtin/#int64">int64</a>, val <a href="/pkg/builtin/#int64">int64</a>)</pre>
			<p>StoreInt64 atomically stores val into *addr.
Consider using the more ergonomic and less error-prone <a href="#Int64.Store">Int64.Store</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="StorePointer">func <a href="/src/sync/atomic/doc.go?s=11873:11932#L234">StorePointer</a>
				<a class="permalink" href="#StorePointer">&#xb6;</a>
				
				
			</h2>
			<pre>func StorePointer(addr *<a href="/pkg/unsafe/">unsafe</a>.<a href="/pkg/unsafe/#Pointer">Pointer</a>, val <a href="/pkg/unsafe/">unsafe</a>.<a href="/pkg/unsafe/#Pointer">Pointer</a>)</pre>
			<p>StorePointer atomically stores val into *addr.
Consider using the more ergonomic and less error-prone <a href="#Pointer.Store">Pointer.Store</a> instead.

			
			

		
			
			
			<h2 id="StoreUint32">func <a href="/src/sync/atomic/doc.go?s=11270:11312#L221">StoreUint32</a>
				<a class="permalink" href="#StoreUint32">&#xb6;</a>
				
				
			</h2>
			<pre>func StoreUint32(addr *<a href="/pkg/builtin/#uint32">uint32</a>, val <a href="/pkg/builtin/#uint32">uint32</a>)</pre>
			<p>StoreUint32 atomically stores val into *addr.
Consider using the more ergonomic and less error-prone <a href="#Uint32.Store">Uint32.Store</a> instead.

			
			

		
			
			
			<h2 id="StoreUint64">func <a href="/src/sync/atomic/doc.go?s=11516:11558#L226">StoreUint64</a>
				<a class="permalink" href="#StoreUint64">&#xb6;</a>
				
				
			</h2>
			<pre>func StoreUint64(addr *<a href="/pkg/builtin/#uint64">uint64</a>, val <a href="/pkg/builtin/#uint64">uint64</a>)</pre>
			<p>StoreUint64 atomically stores val into *addr.
Consider using the more ergonomic and less error-prone <a href="#Uint64.Store">Uint64.Store</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="StoreUintptr">func <a href="/src/sync/atomic/doc.go?s=11693:11738#L230">StoreUintptr</a>
				<a class="permalink" href="#StoreUintptr">&#xb6;</a>
				
				
			</h2>
			<pre>func StoreUintptr(addr *<a href="/pkg/builtin/#uintptr">uintptr</a>, val <a href="/pkg/builtin/#uintptr">uintptr</a>)</pre>
			<p>StoreUintptr atomically stores val into *addr.
Consider using the more ergonomic and less error-prone <a href="#Uintptr.Store">Uintptr.Store</a> instead.

			
			

		
			
			
			<h2 id="SwapInt32">func <a href="/src/sync/atomic/doc.go?s=2494:2544#L58">SwapInt32</a>
				<a class="permalink" href="#SwapInt32">&#xb6;</a>
				
				<span title="Added in Go 1.2">1.2</span>
			</h2>
			<pre>func SwapInt32(addr *<a href="/pkg/builtin/#int32">int32</a>, new <a href="/pkg/builtin/#int32">int32</a>) (old <a href="/pkg/builtin/#int32">int32</a>)</pre>
			<p>SwapInt32 atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone <a href="#Int32.Swap">Int32.Swap</a> instead.

			
			

		
			
			
			<h2 id="SwapInt64">func <a href="/src/sync/atomic/doc.go?s=2781:2831#L63">SwapInt64</a>
				<a class="permalink" href="#SwapInt64">&#xb6;</a>
				
				<span title="Added in Go 1.2">1.2</span>
			</h2>
			<pre>func SwapInt64(addr *<a href="/pkg/builtin/#int64">int64</a>, new <a href="/pkg/builtin/#int64">int64</a>) (old <a href="/pkg/builtin/#int64">int64</a>)</pre>
			<p>SwapInt64 atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone <a href="#Int64.Swap">Int64.Swap</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="SwapPointer">func <a href="/src/sync/atomic/doc.go?s=3744:3823#L80">SwapPointer</a>
				<a class="permalink" href="#SwapPointer">&#xb6;</a>
				
				<span title="Added in Go 1.2">1.2</span>
			</h2>
			<pre>func SwapPointer(addr *<a href="/pkg/unsafe/">unsafe</a>.<a href="/pkg/unsafe/#Pointer">Pointer</a>, new <a href="/pkg/unsafe/">unsafe</a>.<a href="/pkg/unsafe/#Pointer">Pointer</a>) (old <a href="/pkg/unsafe/">unsafe</a>.<a href="/pkg/unsafe/#Pointer">Pointer</a>)</pre>
			<p>SwapPointer atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone <a href="#Pointer.Swap">Pointer.Swap</a> instead.

			
			

		
			
			
			<h2 id="SwapUint32">func <a href="/src/sync/atomic/doc.go?s=2999:3053#L67">SwapUint32</a>
				<a class="permalink" href="#SwapUint32">&#xb6;</a>
				
				<span title="Added in Go 1.2">1.2</span>
			</h2>
			<pre>func SwapUint32(addr *<a href="/pkg/builtin/#uint32">uint32</a>, new <a href="/pkg/builtin/#uint32">uint32</a>) (old <a href="/pkg/builtin/#uint32">uint32</a>)</pre>
			<p>SwapUint32 atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone <a href="#Uint32.Swap">Uint32.Swap</a> instead.

			
			

		
			
			
			<h2 id="SwapUint64">func <a href="/src/sync/atomic/doc.go?s=3292:3346#L72">SwapUint64</a>
				<a class="permalink" href="#SwapUint64">&#xb6;</a>
				
				<span title="Added in Go 1.2">1.2</span>
			</h2>
			<pre>func SwapUint64(addr *<a href="/pkg/builtin/#uint64">uint64</a>, new <a href="/pkg/builtin/#uint64">uint64</a>) (old <a href="/pkg/builtin/#uint64">uint64</a>)</pre>
			<p>SwapUint64 atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone <a href="#Uint64.Swap">Uint64.Swap</a> instead
(particularly if you target 32-bit platforms; see the bugs section).

			
			

		
			
			
			<h2 id="SwapUintptr">func <a href="/src/sync/atomic/doc.go?s=3516:3574#L76">SwapUintptr</a>
				<a class="permalink" href="#SwapUintptr">&#xb6;</a>
				
				<span title="Added in Go 1.2">1.2</span>
			</h2>
			<pre>func SwapUintptr(addr *<a href="/pkg/builtin/#uintptr">uintptr</a>, new <a href="/pkg/builtin/#uintptr">uintptr</a>) (old <a href="/pkg/builtin/#uintptr">uintptr</a>)</pre>
			<p>SwapUintptr atomically stores new into *addr and returns the previous *addr value.
Consider using the more ergonomic and less error-prone <a href="#Uintptr.Swap">Uintptr.Swap</a> instead.

			
			

		
		
			
			
			<h2 id="Bool">type <a href="/src/sync/atomic/type.go?s=259:299#L1">Bool</a>
				<a class="permalink" href="#Bool">&#xb6;</a>
				
				<span title="Added in Go 1.19">1.19</span>
			</h2>
			<p>A Bool is an atomic boolean value.
The zero value is false.

			<pre>type Bool struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Bool.CompareAndSwap">func (*Bool) <a href="/src/sync/atomic/type.go?s=762:821#L16">CompareAndSwap</a>
					<a class="permalink" href="#Bool.CompareAndSwap">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Bool">Bool</a>) CompareAndSwap(old, new <a href="/pkg/builtin/#bool">bool</a>) (swapped <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for the boolean value x.

				
				
				
			
				
				<h3 id="Bool.Load">func (*Bool) <a href="/src/sync/atomic/type.go?s=361:387#L7">Load</a>
					<a class="permalink" href="#Bool.Load">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Bool">Bool</a>) Load() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Load atomically loads and returns the value stored in x.

				
				
				
			
				
				<h3 id="Bool.Store">func (*Bool) <a href="/src/sync/atomic/type.go?s=461:491#L10">Store</a>
					<a class="permalink" href="#Bool.Store">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Bool">Bool</a>) Store(val <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>Store atomically stores val into x.

				
				
				
			
				
				<h3 id="Bool.Swap">func (*Bool) <a href="/src/sync/atomic/type.go?s=594:634#L13">Swap</a>
					<a class="permalink" href="#Bool.Swap">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Bool">Bool</a>) Swap(new <a href="/pkg/builtin/#bool">bool</a>) (old <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>Swap atomically stores new into x and returns the previous value.

				
				
				
			
		
			
			
			<h2 id="Int32">type <a href="/src/sync/atomic/type.go?s=2164:2204#L58">Int32</a>
				<a class="permalink" href="#Int32">&#xb6;</a>
				
				<span title="Added in Go 1.19">1.19</span>
			</h2>
			<p>An Int32 is an atomic int32. The zero value is zero.

			<pre>type Int32 struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Int32.Add">func (*Int32) <a href="/src/sync/atomic/type.go?s=2805:2849#L78">Add</a>
					<a class="permalink" href="#Int32.Add">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Int32">Int32</a>) Add(delta <a href="/pkg/builtin/#int32">int32</a>) (new <a href="/pkg/builtin/#int32">int32</a>)</pre>
				<p>Add atomically adds delta to x and returns the new value.

				
				
				
			
				
				<h3 id="Int32.And">func (*Int32) <a href="/src/sync/atomic/type.go?s=3005:3048#L82">And</a>
					<a class="permalink" href="#Int32.And">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (x *<a href="#Int32">Int32</a>) And(mask <a href="/pkg/builtin/#int32">int32</a>) (old <a href="/pkg/builtin/#int32">int32</a>)</pre>
				<p>And atomically performs a bitwise AND operation on x using the bitmask
provided as mask and returns the old value.

				
				
				
			
				
				<h3 id="Int32.CompareAndSwap">func (*Int32) <a href="/src/sync/atomic/type.go?s=2633:2694#L73">CompareAndSwap</a>
					<a class="permalink" href="#Int32.CompareAndSwap">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Int32">Int32</a>) CompareAndSwap(old, new <a href="/pkg/builtin/#int32">int32</a>) (swapped <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for x.

				
				
				
			
				
				<h3 id="Int32.Load">func (*Int32) <a href="/src/sync/atomic/type.go?s=2266:2294#L64">Load</a>
					<a class="permalink" href="#Int32.Load">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Int32">Int32</a>) Load() <a href="/pkg/builtin/#int32">int32</a></pre>
				<p>Load atomically loads and returns the value stored in x.

				
				
				
			
				
				<h3 id="Int32.Or">func (*Int32) <a href="/src/sync/atomic/type.go?s=3201:3243#L86">Or</a>
					<a class="permalink" href="#Int32.Or">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (x *<a href="#Int32">Int32</a>) Or(mask <a href="/pkg/builtin/#int32">int32</a>) (old <a href="/pkg/builtin/#int32">int32</a>)</pre>
				<p>Or atomically performs a bitwise OR operation on x using the bitmask
provided as mask and returns the old value.

				
				
				
			
				
				<h3 id="Int32.Store">func (*Int32) <a href="/src/sync/atomic/type.go?s=2362:2394#L67">Store</a>
					<a class="permalink" href="#Int32.Store">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Int32">Int32</a>) Store(val <a href="/pkg/builtin/#int32">int32</a>)</pre>
				<p>Store atomically stores val into x.

				
				
				
			
				
				<h3 id="Int32.Swap">func (*Int32) <a href="/src/sync/atomic/type.go?s=2491:2534#L70">Swap</a>
					<a class="permalink" href="#Int32.Swap">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Int32">Int32</a>) Swap(new <a href="/pkg/builtin/#int32">int32</a>) (old <a href="/pkg/builtin/#int32">int32</a>)</pre>
				<p>Swap atomically stores new into x and returns the previous value.

				
				
				
			
		
			
			
			<h2 id="Int64">type <a href="/src/sync/atomic/type.go?s=3332:3383#L89">Int64</a>
				<a class="permalink" href="#Int64">&#xb6;</a>
				
				<span title="Added in Go 1.19">1.19</span>
			</h2>
			<p>An Int64 is an atomic int64. The zero value is zero.

			<pre>type Int64 struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Int64.Add">func (*Int64) <a href="/src/sync/atomic/type.go?s=3984:4028#L110">Add</a>
					<a class="permalink" href="#Int64.Add">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Int64">Int64</a>) Add(delta <a href="/pkg/builtin/#int64">int64</a>) (new <a href="/pkg/builtin/#int64">int64</a>)</pre>
				<p>Add atomically adds delta to x and returns the new value.

				
				
				
			
				
				<h3 id="Int64.And">func (*Int64) <a href="/src/sync/atomic/type.go?s=4184:4227#L114">And</a>
					<a class="permalink" href="#Int64.And">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (x *<a href="#Int64">Int64</a>) And(mask <a href="/pkg/builtin/#int64">int64</a>) (old <a href="/pkg/builtin/#int64">int64</a>)</pre>
				<p>And atomically performs a bitwise AND operation on x using the bitmask
provided as mask and returns the old value.

				
				
				
			
				
				<h3 id="Int64.CompareAndSwap">func (*Int64) <a href="/src/sync/atomic/type.go?s=3812:3873#L105">CompareAndSwap</a>
					<a class="permalink" href="#Int64.CompareAndSwap">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Int64">Int64</a>) CompareAndSwap(old, new <a href="/pkg/builtin/#int64">int64</a>) (swapped <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for x.

				
				
				
			
				
				<h3 id="Int64.Load">func (*Int64) <a href="/src/sync/atomic/type.go?s=3445:3473#L96">Load</a>
					<a class="permalink" href="#Int64.Load">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Int64">Int64</a>) Load() <a href="/pkg/builtin/#int64">int64</a></pre>
				<p>Load atomically loads and returns the value stored in x.

				
				
				
			
				
				<h3 id="Int64.Or">func (*Int64) <a href="/src/sync/atomic/type.go?s=4380:4422#L118">Or</a>
					<a class="permalink" href="#Int64.Or">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (x *<a href="#Int64">Int64</a>) Or(mask <a href="/pkg/builtin/#int64">int64</a>) (old <a href="/pkg/builtin/#int64">int64</a>)</pre>
				<p>Or atomically performs a bitwise OR operation on x using the bitmask
provided as mask and returns the old value.

				
				
				
			
				
				<h3 id="Int64.Store">func (*Int64) <a href="/src/sync/atomic/type.go?s=3541:3573#L99">Store</a>
					<a class="permalink" href="#Int64.Store">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Int64">Int64</a>) Store(val <a href="/pkg/builtin/#int64">int64</a>)</pre>
				<p>Store atomically stores val into x.

				
				
				
			
				
				<h3 id="Int64.Swap">func (*Int64) <a href="/src/sync/atomic/type.go?s=3670:3713#L102">Swap</a>
					<a class="permalink" href="#Int64.Swap">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Int64">Int64</a>) Swap(new <a href="/pkg/builtin/#int64">int64</a>) (old <a href="/pkg/builtin/#int64">int64</a>)</pre>
				<p>Swap atomically stores new into x and returns the previous value.

				
				
				
			
		
			
			
			<h2 id="Pointer">type <a href="/src/sync/atomic/type.go?s=1223:1479#L33">Pointer</a>
				<a class="permalink" href="#Pointer">&#xb6;</a>
				
				
			</h2>
			<p>A Pointer is an atomic pointer of type *T. The zero value is a nil *T.

			<pre>type Pointer[T <a href="/pkg/builtin/#any">any</a>] struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Pointer.CompareAndSwap">func (*Pointer[T]) <a href="/src/sync/atomic/type.go?s=1961:2024#L53">CompareAndSwap</a>
					<a class="permalink" href="#Pointer.CompareAndSwap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Pointer">Pointer</a>[T]) CompareAndSwap(old, new *T) (swapped <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for x.

				
				
				
			
				
				<h3 id="Pointer.Load">func (*Pointer[T]) <a href="/src/sync/atomic/type.go?s=1541:1571#L44">Load</a>
					<a class="permalink" href="#Pointer.Load">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Pointer">Pointer</a>[T]) Load() *T</pre>
				<p>Load atomically loads and returns the value stored in x.

				
				
				
			
				
				<h3 id="Pointer.Store">func (*Pointer[T]) <a href="/src/sync/atomic/type.go?s=1647:1681#L47">Store</a>
					<a class="permalink" href="#Pointer.Store">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Pointer">Pointer</a>[T]) Store(val *T)</pre>
				<p>Store atomically stores val into x.

				
				
				
			
				
				<h3 id="Pointer.Swap">func (*Pointer[T]) <a href="/src/sync/atomic/type.go?s=1796:1838#L50">Swap</a>
					<a class="permalink" href="#Pointer.Swap">&#xb6;</a>
					
					
				</h3>
				<pre>func (x *<a href="#Pointer">Pointer</a>[T]) Swap(new *T) (old *T)</pre>
				<p>Swap atomically stores new into x and returns the previous value.

				
				
				
			
		
			
			
			<h2 id="Uint32">type <a href="/src/sync/atomic/type.go?s=4512:4554#L121">Uint32</a>
				<a class="permalink" href="#Uint32">&#xb6;</a>
				
				<span title="Added in Go 1.19">1.19</span>
			</h2>
			<p>A Uint32 is an atomic uint32. The zero value is zero.

			<pre>type Uint32 struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Uint32.Add">func (*Uint32) <a href="/src/sync/atomic/type.go?s=5168:5215#L141">Add</a>
					<a class="permalink" href="#Uint32.Add">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Uint32">Uint32</a>) Add(delta <a href="/pkg/builtin/#uint32">uint32</a>) (new <a href="/pkg/builtin/#uint32">uint32</a>)</pre>
				<p>Add atomically adds delta to x and returns the new value.

				
				
				
			
				
				<h3 id="Uint32.And">func (*Uint32) <a href="/src/sync/atomic/type.go?s=5372:5418#L145">And</a>
					<a class="permalink" href="#Uint32.And">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (x *<a href="#Uint32">Uint32</a>) And(mask <a href="/pkg/builtin/#uint32">uint32</a>) (old <a href="/pkg/builtin/#uint32">uint32</a>)</pre>
				<p>And atomically performs a bitwise AND operation on x using the bitmask
provided as mask and returns the old value.

				
				
				
			
				
				<h3 id="Uint32.CompareAndSwap">func (*Uint32) <a href="/src/sync/atomic/type.go?s=4993:5056#L136">CompareAndSwap</a>
					<a class="permalink" href="#Uint32.CompareAndSwap">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Uint32">Uint32</a>) CompareAndSwap(old, new <a href="/pkg/builtin/#uint32">uint32</a>) (swapped <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for x.

				
				
				
			
				
				<h3 id="Uint32.Load">func (*Uint32) <a href="/src/sync/atomic/type.go?s=4616:4646#L127">Load</a>
					<a class="permalink" href="#Uint32.Load">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Uint32">Uint32</a>) Load() <a href="/pkg/builtin/#uint32">uint32</a></pre>
				<p>Load atomically loads and returns the value stored in x.

				
				
				
			
				
				<h3 id="Uint32.Or">func (*Uint32) <a href="/src/sync/atomic/type.go?s=5572:5617#L149">Or</a>
					<a class="permalink" href="#Uint32.Or">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (x *<a href="#Uint32">Uint32</a>) Or(mask <a href="/pkg/builtin/#uint32">uint32</a>) (old <a href="/pkg/builtin/#uint32">uint32</a>)</pre>
				<p>Or atomically performs a bitwise OR operation on x using the bitmask
provided as mask and returns the old value.

				
				
				
			
				
				<h3 id="Uint32.Store">func (*Uint32) <a href="/src/sync/atomic/type.go?s=4715:4749#L130">Store</a>
					<a class="permalink" href="#Uint32.Store">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Uint32">Uint32</a>) Store(val <a href="/pkg/builtin/#uint32">uint32</a>)</pre>
				<p>Store atomically stores val into x.

				
				
				
			
				
				<h3 id="Uint32.Swap">func (*Uint32) <a href="/src/sync/atomic/type.go?s=4847:4893#L133">Swap</a>
					<a class="permalink" href="#Uint32.Swap">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Uint32">Uint32</a>) Swap(new <a href="/pkg/builtin/#uint32">uint32</a>) (old <a href="/pkg/builtin/#uint32">uint32</a>)</pre>
				<p>Swap atomically stores new into x and returns the previous value.

				
				
				
			
		
			
			
			<h2 id="Uint64">type <a href="/src/sync/atomic/type.go?s=5708:5761#L152">Uint64</a>
				<a class="permalink" href="#Uint64">&#xb6;</a>
				
				<span title="Added in Go 1.19">1.19</span>
			</h2>
			<p>A Uint64 is an atomic uint64. The zero value is zero.

			<pre>type Uint64 struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Uint64.Add">func (*Uint64) <a href="/src/sync/atomic/type.go?s=6375:6422#L173">Add</a>
					<a class="permalink" href="#Uint64.Add">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Uint64">Uint64</a>) Add(delta <a href="/pkg/builtin/#uint64">uint64</a>) (new <a href="/pkg/builtin/#uint64">uint64</a>)</pre>
				<p>Add atomically adds delta to x and returns the new value.

				
				
				
			
				
				<h3 id="Uint64.And">func (*Uint64) <a href="/src/sync/atomic/type.go?s=6579:6625#L177">And</a>
					<a class="permalink" href="#Uint64.And">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (x *<a href="#Uint64">Uint64</a>) And(mask <a href="/pkg/builtin/#uint64">uint64</a>) (old <a href="/pkg/builtin/#uint64">uint64</a>)</pre>
				<p>And atomically performs a bitwise AND operation on x using the bitmask
provided as mask and returns the old value.

				
				
				
			
				
				<h3 id="Uint64.CompareAndSwap">func (*Uint64) <a href="/src/sync/atomic/type.go?s=6200:6263#L168">CompareAndSwap</a>
					<a class="permalink" href="#Uint64.CompareAndSwap">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Uint64">Uint64</a>) CompareAndSwap(old, new <a href="/pkg/builtin/#uint64">uint64</a>) (swapped <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for x.

				
				
				
			
				
				<h3 id="Uint64.Load">func (*Uint64) <a href="/src/sync/atomic/type.go?s=5823:5853#L159">Load</a>
					<a class="permalink" href="#Uint64.Load">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Uint64">Uint64</a>) Load() <a href="/pkg/builtin/#uint64">uint64</a></pre>
				<p>Load atomically loads and returns the value stored in x.

				
				
				
			
				
				<h3 id="Uint64.Or">func (*Uint64) <a href="/src/sync/atomic/type.go?s=6779:6824#L181">Or</a>
					<a class="permalink" href="#Uint64.Or">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (x *<a href="#Uint64">Uint64</a>) Or(mask <a href="/pkg/builtin/#uint64">uint64</a>) (old <a href="/pkg/builtin/#uint64">uint64</a>)</pre>
				<p>Or atomically performs a bitwise OR operation on x using the bitmask
provided as mask and returns the old value.

				
				
				
			
				
				<h3 id="Uint64.Store">func (*Uint64) <a href="/src/sync/atomic/type.go?s=5922:5956#L162">Store</a>
					<a class="permalink" href="#Uint64.Store">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Uint64">Uint64</a>) Store(val <a href="/pkg/builtin/#uint64">uint64</a>)</pre>
				<p>Store atomically stores val into x.

				
				
				
			
				
				<h3 id="Uint64.Swap">func (*Uint64) <a href="/src/sync/atomic/type.go?s=6054:6100#L165">Swap</a>
					<a class="permalink" href="#Uint64.Swap">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Uint64">Uint64</a>) Swap(new <a href="/pkg/builtin/#uint64">uint64</a>) (old <a href="/pkg/builtin/#uint64">uint64</a>)</pre>
				<p>Swap atomically stores new into x and returns the previous value.

				
				
				
			
		
			
			
			<h2 id="Uintptr">type <a href="/src/sync/atomic/type.go?s=6917:6961#L184">Uintptr</a>
				<a class="permalink" href="#Uintptr">&#xb6;</a>
				
				<span title="Added in Go 1.19">1.19</span>
			</h2>
			<p>A Uintptr is an atomic uintptr. The zero value is zero.

			<pre>type Uintptr struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Uintptr.Add">func (*Uintptr) <a href="/src/sync/atomic/type.go?s=7588:7638#L204">Add</a>
					<a class="permalink" href="#Uintptr.Add">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Uintptr">Uintptr</a>) Add(delta <a href="/pkg/builtin/#uintptr">uintptr</a>) (new <a href="/pkg/builtin/#uintptr">uintptr</a>)</pre>
				<p>Add atomically adds delta to x and returns the new value.

				
				
				
			
				
				<h3 id="Uintptr.And">func (*Uintptr) <a href="/src/sync/atomic/type.go?s=7796:7845#L208">And</a>
					<a class="permalink" href="#Uintptr.And">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (x *<a href="#Uintptr">Uintptr</a>) And(mask <a href="/pkg/builtin/#uintptr">uintptr</a>) (old <a href="/pkg/builtin/#uintptr">uintptr</a>)</pre>
				<p>And atomically performs a bitwise AND operation on x using the bitmask
provided as mask and returns the old value.

				
				
				
			
				
				<h3 id="Uintptr.CompareAndSwap">func (*Uintptr) <a href="/src/sync/atomic/type.go?s=7410:7475#L199">CompareAndSwap</a>
					<a class="permalink" href="#Uintptr.CompareAndSwap">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Uintptr">Uintptr</a>) CompareAndSwap(old, new <a href="/pkg/builtin/#uintptr">uintptr</a>) (swapped <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for x.

				
				
				
			
				
				<h3 id="Uintptr.Load">func (*Uintptr) <a href="/src/sync/atomic/type.go?s=7023:7055#L190">Load</a>
					<a class="permalink" href="#Uintptr.Load">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Uintptr">Uintptr</a>) Load() <a href="/pkg/builtin/#uintptr">uintptr</a></pre>
				<p>Load atomically loads and returns the value stored in x.

				
				
				
			
				
				<h3 id="Uintptr.Or">func (*Uintptr) <a href="/src/sync/atomic/type.go?s=8027:8075#L212">Or</a>
					<a class="permalink" href="#Uintptr.Or">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (x *<a href="#Uintptr">Uintptr</a>) Or(mask <a href="/pkg/builtin/#uintptr">uintptr</a>) (old <a href="/pkg/builtin/#uintptr">uintptr</a>)</pre>
				<p>Or atomically performs a bitwise OR operation on x using the bitmask
provided as mask and returns the updated value after the OR operation.

				
				
				
			
				
				<h3 id="Uintptr.Store">func (*Uintptr) <a href="/src/sync/atomic/type.go?s=7125:7161#L193">Store</a>
					<a class="permalink" href="#Uintptr.Store">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Uintptr">Uintptr</a>) Store(val <a href="/pkg/builtin/#uintptr">uintptr</a>)</pre>
				<p>Store atomically stores val into x.

				
				
				
			
				
				<h3 id="Uintptr.Swap">func (*Uintptr) <a href="/src/sync/atomic/type.go?s=7260:7309#L196">Swap</a>
					<a class="permalink" href="#Uintptr.Swap">&#xb6;</a>
					
					<span title="Added in Go 1.19">1.19</span>
				</h3>
				<pre>func (x *<a href="#Uintptr">Uintptr</a>) Swap(new <a href="/pkg/builtin/#uintptr">uintptr</a>) (old <a href="/pkg/builtin/#uintptr">uintptr</a>)</pre>
				<p>Swap atomically stores new into x and returns the previous value.

				
				
				
			
		
			
			
			<h2 id="Value">type <a href="/src/sync/atomic/value.go?s=452:480#L6">Value</a>
				<a class="permalink" href="#Value">&#xb6;</a>
				
				<span title="Added in Go 1.4">1.4</span>
			</h2>
			<p>A Value provides an atomic load and store of a consistently typed value.
The zero value for a Value returns nil from <a href="#Value.Load">Value.Load</a>.
Once <a href="#Value.Store">Value.Store</a> has been called, a Value must not be copied.
<p>A Value must not be copied after first use.

			<pre>type Value struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Value_config" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Config)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Config)</span></p>
		<p>The following example shows how to use Value for periodic program config updates
and propagation of the changes to worker goroutines.
</p>
		
		
			<p>Code:</p>
			<pre class="code">
var config atomic.Value <span class="comment">// holds current server configuration</span>
<span class="comment">// Create initial config value and store into config.</span>
config.Store(loadConfig())
go func() {
    <span class="comment">// Reload config every 10 seconds</span>
    <span class="comment">// and update config value with the new version.</span>
    for {
        time.Sleep(10 * time.Second)
        config.Store(loadConfig())
    }
}()
<span class="comment">// Create worker goroutines that handle incoming requests</span>
<span class="comment">// using the latest config value.</span>
for i := 0; i &lt; 10; i++ {
    go func() {
        for r := range requests() {
            c := config.Load()
            <span class="comment">// Handle request r using config c.</span>
            _, _ = r, c
        }
    }()
}
</pre>
			
		
	</div>
</div>
<div id="example_Value_readMostly" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (ReadMostly)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (ReadMostly)</span></p>
		<p>The following example shows how to maintain a scalable frequently read,
but infrequently updated data structure using copy-on-write idiom.
</p>
		
		
			<p>Code:</p>
			<pre class="code">
type Map map[string]string
var m atomic.Value
m.Store(make(Map))
var mu sync.Mutex <span class="comment">// used only by writers</span>
<span class="comment">// read function can be used to read the data without further synchronization</span>
read := func(key string) (val string) {
    m1 := m.Load().(Map)
    return m1[key]
}
<span class="comment">// insert function can be used to update the data without further synchronization</span>
insert := func(key, val string) {
    mu.Lock() <span class="comment">// synchronize with other potential writers</span>
    defer mu.Unlock()
    m1 := m.Load().(Map) <span class="comment">// load current value of the data structure</span>
    m2 := make(Map)      <span class="comment">// create a new value</span>
    for k, v := range m1 {
        m2[k] = v <span class="comment">// copy all data from the current object to the new one</span>
    }
    m2[key] = val <span class="comment">// do the update that we need</span>
    m.Store(m2)   <span class="comment">// atomically replace the current object with the new one</span>
    <span class="comment">// At this point all new readers start working with the new version.</span>
    <span class="comment">// The old version will be garbage collected once the existing readers</span>
    <span class="comment">// (if any) are done with it.</span>
}
_, _ = read, insert
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="Value.CompareAndSwap">func (*Value) <a href="/src/sync/atomic/value.go?s=4097:4156#L125">CompareAndSwap</a>
					<a class="permalink" href="#Value.CompareAndSwap">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (v *<a href="#Value">Value</a>) CompareAndSwap(old, new <a href="/pkg/builtin/#any">any</a>) (swapped <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>CompareAndSwap executes the compare-and-swap operation for the <a href="#Value">Value</a>.
<p>All calls to CompareAndSwap for a given Value must use values of the same
concrete type. CompareAndSwap of an inconsistent type panics, as does
CompareAndSwap(old, nil).

				
				
				
			
				
				<h3 id="Value.Load">func (*Value) <a href="/src/sync/atomic/value.go?s=731:763#L18">Load</a>
					<a class="permalink" href="#Value.Load">&#xb6;</a>
					
					<span title="Added in Go 1.4">1.4</span>
				</h3>
				<pre>func (v *<a href="#Value">Value</a>) Load() (val <a href="/pkg/builtin/#any">any</a>)</pre>
				<p>Load returns the value set by the most recent Store.
It returns nil if there has been no call to Store for this Value.

				
				
				
			
				
				<h3 id="Value.Store">func (*Value) <a href="/src/sync/atomic/value.go?s=1294:1324#L37">Store</a>
					<a class="permalink" href="#Value.Store">&#xb6;</a>
					
					<span title="Added in Go 1.4">1.4</span>
				</h3>
				<pre>func (v *<a href="#Value">Value</a>) Store(val <a href="/pkg/builtin/#any">any</a>)</pre>
				<p>Store sets the value of the <a href="#Value">Value</a> v to val.
All calls to Store for a given Value must use values of the same concrete type.
Store of an inconsistent type panics, as does Store(nil).

				
				
				
			
				
				<h3 id="Value.Swap">func (*Value) <a href="/src/sync/atomic/value.go?s=2620:2659#L80">Swap</a>
					<a class="permalink" href="#Value.Swap">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (v *<a href="#Value">Value</a>) Swap(new <a href="/pkg/builtin/#any">any</a>) (old <a href="/pkg/builtin/#any">any</a>)</pre>
				<p>Swap stores new into Value and returns the previous value. It returns nil if
the Value is empty.
<p>All calls to Swap for a given Value must use values of the same concrete
type. Swap of an inconsistent type panics, as does Swap(nil).

				
				
				
			
		
	

	
		
			<h2 id="pkg-note-BUG">Bugs</h2>
			<ul style="list-style: none; padding: 0;">
			
			<li><a href="/src/sync/atomic/doc.go?s=1679:2328#L45" style="float: left;">&#x261e;</a> <p>On 386, the 64-bit functions use instructions unavailable before the Pentium MMX.
<p>On non-Linux ARM, the 64-bit functions use instructions unavailable before the ARMv6k core.
<p>On ARM, 386, and 32-bit MIPS, it is the caller&apos;s responsibility to arrange
for 64-bit alignment of 64-bit words accessed atomically via the primitive
atomic functions (types <a href="#Int64">Int64</a> and <a href="#Uint64">Uint64</a> are automatically aligned).
The first word in an allocated struct, array, or slice; in a global
variable; or in a local variable (because the subject of all atomic operations
will escape to the heap) can be relied upon to be 64-bit aligned.
</li>
			
			</ul>
		
	







<div id="footer">
Build version go1.23.0.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
