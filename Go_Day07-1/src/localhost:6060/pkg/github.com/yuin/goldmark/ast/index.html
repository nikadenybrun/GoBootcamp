<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>ast - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.23.0";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package ast
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "github.com/yuin/goldmark/ast"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package ast defines AST nodes that represent markdown elements.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#DumpHelper">func DumpHelper(v Node, source []byte, level int, kv map[string]string, cb func(int))</a></dd>
			
				
				<dd><a href="#IsParagraph">func IsParagraph(node Node) bool</a></dd>
			
				
				<dd><a href="#MergeOrAppendTextSegment">func MergeOrAppendTextSegment(parent Node, s textm.Segment)</a></dd>
			
				
				<dd><a href="#MergeOrReplaceTextSegment">func MergeOrReplaceTextSegment(parent Node, n Node, s textm.Segment)</a></dd>
			
				
				<dd><a href="#Walk">func Walk(n Node, walker Walker) error</a></dd>
			
			
				
				<dd><a href="#Attribute">type Attribute</a></dd>
				
				
			
				
				<dd><a href="#AutoLink">type AutoLink</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewAutoLink">func NewAutoLink(typ AutoLinkType, value *Text) *AutoLink</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AutoLink.Dump">func (n *AutoLink) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AutoLink.Inline">func (n *AutoLink) Inline()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AutoLink.Kind">func (n *AutoLink) Kind() NodeKind</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AutoLink.Label">func (n *AutoLink) Label(source []byte) []byte</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AutoLink.URL">func (n *AutoLink) URL(source []byte) []byte</a></dd>
				
			
				
				<dd><a href="#AutoLinkType">type AutoLinkType</a></dd>
				
				
			
				
				<dd><a href="#BaseBlock">type BaseBlock</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseBlock.HasBlankPreviousLines">func (b *BaseBlock) HasBlankPreviousLines() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseBlock.IsRaw">func (b *BaseBlock) IsRaw() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseBlock.Lines">func (b *BaseBlock) Lines() *textm.Segments</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseBlock.SetBlankPreviousLines">func (b *BaseBlock) SetBlankPreviousLines(v bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseBlock.SetLines">func (b *BaseBlock) SetLines(v *textm.Segments)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseBlock.Type">func (b *BaseBlock) Type() NodeType</a></dd>
				
			
				
				<dd><a href="#BaseInline">type BaseInline</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseInline.HasBlankPreviousLines">func (b *BaseInline) HasBlankPreviousLines() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseInline.IsRaw">func (b *BaseInline) IsRaw() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseInline.Lines">func (b *BaseInline) Lines() *textm.Segments</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseInline.SetBlankPreviousLines">func (b *BaseInline) SetBlankPreviousLines(v bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseInline.SetLines">func (b *BaseInline) SetLines(v *textm.Segments)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseInline.Type">func (b *BaseInline) Type() NodeType</a></dd>
				
			
				
				<dd><a href="#BaseNode">type BaseNode</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.AppendChild">func (n *BaseNode) AppendChild(self, v Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.Attribute">func (n *BaseNode) Attribute(name []byte) (interface{}, bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.AttributeString">func (n *BaseNode) AttributeString(s string) (interface{}, bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.Attributes">func (n *BaseNode) Attributes() []Attribute</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.ChildCount">func (n *BaseNode) ChildCount() int</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.FirstChild">func (n *BaseNode) FirstChild() Node</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.HasChildren">func (n *BaseNode) HasChildren() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.InsertAfter">func (n *BaseNode) InsertAfter(self, v1, insertee Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.InsertBefore">func (n *BaseNode) InsertBefore(self, v1, insertee Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.LastChild">func (n *BaseNode) LastChild() Node</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.NextSibling">func (n *BaseNode) NextSibling() Node</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.OwnerDocument">func (n *BaseNode) OwnerDocument() *Document</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.Parent">func (n *BaseNode) Parent() Node</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.PreviousSibling">func (n *BaseNode) PreviousSibling() Node</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.RemoveAttributes">func (n *BaseNode) RemoveAttributes()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.RemoveChild">func (n *BaseNode) RemoveChild(self, v Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.RemoveChildren">func (n *BaseNode) RemoveChildren(self Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.ReplaceChild">func (n *BaseNode) ReplaceChild(self, v1, insertee Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.SetAttribute">func (n *BaseNode) SetAttribute(name []byte, value interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.SetAttributeString">func (n *BaseNode) SetAttributeString(name string, value interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.SetNextSibling">func (n *BaseNode) SetNextSibling(v Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.SetParent">func (n *BaseNode) SetParent(v Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.SetPreviousSibling">func (n *BaseNode) SetPreviousSibling(v Node)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.SortChildren">func (n *BaseNode) SortChildren(comparator func(n1, n2 Node) int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BaseNode.Text">func (n *BaseNode) Text(source []byte) []byte</a></dd>
				
			
				
				<dd><a href="#Blockquote">type Blockquote</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewBlockquote">func NewBlockquote() *Blockquote</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Blockquote.Dump">func (n *Blockquote) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Blockquote.Kind">func (n *Blockquote) Kind() NodeKind</a></dd>
				
			
				
				<dd><a href="#CodeBlock">type CodeBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCodeBlock">func NewCodeBlock() *CodeBlock</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CodeBlock.Dump">func (n *CodeBlock) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CodeBlock.IsRaw">func (n *CodeBlock) IsRaw() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CodeBlock.Kind">func (n *CodeBlock) Kind() NodeKind</a></dd>
				
			
				
				<dd><a href="#CodeSpan">type CodeSpan</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewCodeSpan">func NewCodeSpan() *CodeSpan</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CodeSpan.Dump">func (n *CodeSpan) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CodeSpan.Inline">func (n *CodeSpan) Inline()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CodeSpan.IsBlank">func (n *CodeSpan) IsBlank(source []byte) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CodeSpan.Kind">func (n *CodeSpan) Kind() NodeKind</a></dd>
				
			
				
				<dd><a href="#Document">type Document</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewDocument">func NewDocument() *Document</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Document.AddMeta">func (n *Document) AddMeta(key string, value interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Document.Dump">func (n *Document) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Document.Kind">func (n *Document) Kind() NodeKind</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Document.Meta">func (n *Document) Meta() map[string]interface{}</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Document.OwnerDocument">func (n *Document) OwnerDocument() *Document</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Document.SetMeta">func (n *Document) SetMeta(meta map[string]interface{})</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Document.Type">func (n *Document) Type() NodeType</a></dd>
				
			
				
				<dd><a href="#Emphasis">type Emphasis</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewEmphasis">func NewEmphasis(level int) *Emphasis</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Emphasis.Dump">func (n *Emphasis) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Emphasis.Kind">func (n *Emphasis) Kind() NodeKind</a></dd>
				
			
				
				<dd><a href="#FencedCodeBlock">type FencedCodeBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewFencedCodeBlock">func NewFencedCodeBlock(info *Text) *FencedCodeBlock</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FencedCodeBlock.Dump">func (n *FencedCodeBlock) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FencedCodeBlock.IsRaw">func (n *FencedCodeBlock) IsRaw() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FencedCodeBlock.Kind">func (n *FencedCodeBlock) Kind() NodeKind</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FencedCodeBlock.Language">func (n *FencedCodeBlock) Language(source []byte) []byte</a></dd>
				
			
				
				<dd><a href="#HTMLBlock">type HTMLBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewHTMLBlock">func NewHTMLBlock(typ HTMLBlockType) *HTMLBlock</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#HTMLBlock.Dump">func (n *HTMLBlock) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#HTMLBlock.HasClosure">func (n *HTMLBlock) HasClosure() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#HTMLBlock.IsRaw">func (n *HTMLBlock) IsRaw() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#HTMLBlock.Kind">func (n *HTMLBlock) Kind() NodeKind</a></dd>
				
			
				
				<dd><a href="#HTMLBlockType">type HTMLBlockType</a></dd>
				
				
			
				
				<dd><a href="#Heading">type Heading</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewHeading">func NewHeading(level int) *Heading</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Heading.Dump">func (n *Heading) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Heading.Kind">func (n *Heading) Kind() NodeKind</a></dd>
				
			
				
				<dd><a href="#Image">type Image</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewImage">func NewImage(link *Link) *Image</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Image.Dump">func (n *Image) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Image.Inline">func (n *Image) Inline()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Image.Kind">func (n *Image) Kind() NodeKind</a></dd>
				
			
				
				<dd><a href="#Link">type Link</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewLink">func NewLink() *Link</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Link.Dump">func (n *Link) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Link.Inline">func (n *Link) Inline()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Link.Kind">func (n *Link) Kind() NodeKind</a></dd>
				
			
				
				<dd><a href="#List">type List</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewList">func NewList(marker byte) *List</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#List.CanContinue">func (l *List) CanContinue(marker byte, isOrdered bool) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#List.Dump">func (l *List) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#List.IsOrdered">func (l *List) IsOrdered() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#List.Kind">func (l *List) Kind() NodeKind</a></dd>
				
			
				
				<dd><a href="#ListItem">type ListItem</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewListItem">func NewListItem(offset int) *ListItem</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ListItem.Dump">func (n *ListItem) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListItem.Kind">func (n *ListItem) Kind() NodeKind</a></dd>
				
			
				
				<dd><a href="#Node">type Node</a></dd>
				
				
			
				
				<dd><a href="#NodeKind">type NodeKind</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewNodeKind">func NewNodeKind(name string) NodeKind</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NodeKind.String">func (k NodeKind) String() string</a></dd>
				
			
				
				<dd><a href="#NodeType">type NodeType</a></dd>
				
				
			
				
				<dd><a href="#Paragraph">type Paragraph</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewParagraph">func NewParagraph() *Paragraph</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Paragraph.Dump">func (n *Paragraph) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Paragraph.Kind">func (n *Paragraph) Kind() NodeKind</a></dd>
				
			
				
				<dd><a href="#RawHTML">type RawHTML</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRawHTML">func NewRawHTML() *RawHTML</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RawHTML.Dump">func (n *RawHTML) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RawHTML.Inline">func (n *RawHTML) Inline()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RawHTML.Kind">func (n *RawHTML) Kind() NodeKind</a></dd>
				
			
				
				<dd><a href="#String">type String</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewString">func NewString(v []byte) *String</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#String.Dump">func (n *String) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#String.Inline">func (n *String) Inline()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#String.IsCode">func (n *String) IsCode() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#String.IsRaw">func (n *String) IsRaw() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#String.Kind">func (n *String) Kind() NodeKind</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#String.SetCode">func (n *String) SetCode(v bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#String.SetRaw">func (n *String) SetRaw(v bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#String.Text">func (n *String) Text(source []byte) []byte</a></dd>
				
			
				
				<dd><a href="#Text">type Text</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewRawTextSegment">func NewRawTextSegment(v textm.Segment) *Text</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewText">func NewText() *Text</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewTextSegment">func NewTextSegment(v textm.Segment) *Text</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Text.Dump">func (n *Text) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Text.HardLineBreak">func (n *Text) HardLineBreak() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Text.Inline">func (n *Text) Inline()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Text.IsRaw">func (n *Text) IsRaw() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Text.Kind">func (n *Text) Kind() NodeKind</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Text.Merge">func (n *Text) Merge(node Node, source []byte) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Text.SetHardLineBreak">func (n *Text) SetHardLineBreak(v bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Text.SetRaw">func (n *Text) SetRaw(v bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Text.SetSoftLineBreak">func (n *Text) SetSoftLineBreak(v bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Text.SoftLineBreak">func (n *Text) SoftLineBreak() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Text.Text">func (n *Text) Text(source []byte) []byte</a></dd>
				
			
				
				<dd><a href="#TextBlock">type TextBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewTextBlock">func NewTextBlock() *TextBlock</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TextBlock.Dump">func (n *TextBlock) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TextBlock.Kind">func (n *TextBlock) Kind() NodeKind</a></dd>
				
			
				
				<dd><a href="#ThematicBreak">type ThematicBreak</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewThematicBreak">func NewThematicBreak() *ThematicBreak</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ThematicBreak.Dump">func (n *ThematicBreak) Dump(source []byte, level int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ThematicBreak.Kind">func (n *ThematicBreak) Kind() NodeKind</a></dd>
				
			
				
				<dd><a href="#WalkStatus">type WalkStatus</a></dd>
				
				
			
				
				<dd><a href="#Walker">type Walker</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/github.com/yuin/goldmark/ast/ast.go">ast.go</a>
			
				<a href="/src/github.com/yuin/goldmark/ast/block.go">block.go</a>
			
				<a href="/src/github.com/yuin/goldmark/ast/inline.go">inline.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>KindAutoLink is a NodeKind of the AutoLink node.

				<pre>var <span id="KindAutoLink">KindAutoLink</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;AutoLink&#34;)</pre>
			
				<p>KindBlockquote is a NodeKind of the Blockquote node.

				<pre>var <span id="KindBlockquote">KindBlockquote</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;Blockquote&#34;)</pre>
			
				<p>KindCodeBlock is a NodeKind of the CodeBlock node.

				<pre>var <span id="KindCodeBlock">KindCodeBlock</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;CodeBlock&#34;)</pre>
			
				<p>KindCodeSpan is a NodeKind of the CodeSpan node.

				<pre>var <span id="KindCodeSpan">KindCodeSpan</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;CodeSpan&#34;)</pre>
			
				<p>KindDocument is a NodeKind of the Document node.

				<pre>var <span id="KindDocument">KindDocument</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;Document&#34;)</pre>
			
				<p>KindEmphasis is a NodeKind of the Emphasis node.

				<pre>var <span id="KindEmphasis">KindEmphasis</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;Emphasis&#34;)</pre>
			
				<p>KindFencedCodeBlock is a NodeKind of the FencedCodeBlock node.

				<pre>var <span id="KindFencedCodeBlock">KindFencedCodeBlock</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;FencedCodeBlock&#34;)</pre>
			
				<p>KindHTMLBlock is a NodeKind of the HTMLBlock node.

				<pre>var <span id="KindHTMLBlock">KindHTMLBlock</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;HTMLBlock&#34;)</pre>
			
				<p>KindHeading is a NodeKind of the Heading node.

				<pre>var <span id="KindHeading">KindHeading</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;Heading&#34;)</pre>
			
				<p>KindImage is a NodeKind of the Image node.

				<pre>var <span id="KindImage">KindImage</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;Image&#34;)</pre>
			
				<p>KindLink is a NodeKind of the Link node.

				<pre>var <span id="KindLink">KindLink</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;Link&#34;)</pre>
			
				<p>KindList is a NodeKind of the List node.

				<pre>var <span id="KindList">KindList</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;List&#34;)</pre>
			
				<p>KindListItem is a NodeKind of the ListItem node.

				<pre>var <span id="KindListItem">KindListItem</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;ListItem&#34;)</pre>
			
				<p>KindParagraph is a NodeKind of the Paragraph node.

				<pre>var <span id="KindParagraph">KindParagraph</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;Paragraph&#34;)</pre>
			
				<p>KindRawHTML is a NodeKind of the RawHTML node.

				<pre>var <span id="KindRawHTML">KindRawHTML</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;RawHTML&#34;)</pre>
			
				<p>KindString is a NodeKind of the String node.

				<pre>var <span id="KindString">KindString</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;String&#34;)</pre>
			
				<p>KindText is a NodeKind of the Text node.

				<pre>var <span id="KindText">KindText</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;Text&#34;)</pre>
			
				<p>KindTextBlock is a NodeKind of the TextBlock node.

				<pre>var <span id="KindTextBlock">KindTextBlock</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;TextBlock&#34;)</pre>
			
				<p>KindThematicBreak is a NodeKind of the ThematicBreak node.

				<pre>var <span id="KindThematicBreak">KindThematicBreak</span> = <a href="#NewNodeKind">NewNodeKind</a>(&#34;ThematicBreak&#34;)</pre>
			
		
		
			
			
			<h2 id="DumpHelper">func <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=11053:11138#L428">DumpHelper</a>
				<a class="permalink" href="#DumpHelper">&#xb6;</a>
				
				
			</h2>
			<pre>func DumpHelper(v <a href="#Node">Node</a>, source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>, kv map[<a href="/pkg/builtin/#string">string</a>]<a href="/pkg/builtin/#string">string</a>, cb func(<a href="/pkg/builtin/#int">int</a>))</pre>
			<p>DumpHelper is a helper function to implement Node.Dump.
kv is pairs of an attribute name and an attribute value.
cb is a function called after wrote a name and attributes.

			
			

		
			
			
			<h2 id="IsParagraph">func <a href="/src/github.com/yuin/goldmark/ast/block.go?s=3555:3587#L157">IsParagraph</a>
				<a class="permalink" href="#IsParagraph">&#xb6;</a>
				
				
			</h2>
			<pre>func IsParagraph(node <a href="#Node">Node</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>IsParagraph returns true if the given node implements the Paragraph interface,
otherwise false.

			
			

		
			
			
			<h2 id="MergeOrAppendTextSegment">func <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=4610:4669#L186">MergeOrAppendTextSegment</a>
				<a class="permalink" href="#MergeOrAppendTextSegment">&#xb6;</a>
				
				
			</h2>
			<pre>func MergeOrAppendTextSegment(parent <a href="#Node">Node</a>, s <a href="/pkg/github.com/yuin/goldmark/text/">textm</a>.<a href="/pkg/github.com/yuin/goldmark/text/#Segment">Segment</a>)</pre>
			<p>MergeOrAppendTextSegment merges a given s into the last child of the parent if
it can be merged, otherwise creates a new Text node and appends it to after current
last child.

			
			

		
			
			
			<h2 id="MergeOrReplaceTextSegment">func <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=5055:5123#L198">MergeOrReplaceTextSegment</a>
				<a class="permalink" href="#MergeOrReplaceTextSegment">&#xb6;</a>
				
				
			</h2>
			<pre>func MergeOrReplaceTextSegment(parent <a href="#Node">Node</a>, n <a href="#Node">Node</a>, s <a href="/pkg/github.com/yuin/goldmark/text/">textm</a>.<a href="/pkg/github.com/yuin/goldmark/text/#Segment">Segment</a>)</pre>
			<p>MergeOrReplaceTextSegment merges a given s into a previous sibling of the node n
if a previous sibling of the node n is *Text, otherwise replaces Node n with s.

			
			

		
			
			
			<h2 id="Walk">func <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=12506:12544#L476">Walk</a>
				<a class="permalink" href="#Walk">&#xb6;</a>
				
				
			</h2>
			<pre>func Walk(n <a href="#Node">Node</a>, walker <a href="#Walker">Walker</a>) <a href="/pkg/builtin/#error">error</a></pre>
			<p>Walk walks a AST tree by the depth first search algorithm.

			
			

		
		
			
			
			<h2 id="Attribute">type <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=900:958#L33">Attribute</a>
				<a class="permalink" href="#Attribute">&#xb6;</a>
				
				
			</h2>
			<p>An Attribute is an attribute of the Node.

			<pre>type Attribute struct {
<span id="Attribute.Name"></span>    Name  []<a href="/pkg/builtin/#byte">byte</a>
<span id="Attribute.Value"></span>    Value interface{}
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="AutoLink">type <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=10538:10717#L447">AutoLink</a>
				<a class="permalink" href="#AutoLink">&#xb6;</a>
				
				
			</h2>
			<p>An AutoLink struct represents an autolink of the Markdown text.

			<pre>type AutoLink struct {
    <a href="#BaseInline">BaseInline</a>
    <span class="comment">// Type is a type of this autolink.</span>
<span id="AutoLink.AutoLinkType"></span>    AutoLinkType <a href="#AutoLinkType">AutoLinkType</a>

<span id="AutoLink.Protocol"></span>    <span class="comment">// Protocol specified a protocol of the link.</span>
    Protocol []<a href="/pkg/builtin/#byte">byte</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewAutoLink">func <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=11704:11761#L497">NewAutoLink</a>
					<a class="permalink" href="#NewAutoLink">&#xb6;</a>
					
					
				</h3>
				<pre>func NewAutoLink(typ <a href="#AutoLinkType">AutoLinkType</a>, value *<a href="#Text">Text</a>) *<a href="#AutoLink">AutoLink</a></pre>
				<p>NewAutoLink returns a new AutoLink node.

				
				
			

			
				
				<h3 id="AutoLink.Dump">func (*AutoLink) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=10817:10866#L462">Dump</a>
					<a class="permalink" href="#AutoLink.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#AutoLink">AutoLink</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump.

				
				
				
			
				
				<h3 id="AutoLink.Inline">func (*AutoLink) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=10755:10782#L459">Inline</a>
					<a class="permalink" href="#AutoLink.Inline">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#AutoLink">AutoLink</a>) Inline()</pre>
				<p>Inline implements Inline.Inline.

				
				
				
			
				
				<h3 id="AutoLink.Kind">func (*AutoLink) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=11134:11168#L474">Kind</a>
					<a class="permalink" href="#AutoLink.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#AutoLink">AutoLink</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
				
				<h3 id="AutoLink.Label">func (*AutoLink) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=11579:11625#L492">Label</a>
					<a class="permalink" href="#AutoLink.Label">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#AutoLink">AutoLink</a>) Label(source []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>Label returns a label of this node.

				
				
				
			
				
				<h3 id="AutoLink.URL">func (*AutoLink) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=11231:11275#L479">URL</a>
					<a class="permalink" href="#AutoLink.URL">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#AutoLink">AutoLink</a>) URL(source []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>URL returns an url of this node.

				
				
				
			
		
			
			
			<h2 id="AutoLinkType">type <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=10258:10279#L437">AutoLinkType</a>
				<a class="permalink" href="#AutoLinkType">&#xb6;</a>
				
				
			</h2>
			<p>AutoLinkType defines kind of auto links.

			<pre>type AutoLinkType <a href="/pkg/builtin/#int">int</a></pre>

			
				
				<pre>const (
    <span class="comment">// AutoLinkEmail indicates that an autolink is an email address.</span>
    <span id="AutoLinkEmail">AutoLinkEmail</span> <a href="#AutoLinkType">AutoLinkType</a> = <a href="/pkg/builtin/#iota">iota</a> + 1
    <span class="comment">// AutoLinkURL indicates that an autolink is a generic URL.</span>
    <span id="AutoLinkURL">AutoLinkURL</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="BaseBlock">type <a href="/src/github.com/yuin/goldmark/ast/block.go?s=147:243#L1">BaseBlock</a>
				<a class="permalink" href="#BaseBlock">&#xb6;</a>
				
				
			</h2>
			<p>A BaseBlock struct implements the Node interface partialliy.

			<pre>type BaseBlock struct {
    <a href="#BaseNode">BaseNode</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="BaseBlock.HasBlankPreviousLines">func (*BaseBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=482:530#L18">HasBlankPreviousLines</a>
					<a class="permalink" href="#BaseBlock.HasBlankPreviousLines">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BaseBlock">BaseBlock</a>) HasBlankPreviousLines() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>HasBlankPreviousLines implements Node.HasBlankPreviousLines.

				
				
				
			
				
				<h3 id="BaseBlock.IsRaw">func (*BaseBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=366:398#L13">IsRaw</a>
					<a class="permalink" href="#BaseBlock.IsRaw">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BaseBlock">BaseBlock</a>) IsRaw() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsRaw implements Node.IsRaw.

				
				
				
			
				
				<h3 id="BaseBlock.Lines">func (*BaseBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=742:785#L28">Lines</a>
					<a class="permalink" href="#BaseBlock.Lines">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BaseBlock">BaseBlock</a>) Lines() *<a href="/pkg/github.com/yuin/goldmark/text/">textm</a>.<a href="/pkg/github.com/yuin/goldmark/text/#Segments">Segments</a></pre>
				<p>Lines implements Node.Lines.

				
				
				
			
				
				<h3 id="BaseBlock.SetBlankPreviousLines">func (*BaseBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=629:678#L23">SetBlankPreviousLines</a>
					<a class="permalink" href="#BaseBlock.SetBlankPreviousLines">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BaseBlock">BaseBlock</a>) SetBlankPreviousLines(v <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>SetBlankPreviousLines implements Node.SetBlankPreviousLines.

				
				
				
			
				
				<h3 id="BaseBlock.SetLines">func (*BaseBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=901:948#L36">SetLines</a>
					<a class="permalink" href="#BaseBlock.SetLines">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BaseBlock">BaseBlock</a>) SetLines(v *<a href="/pkg/github.com/yuin/goldmark/text/">textm</a>.<a href="/pkg/github.com/yuin/goldmark/text/#Segments">Segments</a>)</pre>
				<p>SetLines implements Node.SetLines.

				
				
				
			
				
				<h3 id="BaseBlock.Type">func (*BaseBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=275:310#L8">Type</a>
					<a class="permalink" href="#BaseBlock.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BaseBlock">BaseBlock</a>) Type() <a href="#NodeType">NodeType</a></pre>
				<p>Type implements Node.Type.

				
				
				
			
		
			
			
			<h2 id="BaseInline">type <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=181:217#L2">BaseInline</a>
				<a class="permalink" href="#BaseInline">&#xb6;</a>
				
				
			</h2>
			<p>A BaseInline struct implements the Node interface partialliy.

			<pre>type BaseInline struct {
    <a href="#BaseNode">BaseNode</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="BaseInline.HasBlankPreviousLines">func (*BaseInline) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=459:508#L17">HasBlankPreviousLines</a>
					<a class="permalink" href="#BaseInline.HasBlankPreviousLines">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BaseInline">BaseInline</a>) HasBlankPreviousLines() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>HasBlankPreviousLines implements Node.HasBlankPreviousLines.

				
				
				
			
				
				<h3 id="BaseInline.IsRaw">func (*BaseInline) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=342:375#L12">IsRaw</a>
					<a class="permalink" href="#BaseInline.IsRaw">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BaseInline">BaseInline</a>) IsRaw() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsRaw implements Node.IsRaw.

				
				
				
			
				
				<h3 id="BaseInline.Lines">func (*BaseInline) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=750:794#L27">Lines</a>
					<a class="permalink" href="#BaseInline.Lines">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BaseInline">BaseInline</a>) Lines() *<a href="/pkg/github.com/yuin/goldmark/text/">textm</a>.<a href="/pkg/github.com/yuin/goldmark/text/#Segments">Segments</a></pre>
				<p>Lines implements Node.Lines.

				
				
				
			
				
				<h3 id="BaseInline.SetBlankPreviousLines">func (*BaseInline) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=620:670#L22">SetBlankPreviousLines</a>
					<a class="permalink" href="#BaseInline.SetBlankPreviousLines">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BaseInline">BaseInline</a>) SetBlankPreviousLines(v <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>SetBlankPreviousLines implements Node.SetBlankPreviousLines.

				
				
				
			
				
				<h3 id="BaseInline.SetLines">func (*BaseInline) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=880:928#L32">SetLines</a>
					<a class="permalink" href="#BaseInline.SetLines">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BaseInline">BaseInline</a>) SetLines(v *<a href="/pkg/github.com/yuin/goldmark/text/">textm</a>.<a href="/pkg/github.com/yuin/goldmark/text/#Segments">Segments</a>)</pre>
				<p>SetLines implements Node.SetLines.

				
				
				
			
				
				<h3 id="BaseInline.Type">func (*BaseInline) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=249:285#L7">Type</a>
					<a class="permalink" href="#BaseInline.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BaseInline">BaseInline</a>) Type() <a href="#NodeType">NodeType</a></pre>
				<p>Type implements Node.Type.

				
				
				
			
		
			
			
			<h2 id="BaseNode">type <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=4995:5144#L163">BaseNode</a>
				<a class="permalink" href="#BaseNode">&#xb6;</a>
				
				
			</h2>
			<p>A BaseNode struct implements the Node interface partialliy.

			<pre>type BaseNode struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="BaseNode.AppendChild">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=7955:7999#L300">AppendChild</a>
					<a class="permalink" href="#BaseNode.AppendChild">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) AppendChild(self, v <a href="#Node">Node</a>)</pre>
				<p>AppendChild implements Node.AppendChild .

				
				
				
			
				
				<h3 id="BaseNode.Attribute">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=10223:10284#L398">Attribute</a>
					<a class="permalink" href="#BaseNode.Attribute">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) Attribute(name []<a href="/pkg/builtin/#byte">byte</a>) (interface{}, <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>Attribute implements Node.Attribute.

				
				
				
			
				
				<h3 id="BaseNode.AttributeString">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=10522:10586#L411">AttributeString</a>
					<a class="permalink" href="#BaseNode.AttributeString">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) AttributeString(s <a href="/pkg/builtin/#string">string</a>) (interface{}, <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>AttributeString implements Node.AttributeString.

				
				
				
			
				
				<h3 id="BaseNode.Attributes">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=10685:10728#L416">Attributes</a>
					<a class="permalink" href="#BaseNode.Attributes">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) Attributes() []<a href="#Attribute">Attribute</a></pre>
				<p>Attributes implements Node.Attributes.

				
				
				
			
				
				<h3 id="BaseNode.ChildCount">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=7661:7696#L285">ChildCount</a>
					<a class="permalink" href="#BaseNode.ChildCount">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) ChildCount() <a href="/pkg/builtin/#int">int</a></pre>
				<p>ChildCount implements Node.ChildCount .

				
				
				
			
				
				<h3 id="BaseNode.FirstChild">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=7453:7489#L275">FirstChild</a>
					<a class="permalink" href="#BaseNode.FirstChild">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) FirstChild() <a href="#Node">Node</a></pre>
				<p>FirstChild implements Node.FirstChild .

				
				
				
			
				
				<h3 id="BaseNode.HasChildren">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=5281:5318#L180">HasChildren</a>
					<a class="permalink" href="#BaseNode.HasChildren">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) HasChildren() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>HasChildren implements Node.HasChildren .

				
				
				
			
				
				<h3 id="BaseNode.InsertAfter">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=8477:8532#L323">InsertAfter</a>
					<a class="permalink" href="#BaseNode.InsertAfter">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) InsertAfter(self, v1, insertee <a href="#Node">Node</a>)</pre>
				<p>InsertAfter implements Node.InsertAfter .

				
				
				
			
				
				<h3 id="BaseNode.InsertBefore">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=8635:8691#L328">InsertBefore</a>
					<a class="permalink" href="#BaseNode.InsertBefore">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) InsertBefore(self, v1, insertee <a href="#Node">Node</a>)</pre>
				<p>InsertBefore implements Node.InsertBefore .

				
				
				
			
				
				<h3 id="BaseNode.LastChild">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=7557:7592#L280">LastChild</a>
					<a class="permalink" href="#BaseNode.LastChild">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) LastChild() <a href="#Node">Node</a></pre>
				<p>LastChild implements Node.LastChild .

				
				
				
			
				
				<h3 id="BaseNode.NextSibling">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=5744:5781#L200">NextSibling</a>
					<a class="permalink" href="#BaseNode.NextSibling">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) NextSibling() <a href="#Node">Node</a></pre>
				<p>NextSibling implements Node.NextSibling .

				
				
				
			
				
				<h3 id="BaseNode.OwnerDocument">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=9172:9216#L352">OwnerDocument</a>
					<a class="permalink" href="#BaseNode.OwnerDocument">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) OwnerDocument() *<a href="#Document">Document</a></pre>
				<p>OwnerDocument implements Node.OwnerDocument.

				
				
				
			
				
				<h3 id="BaseNode.Parent">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=7758:7790#L290">Parent</a>
					<a class="permalink" href="#BaseNode.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) Parent() <a href="#Node">Node</a></pre>
				<p>Parent implements Node.Parent .

				
				
				
			
				
				<h3 id="BaseNode.PreviousSibling">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=5637:5678#L195">PreviousSibling</a>
					<a class="permalink" href="#BaseNode.PreviousSibling">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) PreviousSibling() <a href="#Node">Node</a></pre>
				<p>PreviousSibling implements Node.PreviousSibling .

				
				
				
			
				
				<h3 id="BaseNode.RemoveAttributes">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=10809:10846#L421">RemoveAttributes</a>
					<a class="permalink" href="#BaseNode.RemoveAttributes">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) RemoveAttributes()</pre>
				<p>RemoveAttributes implements Node.RemoveAttributes.

				
				
				
			
				
				<h3 id="BaseNode.RemoveChild">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=5847:5891#L205">RemoveChild</a>
					<a class="permalink" href="#BaseNode.RemoveChild">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) RemoveChild(self, v <a href="#Node">Node</a>)</pre>
				<p>RemoveChild implements Node.RemoveChild .

				
				
				
			
				
				<h3 id="BaseNode.RemoveChildren">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=6288:6332#L228">RemoveChildren</a>
					<a class="permalink" href="#BaseNode.RemoveChildren">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) RemoveChildren(self <a href="#Node">Node</a>)</pre>
				<p>RemoveChildren implements Node.RemoveChildren .

				
				
				
			
				
				<h3 id="BaseNode.ReplaceChild">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=8309:8365#L317">ReplaceChild</a>
					<a class="permalink" href="#BaseNode.ReplaceChild">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) ReplaceChild(self, v1, insertee <a href="#Node">Node</a>)</pre>
				<p>ReplaceChild implements Node.ReplaceChild .

				
				
				
			
				
				<h3 id="BaseNode.SetAttribute">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=9627:9690#L377">SetAttribute</a>
					<a class="permalink" href="#BaseNode.SetAttribute">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) SetAttribute(name []<a href="/pkg/builtin/#byte">byte</a>, value interface{})</pre>
				<p>SetAttribute implements Node.SetAttribute.

				
				
				
			
				
				<h3 id="BaseNode.SetAttributeString">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=10051:10120#L393">SetAttributeString</a>
					<a class="permalink" href="#BaseNode.SetAttributeString">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) SetAttributeString(name <a href="/pkg/builtin/#string">string</a>, value interface{})</pre>
				<p>SetAttributeString implements Node.SetAttributeString.

				
				
				
			
				
				<h3 id="BaseNode.SetNextSibling">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=5525:5566#L190">SetNextSibling</a>
					<a class="permalink" href="#BaseNode.SetNextSibling">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) SetNextSibling(v <a href="#Node">Node</a>)</pre>
				<p>SetNextSibling implements Node.SetNextSibling .

				
				
				
			
				
				<h3 id="BaseNode.SetParent">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=7854:7890#L295">SetParent</a>
					<a class="permalink" href="#BaseNode.SetParent">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) SetParent(v <a href="#Node">Node</a>)</pre>
				<p>SetParent implements Node.SetParent .

				
				
				
			
				
				<h3 id="BaseNode.SetPreviousSibling">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=5411:5456#L185">SetPreviousSibling</a>
					<a class="permalink" href="#BaseNode.SetPreviousSibling">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) SetPreviousSibling(v <a href="#Node">Node</a>)</pre>
				<p>SetPreviousSibling implements Node.SetPreviousSibling .

				
				
				
			
				
				<h3 id="BaseNode.SortChildren">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=6588:6653#L242">SortChildren</a>
					<a class="permalink" href="#BaseNode.SortChildren">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) SortChildren(comparator func(n1, n2 <a href="#Node">Node</a>) <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>SortChildren implements Node.SortChildren.

				
				
				
			
				
				<h3 id="BaseNode.Text">func (*BaseNode) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=9401:9446#L368">Text</a>
					<a class="permalink" href="#BaseNode.Text">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#BaseNode">BaseNode</a>) Text(source []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>Text implements Node.Text  .

				
				
				
			
		
			
			
			<h2 id="Blockquote">type <a href="/src/github.com/yuin/goldmark/ast/block.go?s=7045:7082#L306">Blockquote</a>
				<a class="permalink" href="#Blockquote">&#xb6;</a>
				
				
			</h2>
			<p>A Blockquote struct represents an blockquote block of Markdown text.

			<pre>type Blockquote struct {
    <a href="#BaseBlock">BaseBlock</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewBlockquote">func <a href="/src/github.com/yuin/goldmark/ast/block.go?s=7459:7491#L324">NewBlockquote</a>
					<a class="permalink" href="#NewBlockquote">&#xb6;</a>
					
					
				</h3>
				<pre>func NewBlockquote() *<a href="#Blockquote">Blockquote</a></pre>
				<p>NewBlockquote returns a new Blockquote node.

				
				
			

			
				
				<h3 id="Blockquote.Dump">func (*Blockquote) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=7115:7166#L311">Dump</a>
					<a class="permalink" href="#Blockquote.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Blockquote">Blockquote</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump .

				
				
				
			
				
				<h3 id="Blockquote.Kind">func (*Blockquote) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=7346:7382#L319">Kind</a>
					<a class="permalink" href="#Blockquote.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Blockquote">Blockquote</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
		
			
			
			<h2 id="CodeBlock">type <a href="/src/github.com/yuin/goldmark/ast/block.go?s=5043:5079#L220">CodeBlock</a>
				<a class="permalink" href="#CodeBlock">&#xb6;</a>
				
				
			</h2>
			<p>A CodeBlock interface represents an indented code block of Markdown text.

			<pre>type CodeBlock struct {
    <a href="#BaseBlock">BaseBlock</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewCodeBlock">func <a href="/src/github.com/yuin/goldmark/ast/block.go?s=5530:5560#L243">NewCodeBlock</a>
					<a class="permalink" href="#NewCodeBlock">&#xb6;</a>
					
					
				</h3>
				<pre>func NewCodeBlock() *<a href="#CodeBlock">CodeBlock</a></pre>
				<p>NewCodeBlock returns a new CodeBlock node.

				
				
			

			
				
				<h3 id="CodeBlock.Dump">func (*CodeBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=5195:5245#L230">Dump</a>
					<a class="permalink" href="#CodeBlock.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#CodeBlock">CodeBlock</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump .

				
				
				
			
				
				<h3 id="CodeBlock.IsRaw">func (*CodeBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=5113:5145#L225">IsRaw</a>
					<a class="permalink" href="#CodeBlock.IsRaw">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#CodeBlock">CodeBlock</a>) IsRaw() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsRaw implements Node.IsRaw.

				
				
				
			
				
				<h3 id="CodeBlock.Kind">func (*CodeBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=5421:5456#L238">Kind</a>
					<a class="permalink" href="#CodeBlock.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#CodeBlock">CodeBlock</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
		
			
			
			<h2 id="CodeSpan">type <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=6999:7035#L280">CodeSpan</a>
				<a class="permalink" href="#CodeSpan">&#xb6;</a>
				
				
			</h2>
			<p>A CodeSpan struct represents a code span of Markdown text.

			<pre>type CodeSpan struct {
    <a href="#BaseInline">BaseInline</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewCodeSpan">func <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=7752:7780#L313">NewCodeSpan</a>
					<a class="permalink" href="#NewCodeSpan">&#xb6;</a>
					
					
				</h3>
				<pre>func NewCodeSpan() *<a href="#CodeSpan">CodeSpan</a></pre>
				<p>NewCodeSpan returns a new CodeSpan node.

				
				
			

			
				
				<h3 id="CodeSpan.Dump">func (*CodeSpan) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=7426:7475#L300">Dump</a>
					<a class="permalink" href="#CodeSpan.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#CodeSpan">CodeSpan</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump.

				
				
				
			
				
				<h3 id="CodeSpan.Inline">func (*CodeSpan) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=7074:7101#L285">Inline</a>
					<a class="permalink" href="#CodeSpan.Inline">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#CodeSpan">CodeSpan</a>) Inline()</pre>
				<p>Inline implements Inline.Inline .

				
				
				
			
				
				<h3 id="CodeSpan.IsBlank">func (*CodeSpan) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=7181:7227#L289">IsBlank</a>
					<a class="permalink" href="#CodeSpan.IsBlank">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#CodeSpan">CodeSpan</a>) IsBlank(source []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsBlank returns true if this node consists of spaces, otherwise false.

				
				
				
			
				
				<h3 id="CodeSpan.Kind">func (*CodeSpan) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=7647:7681#L308">Kind</a>
					<a class="permalink" href="#CodeSpan.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#CodeSpan">CodeSpan</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
		
			
			
			<h2 id="Document">type <a href="/src/github.com/yuin/goldmark/ast/block.go?s=1021:1086#L41">Document</a>
				<a class="permalink" href="#Document">&#xb6;</a>
				
				
			</h2>
			<p>A Document struct is a root node of Markdown text.

			<pre>type Document struct {
    <a href="#BaseBlock">BaseBlock</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewDocument">func <a href="/src/github.com/yuin/goldmark/ast/block.go?s=2222:2250#L97">NewDocument</a>
					<a class="permalink" href="#NewDocument">&#xb6;</a>
					
					
				</h3>
				<pre>func NewDocument() *<a href="#Document">Document</a></pre>
				<p>NewDocument returns a new Document node.

				
				
			

			
				
				<h3 id="Document.AddMeta">func (*Document) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=2035:2092#L89">AddMeta</a>
					<a class="permalink" href="#Document.AddMeta">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Document">Document</a>) AddMeta(key <a href="/pkg/builtin/#string">string</a>, value interface{})</pre>
				<p>AddMeta adds given metadata to this document.

				
				
				
			
				
				<h3 id="Document.Dump">func (*Document) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=1215:1264#L51">Dump</a>
					<a class="permalink" href="#Document.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Document">Document</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump .

				
				
				
			
				
				<h3 id="Document.Kind">func (*Document) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=1432:1466#L61">Kind</a>
					<a class="permalink" href="#Document.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Document">Document</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
				
				<h3 id="Document.Meta">func (*Document) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=1644:1692#L71">Meta</a>
					<a class="permalink" href="#Document.Meta">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Document">Document</a>) Meta() map[<a href="/pkg/builtin/#string">string</a>]interface{}</pre>
				<p>Meta returns metadata of this document.

				
				
				
			
				
				<h3 id="Document.OwnerDocument">func (*Document) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=1541:1585#L66">OwnerDocument</a>
					<a class="permalink" href="#Document.OwnerDocument">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Document">Document</a>) OwnerDocument() *<a href="#Document">Document</a></pre>
				<p>OwnerDocument implements Node.OwnerDocument.

				
				
				
			
				
				<h3 id="Document.SetMeta">func (*Document) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=1821:1876#L79">SetMeta</a>
					<a class="permalink" href="#Document.SetMeta">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Document">Document</a>) SetMeta(meta map[<a href="/pkg/builtin/#string">string</a>]interface{})</pre>
				<p>SetMeta sets given metadata to this document.

				
				
				
			
				
				<h3 id="Document.Type">func (*Document) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=1341:1375#L56">Type</a>
					<a class="permalink" href="#Document.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Document">Document</a>) Type() <a href="#NodeType">NodeType</a></pre>
				<p>Type implements Node.Type .

				
				
				
			
		
			
			
			<h2 id="Emphasis">type <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=7899:7985#L320">Emphasis</a>
				<a class="permalink" href="#Emphasis">&#xb6;</a>
				
				
			</h2>
			<p>An Emphasis struct represents an emphasis of Markdown text.

			<pre>type Emphasis struct {
    <a href="#BaseInline">BaseInline</a>

<span id="Emphasis.Level"></span>    <span class="comment">// Level is a level of the emphasis.</span>
    Level <a href="/pkg/builtin/#int">int</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewEmphasis">func <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=8429:8466#L344">NewEmphasis</a>
					<a class="permalink" href="#NewEmphasis">&#xb6;</a>
					
					
				</h3>
				<pre>func NewEmphasis(level <a href="/pkg/builtin/#int">int</a>) *<a href="#Emphasis">Emphasis</a></pre>
				<p>NewEmphasis returns a new Emphasis node with the given level.

				
				
			

			
				
				<h3 id="Emphasis.Dump">func (*Emphasis) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=8017:8066#L328">Dump</a>
					<a class="permalink" href="#Emphasis.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Emphasis">Emphasis</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump.

				
				
				
			
				
				<h3 id="Emphasis.Kind">func (*Emphasis) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=8303:8337#L339">Kind</a>
					<a class="permalink" href="#Emphasis.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Emphasis">Emphasis</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
		
			
			
			<h2 id="FencedCodeBlock">type <a href="/src/github.com/yuin/goldmark/ast/block.go?s=5692:5820#L250">FencedCodeBlock</a>
				<a class="permalink" href="#FencedCodeBlock">&#xb6;</a>
				
				
			</h2>
			<p>A FencedCodeBlock struct represents a fenced code block of Markdown text.

			<pre>type FencedCodeBlock struct {
    <a href="#BaseBlock">BaseBlock</a>
<span id="FencedCodeBlock.Info"></span>    <span class="comment">// Info returns a info text of this fenced code block.</span>
    Info *<a href="#Text">Text</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewFencedCodeBlock">func <a href="/src/github.com/yuin/goldmark/ast/block.go?s=6841:6893#L298">NewFencedCodeBlock</a>
					<a class="permalink" href="#NewFencedCodeBlock">&#xb6;</a>
					
					
				</h3>
				<pre>func NewFencedCodeBlock(info *<a href="#Text">Text</a>) *<a href="#FencedCodeBlock">FencedCodeBlock</a></pre>
				<p>NewFencedCodeBlock return a new FencedCodeBlock node.

				
				
			

			
				
				<h3 id="FencedCodeBlock.Dump">func (*FencedCodeBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=6349:6405#L281">Dump</a>
					<a class="permalink" href="#FencedCodeBlock.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#FencedCodeBlock">FencedCodeBlock</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump .

				
				
				
			
				
				<h3 id="FencedCodeBlock.IsRaw">func (*FencedCodeBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=6261:6299#L276">IsRaw</a>
					<a class="permalink" href="#FencedCodeBlock.IsRaw">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#FencedCodeBlock">FencedCodeBlock</a>) IsRaw() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsRaw implements Node.IsRaw.

				
				
				
			
				
				<h3 id="FencedCodeBlock.Kind">func (*FencedCodeBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=6709:6750#L293">Kind</a>
					<a class="permalink" href="#FencedCodeBlock.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#FencedCodeBlock">FencedCodeBlock</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
				
				<h3 id="FencedCodeBlock.Language">func (*FencedCodeBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=5940:5996#L260">Language</a>
					<a class="permalink" href="#FencedCodeBlock.Language">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#FencedCodeBlock">FencedCodeBlock</a>) Language(source []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>Language returns an language in an info string.
Language returns nil if this node does not have an info string.

				
				
				
			
		
			
			
			<h2 id="HTMLBlock">type <a href="/src/github.com/yuin/goldmark/ast/block.go?s=10399:10587#L441">HTMLBlock</a>
				<a class="permalink" href="#HTMLBlock">&#xb6;</a>
				
				
			</h2>
			<p>An HTMLBlock struct represents an html block of Markdown text.

			<pre>type HTMLBlock struct {
    <a href="#BaseBlock">BaseBlock</a>

    <span class="comment">// Type is a type of this html block.</span>
<span id="HTMLBlock.HTMLBlockType"></span>    HTMLBlockType <a href="#HTMLBlockType">HTMLBlockType</a>

<span id="HTMLBlock.ClosureLine"></span>    <span class="comment">// ClosureLine is a line that closes this html block.</span>
    ClosureLine <a href="/pkg/github.com/yuin/goldmark/text/">textm</a>.<a href="/pkg/github.com/yuin/goldmark/text/#Segment">Segment</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewHTMLBlock">func <a href="/src/github.com/yuin/goldmark/ast/block.go?s=11690:11737#L492">NewHTMLBlock</a>
					<a class="permalink" href="#NewHTMLBlock">&#xb6;</a>
					
					
				</h3>
				<pre>func NewHTMLBlock(typ <a href="#HTMLBlockType">HTMLBlockType</a>) *<a href="#HTMLBlock">HTMLBlock</a></pre>
				<p>NewHTMLBlock returns a new HTMLBlock node.

				
				
			

			
				
				<h3 id="HTMLBlock.Dump">func (*HTMLBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=10864:10914#L463">Dump</a>
					<a class="permalink" href="#HTMLBlock.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#HTMLBlock">HTMLBlock</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump.

				
				
				
			
				
				<h3 id="HTMLBlock.HasClosure">func (*HTMLBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=10758:10795#L458">HasClosure</a>
					<a class="permalink" href="#HTMLBlock.HasClosure">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#HTMLBlock">HTMLBlock</a>) HasClosure() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>HasClosure returns true if this html block has a closure line,
otherwise false.

				
				
				
			
				
				<h3 id="HTMLBlock.IsRaw">func (*HTMLBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=10621:10653#L452">IsRaw</a>
					<a class="permalink" href="#HTMLBlock.IsRaw">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#HTMLBlock">HTMLBlock</a>) IsRaw() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsRaw implements Node.IsRaw.

				
				
				
			
				
				<h3 id="HTMLBlock.Kind">func (*HTMLBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=11581:11616#L487">Kind</a>
					<a class="permalink" href="#HTMLBlock.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#HTMLBlock">HTMLBlock</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
		
			
			
			<h2 id="HTMLBlockType">type <a href="/src/github.com/yuin/goldmark/ast/block.go?s=9811:9833#L421">HTMLBlockType</a>
				<a class="permalink" href="#HTMLBlockType">&#xb6;</a>
				
				
			</h2>
			<p>HTMLBlockType represents kinds of an html blocks.
See <a href="https://spec.commonmark.org/0.30/#html-blocks">https://spec.commonmark.org/0.30/#html-blocks</a>

			<pre>type HTMLBlockType <a href="/pkg/builtin/#int">int</a></pre>

			
				
				<pre>const (
    <span class="comment">// HTMLBlockType1 represents type 1 html blocks.</span>
    <span id="HTMLBlockType1">HTMLBlockType1</span> <a href="#HTMLBlockType">HTMLBlockType</a> = <a href="/pkg/builtin/#iota">iota</a> + 1
    <span class="comment">// HTMLBlockType2 represents type 2 html blocks.</span>
    <span id="HTMLBlockType2">HTMLBlockType2</span>
    <span class="comment">// HTMLBlockType3 represents type 3 html blocks.</span>
    <span id="HTMLBlockType3">HTMLBlockType3</span>
    <span class="comment">// HTMLBlockType4 represents type 4 html blocks.</span>
    <span id="HTMLBlockType4">HTMLBlockType4</span>
    <span class="comment">// HTMLBlockType5 represents type 5 html blocks.</span>
    <span id="HTMLBlockType5">HTMLBlockType5</span>
    <span class="comment">// HTMLBlockType6 represents type 6 html blocks.</span>
    <span id="HTMLBlockType6">HTMLBlockType6</span>
    <span class="comment">// HTMLBlockType7 represents type 7 html blocks.</span>
    <span id="HTMLBlockType7">HTMLBlockType7</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="Heading">type <a href="/src/github.com/yuin/goldmark/ast/block.go?s=3707:3830#L163">Heading</a>
				<a class="permalink" href="#Heading">&#xb6;</a>
				
				
			</h2>
			<p>A Heading struct represents headings like SetextHeading and ATXHeading.

			<pre>type Heading struct {
    <a href="#BaseBlock">BaseBlock</a>
<span id="Heading.Level"></span>    <span class="comment">// Level returns a level of this heading.</span>
    <span class="comment">// This value is between 1 and 6.</span>
    Level <a href="/pkg/builtin/#int">int</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewHeading">func <a href="/src/github.com/yuin/goldmark/ast/block.go?s=4245:4280#L187">NewHeading</a>
					<a class="permalink" href="#NewHeading">&#xb6;</a>
					
					
				</h3>
				<pre>func NewHeading(level <a href="/pkg/builtin/#int">int</a>) *<a href="#Heading">Heading</a></pre>
				<p>NewHeading returns a new Heading node.

				
				
			

			
				
				<h3 id="Heading.Dump">func (*Heading) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=3863:3911#L171">Dump</a>
					<a class="permalink" href="#Heading.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Heading">Heading</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump .

				
				
				
			
				
				<h3 id="Heading.Kind">func (*Heading) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=4144:4177#L182">Kind</a>
					<a class="permalink" href="#Heading.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Heading">Heading</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
		
			
			
			<h2 id="Image">type <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=9447:9478#L397">Image</a>
				<a class="permalink" href="#Image">&#xb6;</a>
				
				
			</h2>
			<p>An Image struct represents an image of the Markdown text.

			<pre>type Image struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewImage">func <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=9905:9937#L418">NewImage</a>
					<a class="permalink" href="#NewImage">&#xb6;</a>
					
					
				</h3>
				<pre>func NewImage(link *<a href="#Link">Link</a>) *<a href="#Image">Image</a></pre>
				<p>NewImage returns a new Image node.

				
				
			

			
				
				<h3 id="Image.Dump">func (*Image) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=9510:9556#L402">Dump</a>
					<a class="permalink" href="#Image.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Image">Image</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump.

				
				
				
			
				
				<h3 id="Image.Inline">func (*Image) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=8740:8767#L362">Inline</a>
					<a class="permalink" href="#Image.Inline">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Image">Image</a>) Inline()</pre>
				<p>Inline implements Inline.Inline.

				
				
				
			
				
				<h3 id="Image.Kind">func (*Image) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=9812:9843#L413">Kind</a>
					<a class="permalink" href="#Image.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Image">Image</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
		
			
			
			<h2 id="Link">type <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=8830:8860#L366">Link</a>
				<a class="permalink" href="#Link">&#xb6;</a>
				
				
			</h2>
			<p>A Link struct represents a link of the Markdown text.

			<pre>type Link struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewLink">func <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=9278:9298#L387">NewLink</a>
					<a class="permalink" href="#NewLink">&#xb6;</a>
					
					
				</h3>
				<pre>func NewLink() *<a href="#Link">Link</a></pre>
				<p>NewLink returns a new Link node.

				
				
			

			
				
				<h3 id="Link.Dump">func (*Link) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=8892:8937#L371">Dump</a>
					<a class="permalink" href="#Link.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Link">Link</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump.

				
				
				
			
				
				<h3 id="Link.Inline">func (*Link) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=8740:8767#L362">Inline</a>
					<a class="permalink" href="#Link.Inline">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Link">Link</a>) Inline()</pre>
				<p>Inline implements Inline.Inline.

				
				
				
			
				
				<h3 id="Link.Kind">func (*Link) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=9189:9219#L382">Kind</a>
					<a class="permalink" href="#Link.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Link">Link</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
		
			
			
			<h2 id="List">type <a href="/src/github.com/yuin/goldmark/ast/block.go?s=7600:7954#L331">List</a>
				<a class="permalink" href="#List">&#xb6;</a>
				
				
			</h2>
			<p>A List struct represents a list of Markdown text.

			<pre>type List struct {
    <a href="#BaseBlock">BaseBlock</a>

<span id="List.Marker"></span>    <span class="comment">// Marker is a marker character like &#39;-&#39;, &#39;+&#39;, &#39;)&#39; and &#39;.&#39;.</span>
    Marker <a href="/pkg/builtin/#byte">byte</a>

<span id="List.IsTight"></span>    <span class="comment">// IsTight is a true if this list is a &#39;tight&#39; list.</span>
    <span class="comment">// See https://spec.commonmark.org/0.30/#loose for details.</span>
    IsTight <a href="/pkg/builtin/#bool">bool</a>

<span id="List.Start"></span>    <span class="comment">// Start is an initial number of this ordered list.</span>
    <span class="comment">// If this list is not an ordered list, Start is 0.</span>
    Start <a href="/pkg/builtin/#int">int</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewList">func <a href="/src/github.com/yuin/goldmark/ast/block.go?s=8889:8920#L379">NewList</a>
					<a class="permalink" href="#NewList">&#xb6;</a>
					
					
				</h3>
				<pre>func NewList(marker <a href="/pkg/builtin/#byte">byte</a>) *<a href="#List">List</a></pre>
				<p>NewList returns a new List node.

				
				
			

			
				
				<h3 id="List.CanContinue">func (*List) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=8223:8283#L353">CanContinue</a>
					<a class="permalink" href="#List.CanContinue">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#List">List</a>) CanContinue(marker <a href="/pkg/builtin/#byte">byte</a>, isOrdered <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>CanContinue returns true if this list can continue with
the given mark and a list type, otherwise false.

				
				
				
			
				
				<h3 id="List.Dump">func (*List) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=8376:8421#L358">Dump</a>
					<a class="permalink" href="#List.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#List">List</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump.

				
				
				
			
				
				<h3 id="List.IsOrdered">func (*List) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=8032:8063#L347">IsOrdered</a>
					<a class="permalink" href="#List.IsOrdered">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#List">List</a>) IsOrdered() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsOrdered returns true if this list is an ordered list, otherwise false.

				
				
				
			
				
				<h3 id="List.Kind">func (*List) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=8800:8830#L374">Kind</a>
					<a class="permalink" href="#List.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#List">List</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
		
			
			
			<h2 id="ListItem">type <a href="/src/github.com/yuin/goldmark/ast/block.go?s=9072:9167#L388">ListItem</a>
				<a class="permalink" href="#ListItem">&#xb6;</a>
				
				
			</h2>
			<p>A ListItem struct represents a list item of Markdown text.

			<pre>type ListItem struct {
    <a href="#BaseBlock">BaseBlock</a>

<span id="ListItem.Offset"></span>    <span class="comment">// Offset is an offset position of this item.</span>
    Offset <a href="/pkg/builtin/#int">int</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewListItem">func <a href="/src/github.com/yuin/goldmark/ast/block.go?s=9592:9630#L412">NewListItem</a>
					<a class="permalink" href="#NewListItem">&#xb6;</a>
					
					
				</h3>
				<pre>func NewListItem(offset <a href="/pkg/builtin/#int">int</a>) *<a href="#ListItem">ListItem</a></pre>
				<p>NewListItem returns a new ListItem node.

				
				
			

			
				
				<h3 id="ListItem.Dump">func (*ListItem) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=9199:9248#L396">Dump</a>
					<a class="permalink" href="#ListItem.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#ListItem">ListItem</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump.

				
				
				
			
				
				<h3 id="ListItem.Kind">func (*ListItem) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=9487:9521#L407">Kind</a>
					<a class="permalink" href="#ListItem.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#ListItem">ListItem</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
		
			
			
			<h2 id="Node">type <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=1020:4930#L39">Node</a>
				<a class="permalink" href="#Node">&#xb6;</a>
				
				
			</h2>
			<p>A Node interface defines basic AST node functionalities.

			<pre>type Node interface {
    <span class="comment">// Type returns a type of this node.</span>
    Type() <a href="#NodeType">NodeType</a>

    <span class="comment">// Kind returns a kind of this node.</span>
    Kind() <a href="#NodeKind">NodeKind</a>

    <span class="comment">// NextSibling returns a next sibling node of this node.</span>
    NextSibling() <a href="#Node">Node</a>

    <span class="comment">// PreviousSibling returns a previous sibling node of this node.</span>
    PreviousSibling() <a href="#Node">Node</a>

    <span class="comment">// Parent returns a parent node of this node.</span>
    Parent() <a href="#Node">Node</a>

    <span class="comment">// SetParent sets a parent node to this node.</span>
    SetParent(<a href="#Node">Node</a>)

    <span class="comment">// SetPreviousSibling sets a previous sibling node to this node.</span>
    SetPreviousSibling(<a href="#Node">Node</a>)

    <span class="comment">// SetNextSibling sets a next sibling node to this node.</span>
    SetNextSibling(<a href="#Node">Node</a>)

    <span class="comment">// HasChildren returns true if this node has any children, otherwise false.</span>
    HasChildren() <a href="/pkg/builtin/#bool">bool</a>

    <span class="comment">// ChildCount returns a total number of children.</span>
    ChildCount() <a href="/pkg/builtin/#int">int</a>

    <span class="comment">// FirstChild returns a first child of this node.</span>
    FirstChild() <a href="#Node">Node</a>

    <span class="comment">// LastChild returns a last child of this node.</span>
    LastChild() <a href="#Node">Node</a>

    <span class="comment">// AppendChild append a node child to the tail of the children.</span>
    AppendChild(self, child <a href="#Node">Node</a>)

    <span class="comment">// RemoveChild removes a node child from this node.</span>
    <span class="comment">// If a node child is not children of this node, RemoveChild nothing to do.</span>
    RemoveChild(self, child <a href="#Node">Node</a>)

    <span class="comment">// RemoveChildren removes all children from this node.</span>
    RemoveChildren(self <a href="#Node">Node</a>)

    <span class="comment">// SortChildren sorts childrens by comparator.</span>
    SortChildren(comparator func(n1, n2 <a href="#Node">Node</a>) <a href="/pkg/builtin/#int">int</a>)

    <span class="comment">// ReplaceChild replace a node v1 with a node insertee.</span>
    <span class="comment">// If v1 is not children of this node, ReplaceChild append a insetee to the</span>
    <span class="comment">// tail of the children.</span>
    ReplaceChild(self, v1, insertee <a href="#Node">Node</a>)

    <span class="comment">// InsertBefore inserts a node insertee before a node v1.</span>
    <span class="comment">// If v1 is not children of this node, InsertBefore append a insetee to the</span>
    <span class="comment">// tail of the children.</span>
    InsertBefore(self, v1, insertee <a href="#Node">Node</a>)

    <span class="comment">// InsertAfterinserts a node insertee after a node v1.</span>
    <span class="comment">// If v1 is not children of this node, InsertBefore append a insetee to the</span>
    <span class="comment">// tail of the children.</span>
    InsertAfter(self, v1, insertee <a href="#Node">Node</a>)

    <span class="comment">// OwnerDocument returns this node&#39;s owner document.</span>
    <span class="comment">// If this node is not a child of the Document node, OwnerDocument</span>
    <span class="comment">// returns nil.</span>
    OwnerDocument() *<a href="#Document">Document</a>

    <span class="comment">// Dump dumps an AST tree structure to stdout.</span>
    <span class="comment">// This function completely aimed for debugging.</span>
    <span class="comment">// level is a indent level. Implementer should indent informations with</span>
    <span class="comment">// 2 * level spaces.</span>
    Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)

    <span class="comment">// Text returns text values of this node.</span>
    Text(source []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a>

    <span class="comment">// HasBlankPreviousLines returns true if the row before this node is blank,</span>
    <span class="comment">// otherwise false.</span>
    <span class="comment">// This method is valid only for block nodes.</span>
    HasBlankPreviousLines() <a href="/pkg/builtin/#bool">bool</a>

    <span class="comment">// SetBlankPreviousLines sets whether the row before this node is blank.</span>
    <span class="comment">// This method is valid only for block nodes.</span>
    SetBlankPreviousLines(v <a href="/pkg/builtin/#bool">bool</a>)

    <span class="comment">// Lines returns text segments that hold positions in a source.</span>
    <span class="comment">// This method is valid only for block nodes.</span>
    Lines() *<a href="/pkg/github.com/yuin/goldmark/text/">textm</a>.<a href="/pkg/github.com/yuin/goldmark/text/#Segments">Segments</a>

    <span class="comment">// SetLines sets text segments that hold positions in a source.</span>
    <span class="comment">// This method is valid only for block nodes.</span>
    SetLines(*<a href="/pkg/github.com/yuin/goldmark/text/">textm</a>.<a href="/pkg/github.com/yuin/goldmark/text/#Segments">Segments</a>)

    <span class="comment">// IsRaw returns true if contents should be rendered as &#39;raw&#39; contents.</span>
    IsRaw() <a href="/pkg/builtin/#bool">bool</a>

    <span class="comment">// SetAttribute sets the given value to the attributes.</span>
    SetAttribute(name []<a href="/pkg/builtin/#byte">byte</a>, value interface{})

    <span class="comment">// SetAttributeString sets the given value to the attributes.</span>
    SetAttributeString(name <a href="/pkg/builtin/#string">string</a>, value interface{})

    <span class="comment">// Attribute returns a (attribute value, true) if an attribute</span>
    <span class="comment">// associated with the given name is found, otherwise</span>
    <span class="comment">// (nil, false)</span>
    Attribute(name []<a href="/pkg/builtin/#byte">byte</a>) (interface{}, <a href="/pkg/builtin/#bool">bool</a>)

    <span class="comment">// AttributeString returns a (attribute value, true) if an attribute</span>
    <span class="comment">// associated with the given name is found, otherwise</span>
    <span class="comment">// (nil, false)</span>
    AttributeString(name <a href="/pkg/builtin/#string">string</a>) (interface{}, <a href="/pkg/builtin/#bool">bool</a>)

    <span class="comment">// Attributes returns a list of attributes.</span>
    <span class="comment">// This may be a nil if there are no attributes.</span>
    Attributes() []<a href="#Attribute">Attribute</a>

    <span class="comment">// RemoveAttributes removes all attributes from this node.</span>
    RemoveAttributes()
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="NodeKind">type <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=576:593#L16">NodeKind</a>
				<a class="permalink" href="#NodeKind">&#xb6;</a>
				
				
			</h2>
			<p>NodeKind indicates more specific type than NodeType.

			<pre>type NodeKind <a href="/pkg/builtin/#int">int</a></pre>

			

			

			
			
			

			
				
				<h3 id="NewNodeKind">func <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=747:785#L26">NewNodeKind</a>
					<a class="permalink" href="#NewNodeKind">&#xb6;</a>
					
					
				</h3>
				<pre>func NewNodeKind(name <a href="/pkg/builtin/#string">string</a>) <a href="#NodeKind">NodeKind</a></pre>
				<p>NewNodeKind returns a new Kind value.

				
				
			

			
				
				<h3 id="NodeKind.String">func (NodeKind) <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=595:628#L18">String</a>
					<a class="permalink" href="#NodeKind.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (k <a href="#NodeKind">NodeKind</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="NodeType">type <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=245:262#L4">NodeType</a>
				<a class="permalink" href="#NodeType">&#xb6;</a>
				
				
			</h2>
			<p>A NodeType indicates what type a node belongs to.

			<pre>type NodeType <a href="/pkg/builtin/#int">int</a></pre>

			
				
				<pre>const (
    <span class="comment">// TypeBlock indicates that a node is kind of block nodes.</span>
    <span id="TypeBlock">TypeBlock</span> <a href="#NodeType">NodeType</a> = <a href="/pkg/builtin/#iota">iota</a> + 1
    <span class="comment">// TypeInline indicates that a node is kind of inline nodes.</span>
    <span id="TypeInline">TypeInline</span>
    <span class="comment">// TypeDocument indicates that a node is kind of document nodes.</span>
    <span id="TypeDocument">TypeDocument</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="Paragraph">type <a href="/src/github.com/yuin/goldmark/ast/block.go?s=2964:3000#L131">Paragraph</a>
				<a class="permalink" href="#Paragraph">&#xb6;</a>
				
				
			</h2>
			<p>A Paragraph struct represents a paragraph of Markdown text.

			<pre>type Paragraph struct {
    <a href="#BaseBlock">BaseBlock</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewParagraph">func <a href="/src/github.com/yuin/goldmark/ast/block.go?s=3368:3398#L149">NewParagraph</a>
					<a class="permalink" href="#NewParagraph">&#xb6;</a>
					
					
				</h3>
				<pre>func NewParagraph() *<a href="#Paragraph">Paragraph</a></pre>
				<p>NewParagraph returns a new Paragraph node.

				
				
			

			
				
				<h3 id="Paragraph.Dump">func (*Paragraph) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=3033:3083#L136">Dump</a>
					<a class="permalink" href="#Paragraph.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Paragraph">Paragraph</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump .

				
				
				
			
				
				<h3 id="Paragraph.Kind">func (*Paragraph) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=3259:3294#L144">Kind</a>
					<a class="permalink" href="#Paragraph.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Paragraph">Paragraph</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
		
			
			
			<h2 id="RawHTML">type <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=11935:11996#L506">RawHTML</a>
				<a class="permalink" href="#RawHTML">&#xb6;</a>
				
				
			</h2>
			<p>A RawHTML struct represents an inline raw HTML of the Markdown text.

			<pre>type RawHTML struct {
    <a href="#BaseInline">BaseInline</a>
<span id="RawHTML.Segments"></span>    Segments *<a href="/pkg/github.com/yuin/goldmark/text/">textm</a>.<a href="/pkg/github.com/yuin/goldmark/text/#Segments">Segments</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewRawHTML">func <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=12610:12636#L535">NewRawHTML</a>
					<a class="permalink" href="#NewRawHTML">&#xb6;</a>
					
					
				</h3>
				<pre>func NewRawHTML() *<a href="#RawHTML">RawHTML</a></pre>
				<p>NewRawHTML returns a new RawHTML node.

				
				
			

			
				
				<h3 id="RawHTML.Dump">func (*RawHTML) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=12095:12143#L515">Dump</a>
					<a class="permalink" href="#RawHTML.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#RawHTML">RawHTML</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump.

				
				
				
			
				
				<h3 id="RawHTML.Inline">func (*RawHTML) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=12034:12060#L512">Inline</a>
					<a class="permalink" href="#RawHTML.Inline">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#RawHTML">RawHTML</a>) Inline()</pre>
				<p>Inline implements Inline.Inline.

				
				
				
			
				
				<h3 id="RawHTML.Kind">func (*RawHTML) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=12509:12542#L530">Kind</a>
					<a class="permalink" href="#RawHTML.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#RawHTML">RawHTML</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
		
			
			
			<h2 id="String">type <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=5446:5508#L209">String</a>
				<a class="permalink" href="#String">&#xb6;</a>
				
				
			</h2>
			<p>A String struct is a textual content that has a concrete value.

			<pre>type String struct {
    <a href="#BaseInline">BaseInline</a>

<span id="String.Value"></span>    Value []<a href="/pkg/builtin/#byte">byte</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewString">func <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=6867:6899#L273">NewString</a>
					<a class="permalink" href="#NewString">&#xb6;</a>
					
					
				</h3>
				<pre>func NewString(v []<a href="/pkg/builtin/#byte">byte</a>) *<a href="#String">String</a></pre>
				<p>NewString returns a new String node.

				
				
			

			
				
				<h3 id="String.Dump">func (*String) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=6410:6457#L256">Dump</a>
					<a class="permalink" href="#String.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#String">String</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump.

				
				
				
			
				
				<h3 id="String.Inline">func (*String) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=5546:5571#L217">Inline</a>
					<a class="permalink" href="#String.Inline">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#String">String</a>) Inline()</pre>
				<p>Inline implements Inline.Inline.

				
				
				
			
				
				<h3 id="String.IsCode">func (*String) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=6026:6056#L237">IsCode</a>
					<a class="permalink" href="#String.IsCode">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#String">String</a>) IsCode() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsCode returns true if this text should be rendered without any
modifications.

				
				
				
			
				
				<h3 id="String.IsRaw">func (*String) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=5698:5727#L222">IsRaw</a>
					<a class="permalink" href="#String.IsRaw">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#String">String</a>) IsRaw() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsRaw returns true if this text should be rendered without unescaping
back slash escapes and resolving references.

				
				
				
			
				
				<h3 id="String.Kind">func (*String) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=6770:6802#L268">Kind</a>
					<a class="permalink" href="#String.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#String">String</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
				
				<h3 id="String.SetCode">func (*String) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=6172:6204#L242">SetCode</a>
					<a class="permalink" href="#String.SetCode">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#String">String</a>) SetCode(v <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>SetCode sets whether this text should be rendered without any modifications.

				
				
				
			
				
				<h3 id="String.SetRaw">func (*String) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=5831:5862#L227">SetRaw</a>
					<a class="permalink" href="#String.SetRaw">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#String">String</a>) SetRaw(v <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>SetRaw sets whether this text should be rendered as raw contents.

				
				
				
			
				
				<h3 id="String.Text">func (*String) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=6315:6358#L251">Text</a>
					<a class="permalink" href="#String.Text">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#String">String</a>) Text(source []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>Text implements Node.Text.

				
				
				
			
		
			
			
			<h2 id="Text">type <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=1044:1157#L37">Text</a>
				<a class="permalink" href="#Text">&#xb6;</a>
				
				
			</h2>
			<p>A Text struct represents a textual content of the Markdown text.

			<pre>type Text struct {
    <a href="#BaseInline">BaseInline</a>
<span id="Text.Segment"></span>    <span class="comment">// Segment is a position in a source text.</span>
    Segment <a href="/pkg/github.com/yuin/goldmark/text/">textm</a>.<a href="/pkg/github.com/yuin/goldmark/text/#Segment">Segment</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewRawTextSegment">func <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=4288:4333#L174">NewRawTextSegment</a>
					<a class="permalink" href="#NewRawTextSegment">&#xb6;</a>
					
					
				</h3>
				<pre>func NewRawTextSegment(v <a href="/pkg/github.com/yuin/goldmark/text/">textm</a>.<a href="/pkg/github.com/yuin/goldmark/text/#Segment">Segment</a>) *<a href="#Text">Text</a></pre>
				<p>NewRawTextSegment returns a new Text node with the given source position.
The new node should be rendered as raw contents.

				
				
			
				
				<h3 id="NewText">func <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=3902:3922#L158">NewText</a>
					<a class="permalink" href="#NewText">&#xb6;</a>
					
					
				</h3>
				<pre>func NewText() *<a href="#Text">Text</a></pre>
				<p>NewText returns a new Text node.

				
				
			
				
				<h3 id="NewTextSegment">func <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=4048:4090#L165">NewTextSegment</a>
					<a class="permalink" href="#NewTextSegment">&#xb6;</a>
					
					
				</h3>
				<pre>func NewTextSegment(v <a href="/pkg/github.com/yuin/goldmark/text/">textm</a>.<a href="/pkg/github.com/yuin/goldmark/text/#Segment">Segment</a>) *<a href="#Text">Text</a></pre>
				<p>NewTextSegment returns a new Text node with the given source position.

				
				
			

			
				
				<h3 id="Text.Dump">func (*Text) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=3458:3503#L141">Dump</a>
					<a class="permalink" href="#Text.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Text">Text</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump.

				
				
				
			
				
				<h3 id="Text.HardLineBreak">func (*Text) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=2534:2569#L105">HardLineBreak</a>
					<a class="permalink" href="#Text.HardLineBreak">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Text">Text</a>) HardLineBreak() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>HardLineBreak returns true if this node ends with a hard line break.
See <a href="https://spec.commonmark.org/0.30/#hard-line-breaks">https://spec.commonmark.org/0.30/#hard-line-breaks</a> for details.

				
				
				
			
				
				<h3 id="Text.Inline">func (*Text) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=1634:1657#L70">Inline</a>
					<a class="permalink" href="#Text.Inline">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Text">Text</a>) Inline()</pre>
				<p>Inline implements Inline.Inline.

				
				
				
			
				
				<h3 id="Text.IsRaw">func (*Text) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=2152:2179#L90">IsRaw</a>
					<a class="permalink" href="#Text.IsRaw">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Text">Text</a>) IsRaw() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsRaw returns true if this text should be rendered without unescaping
back slash escapes and resolving references.

				
				
				
			
				
				<h3 id="Text.Kind">func (*Text) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=3813:3843#L153">Kind</a>
					<a class="permalink" href="#Text.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Text">Text</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
				
				<h3 id="Text.Merge">func (*Text) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=2939:2990#L120">Merge</a>
					<a class="permalink" href="#Text.Merge">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Text">Text</a>) Merge(node <a href="#Node">Node</a>, source []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Merge merges a Node n into this node.
Merge returns true if the given node has been merged, otherwise false.

				
				
				
			
				
				<h3 id="Text.SetHardLineBreak">func (*Text) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=2686:2725#L110">SetHardLineBreak</a>
					<a class="permalink" href="#Text.SetHardLineBreak">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Text">Text</a>) SetHardLineBreak(v <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>SetHardLineBreak sets whether this node ends with a hard line break.

				
				
				
			
				
				<h3 id="Text.SetRaw">func (*Text) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=2283:2312#L95">SetRaw</a>
					<a class="permalink" href="#Text.SetRaw">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Text">Text</a>) SetRaw(v <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>SetRaw sets whether this text should be rendered as raw contents.

				
				
				
			
				
				<h3 id="Text.SetSoftLineBreak">func (*Text) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=1893:1932#L80">SetSoftLineBreak</a>
					<a class="permalink" href="#Text.SetSoftLineBreak">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Text">Text</a>) SetSoftLineBreak(v <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>SetSoftLineBreak sets whether this node ends with a new line.

				
				
				
			
				
				<h3 id="Text.SoftLineBreak">func (*Text) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=1748:1783#L75">SoftLineBreak</a>
					<a class="permalink" href="#Text.SoftLineBreak">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Text">Text</a>) SoftLineBreak() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>SoftLineBreak returns true if this node ends with a new line,
otherwise false.

				
				
				
			
				
				<h3 id="Text.Text">func (*Text) <a href="/src/github.com/yuin/goldmark/ast/inline.go?s=3349:3390#L136">Text</a>
					<a class="permalink" href="#Text.Text">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#Text">Text</a>) Text(source []<a href="/pkg/builtin/#byte">byte</a>) []<a href="/pkg/builtin/#byte">byte</a></pre>
				<p>Text implements Node.Text.

				
				
				
			
		
			
			
			<h2 id="TextBlock">type <a href="/src/github.com/yuin/goldmark/ast/block.go?s=2412:2448#L106">TextBlock</a>
				<a class="permalink" href="#TextBlock">&#xb6;</a>
				
				
			</h2>
			<p>A TextBlock struct is a node whose lines
should be rendered without any containers.

			<pre>type TextBlock struct {
    <a href="#BaseBlock">BaseBlock</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewTextBlock">func <a href="/src/github.com/yuin/goldmark/ast/block.go?s=2816:2846#L124">NewTextBlock</a>
					<a class="permalink" href="#NewTextBlock">&#xb6;</a>
					
					
				</h3>
				<pre>func NewTextBlock() *<a href="#TextBlock">TextBlock</a></pre>
				<p>NewTextBlock returns a new TextBlock node.

				
				
			

			
				
				<h3 id="TextBlock.Dump">func (*TextBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=2481:2531#L111">Dump</a>
					<a class="permalink" href="#TextBlock.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#TextBlock">TextBlock</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump .

				
				
				
			
				
				<h3 id="TextBlock.Kind">func (*TextBlock) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=2707:2742#L119">Kind</a>
					<a class="permalink" href="#TextBlock.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#TextBlock">TextBlock</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
		
			
			
			<h2 id="ThematicBreak">type <a href="/src/github.com/yuin/goldmark/ast/block.go?s=4425:4465#L195">ThematicBreak</a>
				<a class="permalink" href="#ThematicBreak">&#xb6;</a>
				
				
			</h2>
			<p>A ThematicBreak struct represents a thematic break of Markdown text.

			<pre>type ThematicBreak struct {
    <a href="#BaseBlock">BaseBlock</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewThematicBreak">func <a href="/src/github.com/yuin/goldmark/ast/block.go?s=4869:4907#L213">NewThematicBreak</a>
					<a class="permalink" href="#NewThematicBreak">&#xb6;</a>
					
					
				</h3>
				<pre>func NewThematicBreak() *<a href="#ThematicBreak">ThematicBreak</a></pre>
				<p>NewThematicBreak returns a new ThematicBreak node.

				
				
			

			
				
				<h3 id="ThematicBreak.Dump">func (*ThematicBreak) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=4498:4552#L200">Dump</a>
					<a class="permalink" href="#ThematicBreak.Dump">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#ThematicBreak">ThematicBreak</a>) Dump(source []<a href="/pkg/builtin/#byte">byte</a>, level <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Dump implements Node.Dump .

				
				
				
			
				
				<h3 id="ThematicBreak.Kind">func (*ThematicBreak) <a href="/src/github.com/yuin/goldmark/ast/block.go?s=4744:4783#L208">Kind</a>
					<a class="permalink" href="#ThematicBreak.Kind">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#ThematicBreak">ThematicBreak</a>) Kind() <a href="#NodeKind">NodeKind</a></pre>
				<p>Kind implements Node.Kind.

				
				
				
			
		
			
			
			<h2 id="WalkStatus">type <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=11877:11896#L455">WalkStatus</a>
				<a class="permalink" href="#WalkStatus">&#xb6;</a>
				
				
			</h2>
			<p>WalkStatus represents a current status of the Walk function.

			<pre>type WalkStatus <a href="/pkg/builtin/#int">int</a></pre>

			
				
				<pre>const (
    <span class="comment">// WalkStop indicates no more walking needed.</span>
    <span id="WalkStop">WalkStop</span> <a href="#WalkStatus">WalkStatus</a> = <a href="/pkg/builtin/#iota">iota</a> + 1

    <span class="comment">// WalkSkipChildren indicates that Walk wont walk on children of current</span>
    <span class="comment">// node.</span>
    <span id="WalkSkipChildren">WalkSkipChildren</span>

    <span class="comment">// WalkContinue indicates that Walk can continue to walk.</span>
    <span id="WalkContinue">WalkContinue</span>
)</pre>
			

			

			
			
			

			

			
		
			
			
			<h2 id="Walker">type <a href="/src/github.com/yuin/goldmark/ast/ast.go?s=12383:12442#L473">Walker</a>
				<a class="permalink" href="#Walker">&#xb6;</a>
				
				
			</h2>
			<p>Walker is a function that will be called when Walk find a
new node.
entering is set true before walks children, false after walked children.
If Walker returns error, Walk function immediately stop walking.

			<pre>type Walker func(n <a href="#Node">Node</a>, entering <a href="/pkg/builtin/#bool">bool</a>) (<a href="#WalkStatus">WalkStatus</a>, <a href="/pkg/builtin/#error">error</a>)</pre>

			

			

			
			
			

			

			
		
	

	







<div id="footer">
Build version go1.23.0.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
