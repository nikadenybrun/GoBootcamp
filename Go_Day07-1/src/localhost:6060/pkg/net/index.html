<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>net - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.23.0";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package net
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "net"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package net provides a portable interface for network I/O, including
TCP/IP, UDP, domain name resolution, and Unix domain sockets.
<p>Although the package provides access to low-level networking
primitives, most clients will need only the basic interface provided
by the <a href="#Dial">Dial</a>, <a href="#Listen">Listen</a>, and Accept functions and the associated
<a href="#Conn">Conn</a> and <a href="#Listener">Listener</a> interfaces. The crypto/tls package uses
the same interfaces and similar Dial and Listen functions.
<p>The Dial function connects to a server:
<pre>conn, err := net.Dial(&quot;tcp&quot;, &quot;golang.org:80&quot;)
if err != nil {
	// handle error
}
fmt.Fprintf(conn, &quot;GET / HTTP/1.0\r\n\r\n&quot;)
status, err := bufio.NewReader(conn).ReadString(&apos;\n&apos;)
// ...
</pre>
<p>The Listen function creates servers:
<pre>ln, err := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;)
if err != nil {
	// handle error
}
for {
	conn, err := ln.Accept()
	if err != nil {
		// handle error
	}
	go handleConnection(conn)
}
</pre>
<h3 id="hdr-Name_Resolution">Name Resolution</h3>
<p>The method for resolving domain names, whether indirectly with functions like Dial
or directly with functions like <a href="#LookupHost">LookupHost</a> and <a href="#LookupAddr">LookupAddr</a>, varies by operating system.
<p>On Unix systems, the resolver has two options for resolving names.
It can use a pure Go resolver that sends DNS requests directly to the servers
listed in /etc/resolv.conf, or it can use a cgo-based resolver that calls C
library routines such as getaddrinfo and getnameinfo.
<p>On Unix the pure Go resolver is preferred over the cgo resolver, because a blocked DNS
request consumes only a goroutine, while a blocked C call consumes an operating system thread.
When cgo is available, the cgo-based resolver is used instead under a variety of
conditions: on systems that do not let programs make direct DNS requests (OS X),
when the LOCALDOMAIN environment variable is present (even if empty),
when the RES_OPTIONS or HOSTALIASES environment variable is non-empty,
when the ASR_CONFIG environment variable is non-empty (OpenBSD only),
when /etc/resolv.conf or /etc/nsswitch.conf specify the use of features that the
Go resolver does not implement.
<p>On all systems (except Plan 9), when the cgo resolver is being used
this package applies a concurrent cgo lookup limit to prevent the system
from running out of system threads. Currently, it is limited to 500 concurrent lookups.
<p>The resolver decision can be overridden by setting the netdns value of the
GODEBUG environment variable (see package runtime) to go or cgo, as in:
<pre>export GODEBUG=netdns=go    # force pure Go resolver
export GODEBUG=netdns=cgo   # force native resolver (cgo, win32)
</pre>
<p>The decision can also be forced while building the Go source tree
by setting the netgo or netcgo build tag.
<p>A numeric netdns setting, as in GODEBUG=netdns=1, causes the resolver
to print debugging information about its decisions.
To force a particular resolver while also printing debugging information,
join the two settings by a plus sign, as in GODEBUG=netdns=go+1.
<p>The Go resolver will send an EDNS0 additional header with a DNS request,
to signal a willingness to accept a larger DNS packet size.
This can reportedly cause sporadic failures with the DNS server run
by some modems and routers. Setting GODEBUG=netedns0=0 will disable
sending the additional header.
<p>On macOS, if Go code that uses the net package is built with
-buildmode=c-archive, linking the resulting archive into a C program
requires passing -lresolv when linking the C code.
<p>On Plan 9, the resolver always accesses /net/cs and /net/dns.
<p>On Windows, in Go 1.18.x and earlier, the resolver always used C
library functions, such as GetAddrInfo and DnsQuery.

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
				<dd><a href="#pkg-variables">Variables</a></dd>
			
			
				
				<dd><a href="#JoinHostPort">func JoinHostPort(host, port string) string</a></dd>
			
				
				<dd><a href="#LookupAddr">func LookupAddr(addr string) (names []string, err error)</a></dd>
			
				
				<dd><a href="#LookupCNAME">func LookupCNAME(host string) (cname string, err error)</a></dd>
			
				
				<dd><a href="#LookupHost">func LookupHost(host string) (addrs []string, err error)</a></dd>
			
				
				<dd><a href="#LookupPort">func LookupPort(network, service string) (port int, err error)</a></dd>
			
				
				<dd><a href="#LookupTXT">func LookupTXT(name string) ([]string, error)</a></dd>
			
				
				<dd><a href="#ParseCIDR">func ParseCIDR(s string) (IP, *IPNet, error)</a></dd>
			
				
				<dd><a href="#Pipe">func Pipe() (Conn, Conn)</a></dd>
			
				
				<dd><a href="#SplitHostPort">func SplitHostPort(hostport string) (host, port string, err error)</a></dd>
			
			
				
				<dd><a href="#Addr">type Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#InterfaceAddrs">func InterfaceAddrs() ([]Addr, error)</a></dd>
				
				
			
				
				<dd><a href="#AddrError">type AddrError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#AddrError.Error">func (e *AddrError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AddrError.Temporary">func (e *AddrError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#AddrError.Timeout">func (e *AddrError) Timeout() bool</a></dd>
				
			
				
				<dd><a href="#Buffers">type Buffers</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffers.Read">func (v *Buffers) Read(p []byte) (n int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Buffers.WriteTo">func (v *Buffers) WriteTo(w io.Writer) (n int64, err error)</a></dd>
				
			
				
				<dd><a href="#Conn">type Conn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Dial">func Dial(network, address string) (Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DialTimeout">func DialTimeout(network, address string, timeout time.Duration) (Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FileConn">func FileConn(f *os.File) (c Conn, err error)</a></dd>
				
				
			
				
				<dd><a href="#DNSConfigError">type DNSConfigError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSConfigError.Error">func (e *DNSConfigError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSConfigError.Temporary">func (e *DNSConfigError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSConfigError.Timeout">func (e *DNSConfigError) Timeout() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSConfigError.Unwrap">func (e *DNSConfigError) Unwrap() error</a></dd>
				
			
				
				<dd><a href="#DNSError">type DNSError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSError.Error">func (e *DNSError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSError.Temporary">func (e *DNSError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSError.Timeout">func (e *DNSError) Timeout() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DNSError.Unwrap">func (e *DNSError) Unwrap() error</a></dd>
				
			
				
				<dd><a href="#Dialer">type Dialer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Dialer.Dial">func (d *Dialer) Dial(network, address string) (Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Dialer.DialContext">func (d *Dialer) DialContext(ctx context.Context, network, address string) (Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Dialer.MultipathTCP">func (d *Dialer) MultipathTCP() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Dialer.SetMultipathTCP">func (d *Dialer) SetMultipathTCP(use bool)</a></dd>
				
			
				
				<dd><a href="#Error">type Error</a></dd>
				
				
			
				
				<dd><a href="#Flags">type Flags</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Flags.String">func (f Flags) String() string</a></dd>
				
			
				
				<dd><a href="#HardwareAddr">type HardwareAddr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseMAC">func ParseMAC(s string) (hw HardwareAddr, err error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#HardwareAddr.String">func (a HardwareAddr) String() string</a></dd>
				
			
				
				<dd><a href="#IP">type IP</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPv4">func IPv4(a, b, c, d byte) IP</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LookupIP">func LookupIP(host string) ([]IP, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseIP">func ParseIP(s string) IP</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.DefaultMask">func (ip IP) DefaultMask() IPMask</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.Equal">func (ip IP) Equal(x IP) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsGlobalUnicast">func (ip IP) IsGlobalUnicast() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsInterfaceLocalMulticast">func (ip IP) IsInterfaceLocalMulticast() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsLinkLocalMulticast">func (ip IP) IsLinkLocalMulticast() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsLinkLocalUnicast">func (ip IP) IsLinkLocalUnicast() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsLoopback">func (ip IP) IsLoopback() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsMulticast">func (ip IP) IsMulticast() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsPrivate">func (ip IP) IsPrivate() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.IsUnspecified">func (ip IP) IsUnspecified() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.MarshalText">func (ip IP) MarshalText() ([]byte, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.Mask">func (ip IP) Mask(mask IPMask) IP</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.String">func (ip IP) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.To16">func (ip IP) To16() IP</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.To4">func (ip IP) To4() IP</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IP.UnmarshalText">func (ip *IP) UnmarshalText(text []byte) error</a></dd>
				
			
				
				<dd><a href="#IPAddr">type IPAddr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ResolveIPAddr">func ResolveIPAddr(network, address string) (*IPAddr, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IPAddr.Network">func (a *IPAddr) Network() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPAddr.String">func (a *IPAddr) String() string</a></dd>
				
			
				
				<dd><a href="#IPConn">type IPConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DialIP">func DialIP(network string, laddr, raddr *IPAddr) (*IPConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenIP">func ListenIP(network string, laddr *IPAddr) (*IPConn, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.Close">func (c *IPConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.File">func (c *IPConn) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.LocalAddr">func (c *IPConn) LocalAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.Read">func (c *IPConn) Read(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.ReadFrom">func (c *IPConn) ReadFrom(b []byte) (int, Addr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.ReadFromIP">func (c *IPConn) ReadFromIP(b []byte) (int, *IPAddr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.ReadMsgIP">func (c *IPConn) ReadMsgIP(b, oob []byte) (n, oobn, flags int, addr *IPAddr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.RemoteAddr">func (c *IPConn) RemoteAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SetDeadline">func (c *IPConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SetReadBuffer">func (c *IPConn) SetReadBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SetReadDeadline">func (c *IPConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SetWriteBuffer">func (c *IPConn) SetWriteBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SetWriteDeadline">func (c *IPConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.SyscallConn">func (c *IPConn) SyscallConn() (syscall.RawConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.Write">func (c *IPConn) Write(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.WriteMsgIP">func (c *IPConn) WriteMsgIP(b, oob []byte, addr *IPAddr) (n, oobn int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.WriteTo">func (c *IPConn) WriteTo(b []byte, addr Addr) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPConn.WriteToIP">func (c *IPConn) WriteToIP(b []byte, addr *IPAddr) (int, error)</a></dd>
				
			
				
				<dd><a href="#IPMask">type IPMask</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CIDRMask">func CIDRMask(ones, bits int) IPMask</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPv4Mask">func IPv4Mask(a, b, c, d byte) IPMask</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IPMask.Size">func (m IPMask) Size() (ones, bits int)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPMask.String">func (m IPMask) String() string</a></dd>
				
			
				
				<dd><a href="#IPNet">type IPNet</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IPNet.Contains">func (n *IPNet) Contains(ip IP) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPNet.Network">func (n *IPNet) Network() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IPNet.String">func (n *IPNet) String() string</a></dd>
				
			
				
				<dd><a href="#Interface">type Interface</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#InterfaceByIndex">func InterfaceByIndex(index int) (*Interface, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#InterfaceByName">func InterfaceByName(name string) (*Interface, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interfaces">func Interfaces() ([]Interface, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.Addrs">func (ifi *Interface) Addrs() ([]Addr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Interface.MulticastAddrs">func (ifi *Interface) MulticastAddrs() ([]Addr, error)</a></dd>
				
			
				
				<dd><a href="#InvalidAddrError">type InvalidAddrError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#InvalidAddrError.Error">func (e InvalidAddrError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#InvalidAddrError.Temporary">func (e InvalidAddrError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#InvalidAddrError.Timeout">func (e InvalidAddrError) Timeout() bool</a></dd>
				
			
				
				<dd><a href="#KeepAliveConfig">type KeepAliveConfig</a></dd>
				
				
			
				
				<dd><a href="#ListenConfig">type ListenConfig</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenConfig.Listen">func (lc *ListenConfig) Listen(ctx context.Context, network, address string) (Listener, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenConfig.ListenPacket">func (lc *ListenConfig) ListenPacket(ctx context.Context, network, address string) (PacketConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenConfig.MultipathTCP">func (lc *ListenConfig) MultipathTCP() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenConfig.SetMultipathTCP">func (lc *ListenConfig) SetMultipathTCP(use bool)</a></dd>
				
			
				
				<dd><a href="#Listener">type Listener</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FileListener">func FileListener(f *os.File) (ln Listener, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Listen">func Listen(network, address string) (Listener, error)</a></dd>
				
				
			
				
				<dd><a href="#MX">type MX</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LookupMX">func LookupMX(name string) ([]*MX, error)</a></dd>
				
				
			
				
				<dd><a href="#NS">type NS</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LookupNS">func LookupNS(name string) ([]*NS, error)</a></dd>
				
				
			
				
				<dd><a href="#OpError">type OpError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#OpError.Error">func (e *OpError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#OpError.Temporary">func (e *OpError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#OpError.Timeout">func (e *OpError) Timeout() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#OpError.Unwrap">func (e *OpError) Unwrap() error</a></dd>
				
			
				
				<dd><a href="#PacketConn">type PacketConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FilePacketConn">func FilePacketConn(f *os.File) (c PacketConn, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenPacket">func ListenPacket(network, address string) (PacketConn, error)</a></dd>
				
				
			
				
				<dd><a href="#ParseError">type ParseError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseError.Error">func (e *ParseError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseError.Temporary">func (e *ParseError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ParseError.Timeout">func (e *ParseError) Timeout() bool</a></dd>
				
			
				
				<dd><a href="#Resolver">type Resolver</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Resolver.LookupAddr">func (r *Resolver) LookupAddr(ctx context.Context, addr string) ([]string, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Resolver.LookupCNAME">func (r *Resolver) LookupCNAME(ctx context.Context, host string) (string, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Resolver.LookupHost">func (r *Resolver) LookupHost(ctx context.Context, host string) (addrs []string, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Resolver.LookupIP">func (r *Resolver) LookupIP(ctx context.Context, network, host string) ([]IP, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Resolver.LookupIPAddr">func (r *Resolver) LookupIPAddr(ctx context.Context, host string) ([]IPAddr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Resolver.LookupMX">func (r *Resolver) LookupMX(ctx context.Context, name string) ([]*MX, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Resolver.LookupNS">func (r *Resolver) LookupNS(ctx context.Context, name string) ([]*NS, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Resolver.LookupNetIP">func (r *Resolver) LookupNetIP(ctx context.Context, network, host string) ([]netip.Addr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Resolver.LookupPort">func (r *Resolver) LookupPort(ctx context.Context, network, service string) (port int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Resolver.LookupSRV">func (r *Resolver) LookupSRV(ctx context.Context, service, proto, name string) (string, []*SRV, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Resolver.LookupTXT">func (r *Resolver) LookupTXT(ctx context.Context, name string) ([]string, error)</a></dd>
				
			
				
				<dd><a href="#SRV">type SRV</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#LookupSRV">func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err error)</a></dd>
				
				
			
				
				<dd><a href="#TCPAddr">type TCPAddr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ResolveTCPAddr">func ResolveTCPAddr(network, address string) (*TCPAddr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPAddrFromAddrPort">func TCPAddrFromAddrPort(addr netip.AddrPort) *TCPAddr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPAddr.AddrPort">func (a *TCPAddr) AddrPort() netip.AddrPort</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPAddr.Network">func (a *TCPAddr) Network() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPAddr.String">func (a *TCPAddr) String() string</a></dd>
				
			
				
				<dd><a href="#TCPConn">type TCPConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DialTCP">func DialTCP(network string, laddr, raddr *TCPAddr) (*TCPConn, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.Close">func (c *TCPConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.CloseRead">func (c *TCPConn) CloseRead() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.CloseWrite">func (c *TCPConn) CloseWrite() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.File">func (c *TCPConn) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.LocalAddr">func (c *TCPConn) LocalAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.MultipathTCP">func (c *TCPConn) MultipathTCP() (bool, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.Read">func (c *TCPConn) Read(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.ReadFrom">func (c *TCPConn) ReadFrom(r io.Reader) (int64, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.RemoteAddr">func (c *TCPConn) RemoteAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetDeadline">func (c *TCPConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetKeepAlive">func (c *TCPConn) SetKeepAlive(keepalive bool) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetKeepAliveConfig">func (c *TCPConn) SetKeepAliveConfig(config KeepAliveConfig) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetKeepAlivePeriod">func (c *TCPConn) SetKeepAlivePeriod(d time.Duration) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetLinger">func (c *TCPConn) SetLinger(sec int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetNoDelay">func (c *TCPConn) SetNoDelay(noDelay bool) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetReadBuffer">func (c *TCPConn) SetReadBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetReadDeadline">func (c *TCPConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetWriteBuffer">func (c *TCPConn) SetWriteBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SetWriteDeadline">func (c *TCPConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.SyscallConn">func (c *TCPConn) SyscallConn() (syscall.RawConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.Write">func (c *TCPConn) Write(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPConn.WriteTo">func (c *TCPConn) WriteTo(w io.Writer) (int64, error)</a></dd>
				
			
				
				<dd><a href="#TCPListener">type TCPListener</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenTCP">func ListenTCP(network string, laddr *TCPAddr) (*TCPListener, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.Accept">func (l *TCPListener) Accept() (Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.AcceptTCP">func (l *TCPListener) AcceptTCP() (*TCPConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.Addr">func (l *TCPListener) Addr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.Close">func (l *TCPListener) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.File">func (l *TCPListener) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.SetDeadline">func (l *TCPListener) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TCPListener.SyscallConn">func (l *TCPListener) SyscallConn() (syscall.RawConn, error)</a></dd>
				
			
				
				<dd><a href="#UDPAddr">type UDPAddr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ResolveUDPAddr">func ResolveUDPAddr(network, address string) (*UDPAddr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPAddrFromAddrPort">func UDPAddrFromAddrPort(addr netip.AddrPort) *UDPAddr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPAddr.AddrPort">func (a *UDPAddr) AddrPort() netip.AddrPort</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPAddr.Network">func (a *UDPAddr) Network() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPAddr.String">func (a *UDPAddr) String() string</a></dd>
				
			
				
				<dd><a href="#UDPConn">type UDPConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DialUDP">func DialUDP(network string, laddr, raddr *UDPAddr) (*UDPConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenMulticastUDP">func ListenMulticastUDP(network string, ifi *Interface, gaddr *UDPAddr) (*UDPConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenUDP">func ListenUDP(network string, laddr *UDPAddr) (*UDPConn, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.Close">func (c *UDPConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.File">func (c *UDPConn) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.LocalAddr">func (c *UDPConn) LocalAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.Read">func (c *UDPConn) Read(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.ReadFrom">func (c *UDPConn) ReadFrom(b []byte) (int, Addr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.ReadFromUDP">func (c *UDPConn) ReadFromUDP(b []byte) (n int, addr *UDPAddr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.ReadFromUDPAddrPort">func (c *UDPConn) ReadFromUDPAddrPort(b []byte) (n int, addr netip.AddrPort, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.ReadMsgUDP">func (c *UDPConn) ReadMsgUDP(b, oob []byte) (n, oobn, flags int, addr *UDPAddr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.ReadMsgUDPAddrPort">func (c *UDPConn) ReadMsgUDPAddrPort(b, oob []byte) (n, oobn, flags int, addr netip.AddrPort, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.RemoteAddr">func (c *UDPConn) RemoteAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SetDeadline">func (c *UDPConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SetReadBuffer">func (c *UDPConn) SetReadBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SetReadDeadline">func (c *UDPConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SetWriteBuffer">func (c *UDPConn) SetWriteBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SetWriteDeadline">func (c *UDPConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.SyscallConn">func (c *UDPConn) SyscallConn() (syscall.RawConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.Write">func (c *UDPConn) Write(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.WriteMsgUDP">func (c *UDPConn) WriteMsgUDP(b, oob []byte, addr *UDPAddr) (n, oobn int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.WriteMsgUDPAddrPort">func (c *UDPConn) WriteMsgUDPAddrPort(b, oob []byte, addr netip.AddrPort) (n, oobn int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.WriteTo">func (c *UDPConn) WriteTo(b []byte, addr Addr) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.WriteToUDP">func (c *UDPConn) WriteToUDP(b []byte, addr *UDPAddr) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UDPConn.WriteToUDPAddrPort">func (c *UDPConn) WriteToUDPAddrPort(b []byte, addr netip.AddrPort) (int, error)</a></dd>
				
			
				
				<dd><a href="#UnixAddr">type UnixAddr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ResolveUnixAddr">func ResolveUnixAddr(network, address string) (*UnixAddr, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixAddr.Network">func (a *UnixAddr) Network() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixAddr.String">func (a *UnixAddr) String() string</a></dd>
				
			
				
				<dd><a href="#UnixConn">type UnixConn</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DialUnix">func DialUnix(network string, laddr, raddr *UnixAddr) (*UnixConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenUnixgram">func ListenUnixgram(network string, laddr *UnixAddr) (*UnixConn, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.Close">func (c *UnixConn) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.CloseRead">func (c *UnixConn) CloseRead() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.CloseWrite">func (c *UnixConn) CloseWrite() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.File">func (c *UnixConn) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.LocalAddr">func (c *UnixConn) LocalAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.Read">func (c *UnixConn) Read(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.ReadFrom">func (c *UnixConn) ReadFrom(b []byte) (int, Addr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.ReadFromUnix">func (c *UnixConn) ReadFromUnix(b []byte) (int, *UnixAddr, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.ReadMsgUnix">func (c *UnixConn) ReadMsgUnix(b, oob []byte) (n, oobn, flags int, addr *UnixAddr, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.RemoteAddr">func (c *UnixConn) RemoteAddr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SetDeadline">func (c *UnixConn) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SetReadBuffer">func (c *UnixConn) SetReadBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SetReadDeadline">func (c *UnixConn) SetReadDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SetWriteBuffer">func (c *UnixConn) SetWriteBuffer(bytes int) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SetWriteDeadline">func (c *UnixConn) SetWriteDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.SyscallConn">func (c *UnixConn) SyscallConn() (syscall.RawConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.Write">func (c *UnixConn) Write(b []byte) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.WriteMsgUnix">func (c *UnixConn) WriteMsgUnix(b, oob []byte, addr *UnixAddr) (n, oobn int, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.WriteTo">func (c *UnixConn) WriteTo(b []byte, addr Addr) (int, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixConn.WriteToUnix">func (c *UnixConn) WriteToUnix(b []byte, addr *UnixAddr) (int, error)</a></dd>
				
			
				
				<dd><a href="#UnixListener">type UnixListener</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ListenUnix">func ListenUnix(network string, laddr *UnixAddr) (*UnixListener, error)</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.Accept">func (l *UnixListener) Accept() (Conn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.AcceptUnix">func (l *UnixListener) AcceptUnix() (*UnixConn, error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.Addr">func (l *UnixListener) Addr() Addr</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.Close">func (l *UnixListener) Close() error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.File">func (l *UnixListener) File() (f *os.File, err error)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.SetDeadline">func (l *UnixListener) SetDeadline(t time.Time) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.SetUnlinkOnClose">func (l *UnixListener) SetUnlinkOnClose(unlink bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnixListener.SyscallConn">func (l *UnixListener) SyscallConn() (syscall.RawConn, error)</a></dd>
				
			
				
				<dd><a href="#UnknownNetworkError">type UnknownNetworkError</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnknownNetworkError.Error">func (e UnknownNetworkError) Error() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnknownNetworkError.Temporary">func (e UnknownNetworkError) Temporary() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnknownNetworkError.Timeout">func (e UnknownNetworkError) Timeout() bool</a></dd>
				
			
			
				
				<dd><a href="#pkg-note-BUG">Bugs</a></dd>
				
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="#example_CIDRMask">CIDRMask</a></dd>
			
			<dd><a class="exampleLink" href="#example_Dialer">Dialer</a></dd>
			
			<dd><a class="exampleLink" href="#example_Dialer_unix">Dialer (Unix)</a></dd>
			
			<dd><a class="exampleLink" href="#example_IP_DefaultMask">IP.DefaultMask</a></dd>
			
			<dd><a class="exampleLink" href="#example_IP_Equal">IP.Equal</a></dd>
			
			<dd><a class="exampleLink" href="#example_IP_IsGlobalUnicast">IP.IsGlobalUnicast</a></dd>
			
			<dd><a class="exampleLink" href="#example_IP_IsInterfaceLocalMulticast">IP.IsInterfaceLocalMulticast</a></dd>
			
			<dd><a class="exampleLink" href="#example_IP_IsLinkLocalMulticast">IP.IsLinkLocalMulticast</a></dd>
			
			<dd><a class="exampleLink" href="#example_IP_IsLinkLocalUnicast">IP.IsLinkLocalUnicast</a></dd>
			
			<dd><a class="exampleLink" href="#example_IP_IsLoopback">IP.IsLoopback</a></dd>
			
			<dd><a class="exampleLink" href="#example_IP_IsMulticast">IP.IsMulticast</a></dd>
			
			<dd><a class="exampleLink" href="#example_IP_IsPrivate">IP.IsPrivate</a></dd>
			
			<dd><a class="exampleLink" href="#example_IP_IsUnspecified">IP.IsUnspecified</a></dd>
			
			<dd><a class="exampleLink" href="#example_IP_Mask">IP.Mask</a></dd>
			
			<dd><a class="exampleLink" href="#example_IP_String">IP.String</a></dd>
			
			<dd><a class="exampleLink" href="#example_IP_To16">IP.To16</a></dd>
			
			<dd><a class="exampleLink" href="#example_IP_to4">IP (To4)</a></dd>
			
			<dd><a class="exampleLink" href="#example_IPv4">IPv4</a></dd>
			
			<dd><a class="exampleLink" href="#example_IPv4Mask">IPv4Mask</a></dd>
			
			<dd><a class="exampleLink" href="#example_Listener">Listener</a></dd>
			
			<dd><a class="exampleLink" href="#example_ParseCIDR">ParseCIDR</a></dd>
			
			<dd><a class="exampleLink" href="#example_ParseIP">ParseIP</a></dd>
			
			<dd><a class="exampleLink" href="#example_UDPConn_WriteTo">UDPConn.WriteTo</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/net/addrselect.go">addrselect.go</a>
			
				<a href="/src/net/cgo_darwin.go">cgo_darwin.go</a>
			
				<a href="/src/net/cgo_unix.go">cgo_unix.go</a>
			
				<a href="/src/net/cgo_unix_syscall.go">cgo_unix_syscall.go</a>
			
				<a href="/src/net/conf.go">conf.go</a>
			
				<a href="/src/net/dial.go">dial.go</a>
			
				<a href="/src/net/dnsclient.go">dnsclient.go</a>
			
				<a href="/src/net/dnsclient_unix.go">dnsclient_unix.go</a>
			
				<a href="/src/net/dnsconfig.go">dnsconfig.go</a>
			
				<a href="/src/net/dnsconfig_unix.go">dnsconfig_unix.go</a>
			
				<a href="/src/net/error_posix.go">error_posix.go</a>
			
				<a href="/src/net/error_unix.go">error_unix.go</a>
			
				<a href="/src/net/fd_posix.go">fd_posix.go</a>
			
				<a href="/src/net/fd_unix.go">fd_unix.go</a>
			
				<a href="/src/net/file.go">file.go</a>
			
				<a href="/src/net/file_unix.go">file_unix.go</a>
			
				<a href="/src/net/hook.go">hook.go</a>
			
				<a href="/src/net/hook_unix.go">hook_unix.go</a>
			
				<a href="/src/net/hosts.go">hosts.go</a>
			
				<a href="/src/net/interface.go">interface.go</a>
			
				<a href="/src/net/interface_bsd.go">interface_bsd.go</a>
			
				<a href="/src/net/interface_darwin.go">interface_darwin.go</a>
			
				<a href="/src/net/ip.go">ip.go</a>
			
				<a href="/src/net/iprawsock.go">iprawsock.go</a>
			
				<a href="/src/net/iprawsock_posix.go">iprawsock_posix.go</a>
			
				<a href="/src/net/ipsock.go">ipsock.go</a>
			
				<a href="/src/net/ipsock_posix.go">ipsock_posix.go</a>
			
				<a href="/src/net/lookup.go">lookup.go</a>
			
				<a href="/src/net/lookup_unix.go">lookup_unix.go</a>
			
				<a href="/src/net/mac.go">mac.go</a>
			
				<a href="/src/net/mptcpsock_stub.go">mptcpsock_stub.go</a>
			
				<a href="/src/net/net.go">net.go</a>
			
				<a href="/src/net/netcgo_off.go">netcgo_off.go</a>
			
				<a href="/src/net/netgo_off.go">netgo_off.go</a>
			
				<a href="/src/net/nss.go">nss.go</a>
			
				<a href="/src/net/parse.go">parse.go</a>
			
				<a href="/src/net/pipe.go">pipe.go</a>
			
				<a href="/src/net/port.go">port.go</a>
			
				<a href="/src/net/port_unix.go">port_unix.go</a>
			
				<a href="/src/net/rawconn.go">rawconn.go</a>
			
				<a href="/src/net/rlimit_unix.go">rlimit_unix.go</a>
			
				<a href="/src/net/sendfile_unix_alt.go">sendfile_unix_alt.go</a>
			
				<a href="/src/net/sock_bsd.go">sock_bsd.go</a>
			
				<a href="/src/net/sock_posix.go">sock_posix.go</a>
			
				<a href="/src/net/sockaddr_posix.go">sockaddr_posix.go</a>
			
				<a href="/src/net/sockopt_bsd.go">sockopt_bsd.go</a>
			
				<a href="/src/net/sockopt_posix.go">sockopt_posix.go</a>
			
				<a href="/src/net/sockoptip_bsdvar.go">sockoptip_bsdvar.go</a>
			
				<a href="/src/net/sockoptip_posix.go">sockoptip_posix.go</a>
			
				<a href="/src/net/splice_stub.go">splice_stub.go</a>
			
				<a href="/src/net/sys_cloexec.go">sys_cloexec.go</a>
			
				<a href="/src/net/tcpsock.go">tcpsock.go</a>
			
				<a href="/src/net/tcpsock_posix.go">tcpsock_posix.go</a>
			
				<a href="/src/net/tcpsock_unix.go">tcpsock_unix.go</a>
			
				<a href="/src/net/tcpsockopt_darwin.go">tcpsockopt_darwin.go</a>
			
				<a href="/src/net/tcpsockopt_posix.go">tcpsockopt_posix.go</a>
			
				<a href="/src/net/udpsock.go">udpsock.go</a>
			
				<a href="/src/net/udpsock_posix.go">udpsock_posix.go</a>
			
				<a href="/src/net/unixsock.go">unixsock.go</a>
			
				<a href="/src/net/unixsock_posix.go">unixsock_posix.go</a>
			
				<a href="/src/net/unixsock_readmsg_cloexec.go">unixsock_readmsg_cloexec.go</a>
			
				<a href="/src/net/writev_unix.go">writev_unix.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				<p>IP address lengths (bytes).

				<pre>const (
    <span id="IPv4len">IPv4len</span> = 4
    <span id="IPv6len">IPv6len</span> = 16
)</pre>
			
		
		
			<h2 id="pkg-variables">Variables</h2>
			
				<p>Well-known IPv4 addresses

				<pre>var (
    <span id="IPv4bcast">IPv4bcast</span>     = <a href="#IPv4">IPv4</a>(255, 255, 255, 255) <span class="comment">// limited broadcast</span>
    <span id="IPv4allsys">IPv4allsys</span>    = <a href="#IPv4">IPv4</a>(224, 0, 0, 1)       <span class="comment">// all systems</span>
    <span id="IPv4allrouter">IPv4allrouter</span> = <a href="#IPv4">IPv4</a>(224, 0, 0, 2)       <span class="comment">// all routers</span>
    <span id="IPv4zero">IPv4zero</span>      = <a href="#IPv4">IPv4</a>(0, 0, 0, 0)         <span class="comment">// all zeros</span>
)</pre>
			
				<p>Well-known IPv6 addresses

				<pre>var (
    <span id="IPv6zero">IPv6zero</span>                   = <a href="#IP">IP</a>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    <span id="IPv6unspecified">IPv6unspecified</span>            = <a href="#IP">IP</a>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    <span id="IPv6loopback">IPv6loopback</span>               = <a href="#IP">IP</a>{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1}
    <span id="IPv6interfacelocalallnodes">IPv6interfacelocalallnodes</span> = <a href="#IP">IP</a>{0xff, 0x01, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}
    <span id="IPv6linklocalallnodes">IPv6linklocalallnodes</span>      = <a href="#IP">IP</a>{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x01}
    <span id="IPv6linklocalallrouters">IPv6linklocalallrouters</span>    = <a href="#IP">IP</a>{0xff, 0x02, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x02}
)</pre>
			
				<p>DefaultResolver is the resolver used by the package-level Lookup
functions and by Dialers without a specified Resolver.

				<pre>var <span id="DefaultResolver">DefaultResolver</span> = &amp;<a href="#Resolver">Resolver</a>{}</pre>
			
				<p>ErrClosed is the error returned by an I/O call on a network
connection that has already been closed, or that is closed by
another goroutine before the I/O is completed. This may be wrapped
in another error, and should normally be tested using
errors.Is(err, net.ErrClosed).

				<pre>var <span id="ErrClosed">ErrClosed</span> <a href="/pkg/builtin/#error">error</a> = errClosed</pre>
			
				<p>Various errors contained in OpError.

				<pre>var (
    <span id="ErrWriteToConnected">ErrWriteToConnected</span> = <a href="/pkg/errors/">errors</a>.<a href="/pkg/errors/#New">New</a>(&#34;use of WriteTo with pre-connected connection&#34;)
)</pre>
			
		
		
			
			
			<h2 id="JoinHostPort">func <a href="/src/net/ipsock.go?s=7117:7160#L226">JoinHostPort</a>
				<a class="permalink" href="#JoinHostPort">&#xb6;</a>
				
				
			</h2>
			<pre>func JoinHostPort(host, port <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#string">string</a></pre>
			<p>JoinHostPort combines host and port into a network address of the
form &quot;host:port&quot;. If host contains a colon, as found in literal
IPv6 addresses, then JoinHostPort returns &quot;[host]:port&quot;.
<p>See func Dial for a description of the host and port parameters.

			
			

		
			
			
			<h2 id="LookupAddr">func <a href="/src/net/lookup.go?s=22068:22124#L630">LookupAddr</a>
				<a class="permalink" href="#LookupAddr">&#xb6;</a>
				
				
			</h2>
			<pre>func LookupAddr(addr <a href="/pkg/builtin/#string">string</a>) (names []<a href="/pkg/builtin/#string">string</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>LookupAddr performs a reverse lookup for the given address, returning a list
of names mapping to that address.
<p>The returned names are validated to be properly formatted presentation-format
domain names. If the response contains invalid names, those records are filtered
out and an error will be returned alongside the remaining results, if any.
<p>When using the host C library resolver, at most one result will be
returned. To bypass the host resolver, use a custom <a href="#Resolver">Resolver</a>.
<p>LookupAddr uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Resolver.LookupAddr">Resolver.LookupAddr</a>.

			
			

		
			
			
			<h2 id="LookupCNAME">func <a href="/src/net/lookup.go?s=14860:14915#L441">LookupCNAME</a>
				<a class="permalink" href="#LookupCNAME">&#xb6;</a>
				
				
			</h2>
			<pre>func LookupCNAME(host <a href="/pkg/builtin/#string">string</a>) (cname <a href="/pkg/builtin/#string">string</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>LookupCNAME returns the canonical name for the given host.
Callers that do not care about the canonical name can call
<a href="#LookupHost">LookupHost</a> or <a href="#LookupIP">LookupIP</a> directly; both take care of resolving
the canonical name as part of the lookup.
<p>A canonical name is the final name after following zero
or more CNAME records.
LookupCNAME does not return an error if host does not
contain DNS &quot;CNAME&quot; records, as long as host resolves to
address records.
<p>The returned canonical name is validated to be a properly
formatted presentation-format domain name.
<p>LookupCNAME uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Resolver.LookupCNAME">Resolver.LookupCNAME</a>.

			
			

		
			
			
			<h2 id="LookupHost">func <a href="/src/net/lookup.go?s=6129:6185#L176">LookupHost</a>
				<a class="permalink" href="#LookupHost">&#xb6;</a>
				
				
			</h2>
			<pre>func LookupHost(host <a href="/pkg/builtin/#string">string</a>) (addrs []<a href="/pkg/builtin/#string">string</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>LookupHost looks up the given host using the local resolver.
It returns a slice of that host&apos;s addresses.
<p>LookupHost uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Resolver.LookupHost">Resolver.LookupHost</a>.

			
			

		
			
			
			<h2 id="LookupPort">func <a href="/src/net/lookup.go?s=13278:13340#L397">LookupPort</a>
				<a class="permalink" href="#LookupPort">&#xb6;</a>
				
				
			</h2>
			<pre>func LookupPort(network, service <a href="/pkg/builtin/#string">string</a>) (port <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>LookupPort looks up the port for the given network and service.
<p>LookupPort uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Resolver.LookupPort">Resolver.LookupPort</a>.

			
			

		
			
			
			<h2 id="LookupTXT">func <a href="/src/net/lookup.go?s=21158:21203#L609">LookupTXT</a>
				<a class="permalink" href="#LookupTXT">&#xb6;</a>
				
				
			</h2>
			<pre>func LookupTXT(name <a href="/pkg/builtin/#string">string</a>) ([]<a href="/pkg/builtin/#string">string</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>LookupTXT returns the DNS TXT records for the given domain name.
<p>LookupTXT uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Resolver.LookupTXT">Resolver.LookupTXT</a>.

			
			

		
			
			
			<h2 id="ParseCIDR">func <a href="/src/net/ip.go?s=13641:13685#L509">ParseCIDR</a>
				<a class="permalink" href="#ParseCIDR">&#xb6;</a>
				
				
			</h2>
			<pre>func ParseCIDR(s <a href="/pkg/builtin/#string">string</a>) (<a href="#IP">IP</a>, *<a href="#IPNet">IPNet</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>ParseCIDR parses s as a CIDR notation IP address and prefix length,
like &quot;192.0.2.0/24&quot; or &quot;2001:db8::/32&quot;, as defined in
RFC 4632 and RFC 4291.
<p>It returns the IP address and the network implied by the IP and
prefix length.
For example, ParseCIDR(&quot;192.0.2.1/24&quot;) returns the IP address
192.0.2.1 and the network 192.0.2.0/24.

			<div id="example_ParseCIDR" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">ipv4Addr, ipv4Net, err := net.ParseCIDR(&#34;192.0.2.1/24&#34;)
if err != nil {
    log.Fatal(err)
}
fmt.Println(ipv4Addr)
fmt.Println(ipv4Net)

ipv6Addr, ipv6Net, err := net.ParseCIDR(&#34;2001:db8:a0b:12f0::1/32&#34;)
if err != nil {
    log.Fatal(err)
}
fmt.Println(ipv6Addr)
fmt.Println(ipv6Net)

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">192.0.2.1
192.0.2.0/24
2001:db8:a0b:12f0::1
2001:db8::/32
</pre>
			
		
	</div>
</div>

			

		
			
			
			<h2 id="Pipe">func <a href="/src/net/pipe.go?s=2676:2700#L103">Pipe</a>
				<a class="permalink" href="#Pipe">&#xb6;</a>
				
				
			</h2>
			<pre>func Pipe() (<a href="#Conn">Conn</a>, <a href="#Conn">Conn</a>)</pre>
			<p>Pipe creates a synchronous, in-memory, full duplex
network connection; both ends implement the <a href="#Conn">Conn</a> interface.
Reads on one end are matched with writes on the other,
copying data directly between the two; there is no internal
buffering.

			
			

		
			
			
			<h2 id="SplitHostPort">func <a href="/src/net/ipsock.go?s=5027:5093#L155">SplitHostPort</a>
				<a class="permalink" href="#SplitHostPort">&#xb6;</a>
				
				
			</h2>
			<pre>func SplitHostPort(hostport <a href="/pkg/builtin/#string">string</a>) (host, port <a href="/pkg/builtin/#string">string</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
			<p>SplitHostPort splits a network address of the form &quot;host:port&quot;,
&quot;host%zone:port&quot;, &quot;[host]:port&quot; or &quot;[host%zone]:port&quot; into host or
host%zone and port.
<p>A literal IPv6 address in hostport must be enclosed in square
brackets, as in &quot;[::1]:80&quot;, &quot;[::1%lo0]:80&quot;.
<p>See func Dial for a description of the hostport parameter, and host
and port results.

			
			

		
		
			
			
			<h2 id="Addr">type <a href="/src/net/net.go?s=4136:4322#L101">Addr</a>
				<a class="permalink" href="#Addr">&#xb6;</a>
				
				
			</h2>
			<p>Addr represents a network end point address.
<p>The two methods [Addr.Network] and [Addr.String] conventionally return strings
that can be passed as the arguments to <a href="#Dial">Dial</a>, but the exact form
and meaning of the strings is up to the implementation.

			<pre>type Addr interface {
    Network() <a href="/pkg/builtin/#string">string</a> <span class="comment">// name of the network (for example, &#34;tcp&#34;, &#34;udp&#34;)</span>
    String() <a href="/pkg/builtin/#string">string</a>  <span class="comment">// string form of address (for example, &#34;192.0.2.1:25&#34;, &#34;[2001:db8::1]:80&#34;)</span>
}</pre>

			

			

			
			
			

			
				
				<h3 id="InterfaceAddrs">func <a href="/src/net/interface.go?s=3839:3876#L119">InterfaceAddrs</a>
					<a class="permalink" href="#InterfaceAddrs">&#xb6;</a>
					
					
				</h3>
				<pre>func InterfaceAddrs() ([]<a href="#Addr">Addr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>InterfaceAddrs returns a list of the system&apos;s unicast interface
addresses.
<p>The returned list does not identify the associated interface; use
Interfaces and <a href="#Interface.Addrs">Interface.Addrs</a> for more detail.

				
				
			

			
		
			
			
			<h2 id="AddrError">type <a href="/src/net/net.go?s=18383:18434#L562">AddrError</a>
				<a class="permalink" href="#AddrError">&#xb6;</a>
				
				
			</h2>
			
			<pre>type AddrError struct {
<span id="AddrError.Err"></span>    Err  <a href="/pkg/builtin/#string">string</a>
<span id="AddrError.Addr"></span>    Addr <a href="/pkg/builtin/#string">string</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="AddrError.Error">func (*AddrError) <a href="/src/net/net.go?s=18436:18470#L567">Error</a>
					<a class="permalink" href="#AddrError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#AddrError">AddrError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="AddrError.Temporary">func (*AddrError) <a href="/src/net/net.go?s=18646:18682#L579">Temporary</a>
					<a class="permalink" href="#AddrError.Temporary">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#AddrError">AddrError</a>) Temporary() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="AddrError.Timeout">func (*AddrError) <a href="/src/net/net.go?s=18592:18626#L578">Timeout</a>
					<a class="permalink" href="#AddrError.Timeout">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#AddrError">AddrError</a>) Timeout() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Buffers">type <a href="/src/net/net.go?s=26583:26604#L818">Buffers</a>
				<a class="permalink" href="#Buffers">&#xb6;</a>
				
				<span title="Added in Go 1.8">1.8</span>
			</h2>
			<p>Buffers contains zero or more runs of bytes to write.
<p>On certain machines, for certain types of connections, this is
optimized into an OS-specific batch write operation (such as
&quot;writev&quot;).

			<pre>type Buffers [][]<a href="/pkg/builtin/#byte">byte</a></pre>

			

			

			
			
			

			

			
				
				<h3 id="Buffers.Read">func (*Buffers) <a href="/src/net/net.go?s=27375:27426#L853">Read</a>
					<a class="permalink" href="#Buffers.Read">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (v *<a href="#Buffers">Buffers</a>) Read(p []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Read from the buffers.
<p>Read implements <a href="/io#Reader">io.Reader</a> for <a href="#Buffers">Buffers</a>.
<p>Read modifies the slice v as well as v[i] for 0 &lt;= i &lt; len(v),
but does not modify v[i][j] for any i, j.

				
				
				
			
				
				<h3 id="Buffers.WriteTo">func (*Buffers) <a href="/src/net/net.go?s=26900:26959#L831">WriteTo</a>
					<a class="permalink" href="#Buffers.WriteTo">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (v *<a href="#Buffers">Buffers</a>) WriteTo(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>) (n <a href="/pkg/builtin/#int64">int64</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteTo writes contents of the buffers to w.
<p>WriteTo implements <a href="/io#WriterTo">io.WriterTo</a> for <a href="#Buffers">Buffers</a>.
<p>WriteTo modifies the slice v as well as v[i] for 0 &lt;= i &lt; len(v),
but does not modify v[i][j] for any i, j.

				
				
				
			
		
			
			
			<h2 id="Conn">type <a href="/src/net/net.go?s=4452:6769#L109">Conn</a>
				<a class="permalink" href="#Conn">&#xb6;</a>
				
				
			</h2>
			<p>Conn is a generic stream-oriented network connection.
<p>Multiple goroutines may invoke methods on a Conn simultaneously.

			<pre>type Conn interface {
    <span class="comment">// Read reads data from the connection.</span>
    <span class="comment">// Read can be made to time out and return an error after a fixed</span>
    <span class="comment">// time limit; see SetDeadline and SetReadDeadline.</span>
    Read(b []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)

    <span class="comment">// Write writes data to the connection.</span>
    <span class="comment">// Write can be made to time out and return an error after a fixed</span>
    <span class="comment">// time limit; see SetDeadline and SetWriteDeadline.</span>
    Write(b []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)

    <span class="comment">// Close closes the connection.</span>
    <span class="comment">// Any blocked Read or Write operations will be unblocked and return errors.</span>
    Close() <a href="/pkg/builtin/#error">error</a>

    <span class="comment">// LocalAddr returns the local network address, if known.</span>
    LocalAddr() <a href="#Addr">Addr</a>

    <span class="comment">// RemoteAddr returns the remote network address, if known.</span>
    RemoteAddr() <a href="#Addr">Addr</a>

    <span class="comment">// SetDeadline sets the read and write deadlines associated</span>
    <span class="comment">// with the connection. It is equivalent to calling both</span>
    <span class="comment">// SetReadDeadline and SetWriteDeadline.</span>
    <span class="comment">//</span>
    <span class="comment">// A deadline is an absolute time after which I/O operations</span>
    <span class="comment">// fail instead of blocking. The deadline applies to all future</span>
    <span class="comment">// and pending I/O, not just the immediately following call to</span>
    <span class="comment">// Read or Write. After a deadline has been exceeded, the</span>
    <span class="comment">// connection can be refreshed by setting a deadline in the future.</span>
    <span class="comment">//</span>
    <span class="comment">// If the deadline is exceeded a call to Read or Write or to other</span>
    <span class="comment">// I/O methods will return an error that wraps os.ErrDeadlineExceeded.</span>
    <span class="comment">// This can be tested using errors.Is(err, os.ErrDeadlineExceeded).</span>
    <span class="comment">// The error&#39;s Timeout method will return true, but note that there</span>
    <span class="comment">// are other possible errors for which the Timeout method will</span>
    <span class="comment">// return true even if the deadline has not been exceeded.</span>
    <span class="comment">//</span>
    <span class="comment">// An idle timeout can be implemented by repeatedly extending</span>
    <span class="comment">// the deadline after successful Read or Write calls.</span>
    <span class="comment">//</span>
    <span class="comment">// A zero value for t means I/O operations will not time out.</span>
    SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a>

    <span class="comment">// SetReadDeadline sets the deadline for future Read calls</span>
    <span class="comment">// and any currently-blocked Read call.</span>
    <span class="comment">// A zero value for t means Read will not time out.</span>
    SetReadDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a>

    <span class="comment">// SetWriteDeadline sets the deadline for future Write calls</span>
    <span class="comment">// and any currently-blocked Write call.</span>
    <span class="comment">// Even if write times out, it may return n &gt; 0, indicating that</span>
    <span class="comment">// some of the data was successfully written.</span>
    <span class="comment">// A zero value for t means Write will not time out.</span>
    SetWriteDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="Dial">func <a href="/src/net/dial.go?s=12856:12904#L408">Dial</a>
					<a class="permalink" href="#Dial">&#xb6;</a>
					
					
				</h3>
				<pre>func Dial(network, address <a href="/pkg/builtin/#string">string</a>) (<a href="#Conn">Conn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Dial connects to the address on the named network.
<p>Known networks are &quot;tcp&quot;, &quot;tcp4&quot; (IPv4-only), &quot;tcp6&quot; (IPv6-only),
&quot;udp&quot;, &quot;udp4&quot; (IPv4-only), &quot;udp6&quot; (IPv6-only), &quot;ip&quot;, &quot;ip4&quot;
(IPv4-only), &quot;ip6&quot; (IPv6-only), &quot;unix&quot;, &quot;unixgram&quot; and
&quot;unixpacket&quot;.
<p>For TCP and UDP networks, the address has the form &quot;host:port&quot;.
The host must be a literal IP address, or a host name that can be
resolved to IP addresses.
The port must be a literal port number or a service name.
If the host is a literal IPv6 address it must be enclosed in square
brackets, as in &quot;[2001:db8::1]:80&quot; or &quot;[fe80::1%zone]:80&quot;.
The zone specifies the scope of the literal IPv6 address as defined
in RFC 4007.
The functions <a href="#JoinHostPort">JoinHostPort</a> and <a href="#SplitHostPort">SplitHostPort</a> manipulate a pair of
host and port in this form.
When using TCP, and the host resolves to multiple IP addresses,
Dial will try each IP address in order until one succeeds.
<p>Examples:
<pre>Dial(&quot;tcp&quot;, &quot;golang.org:http&quot;)
Dial(&quot;tcp&quot;, &quot;192.0.2.1:http&quot;)
Dial(&quot;tcp&quot;, &quot;198.51.100.1:80&quot;)
Dial(&quot;udp&quot;, &quot;[2001:db8::1]:domain&quot;)
Dial(&quot;udp&quot;, &quot;[fe80::1%lo0]:53&quot;)
Dial(&quot;tcp&quot;, &quot;:80&quot;)
</pre>
<p>For IP networks, the network must be &quot;ip&quot;, &quot;ip4&quot; or &quot;ip6&quot; followed
by a colon and a literal protocol number or a protocol name, and
the address has the form &quot;host&quot;. The host must be a literal IP
address or a literal IPv6 address with zone.
It depends on each operating system how the operating system
behaves with a non-well known protocol number such as &quot;0&quot; or &quot;255&quot;.
<p>Examples:
<pre>Dial(&quot;ip4:1&quot;, &quot;192.0.2.1&quot;)
Dial(&quot;ip6:ipv6-icmp&quot;, &quot;2001:db8::1&quot;)
Dial(&quot;ip6:58&quot;, &quot;fe80::1%lo0&quot;)
</pre>
<p>For TCP, UDP and IP networks, if the host is empty or a literal
unspecified IP address, as in &quot;:80&quot;, &quot;0.0.0.0:80&quot; or &quot;[::]:80&quot; for
TCP and UDP, &quot;&quot;, &quot;0.0.0.0&quot; or &quot;::&quot; for IP, the local system is
assumed.
<p>For Unix networks, the address must be a file system path.

				
				
			
				
				<h3 id="DialTimeout">func <a href="/src/net/dial.go?s=13370:13448#L423">DialTimeout</a>
					<a class="permalink" href="#DialTimeout">&#xb6;</a>
					
					
				</h3>
				<pre>func DialTimeout(network, address <a href="/pkg/builtin/#string">string</a>, timeout <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a>) (<a href="#Conn">Conn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>DialTimeout acts like <a href="#Dial">Dial</a> but takes a timeout.
<p>The timeout includes name resolution, if required.
When using TCP, and the host in the address parameter resolves to
multiple IP addresses, the timeout is spread over each consecutive
dial, such that each is given an appropriate fraction of the time
to connect.
<p>See func Dial for a description of the network and address
parameters.

				
				
			
				
				<h3 id="FileConn">func <a href="/src/net/file.go?s=653:698#L11">FileConn</a>
					<a class="permalink" href="#FileConn">&#xb6;</a>
					
					
				</h3>
				<pre>func FileConn(f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>) (c <a href="#Conn">Conn</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>FileConn returns a copy of the network connection corresponding to
the open file f.
It is the caller&apos;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.

				
				
			

			
		
			
			
			<h2 id="DNSConfigError">type <a href="/src/net/net.go?s=20040:20081#L618">DNSConfigError</a>
				<a class="permalink" href="#DNSConfigError">&#xb6;</a>
				
				
			</h2>
			<p>DNSConfigError represents an error reading the machine&apos;s DNS configuration.
(No longer used; kept for compatibility.)

			<pre>type DNSConfigError struct {
<span id="DNSConfigError.Err"></span>    Err <a href="/pkg/builtin/#error">error</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="DNSConfigError.Error">func (*DNSConfigError) <a href="/src/net/net.go?s=20142:20181#L623">Error</a>
					<a class="permalink" href="#DNSConfigError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#DNSConfigError">DNSConfigError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="DNSConfigError.Temporary">func (*DNSConfigError) <a href="/src/net/net.go?s=20299:20340#L625">Temporary</a>
					<a class="permalink" href="#DNSConfigError.Temporary">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#DNSConfigError">DNSConfigError</a>) Temporary() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="DNSConfigError.Timeout">func (*DNSConfigError) <a href="/src/net/net.go?s=20240:20279#L624">Timeout</a>
					<a class="permalink" href="#DNSConfigError.Timeout">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#DNSConfigError">DNSConfigError</a>) Timeout() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="DNSConfigError.Unwrap">func (*DNSConfigError) <a href="/src/net/net.go?s=20083:20122#L622">Unwrap</a>
					<a class="permalink" href="#DNSConfigError.Unwrap">&#xb6;</a>
					
					<span title="Added in Go 1.13">1.13</span>
				</h3>
				<pre>func (e *<a href="#DNSConfigError">DNSConfigError</a>) Unwrap() <a href="/pkg/builtin/#error">error</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="DNSError">type <a href="/src/net/net.go?s=21131:21700#L648">DNSError</a>
				<a class="permalink" href="#DNSError">&#xb6;</a>
				
				
			</h2>
			<p>DNSError represents a DNS lookup error.

			<pre>type DNSError struct {
<span id="DNSError.UnwrapErr"></span>    UnwrapErr   <a href="/pkg/builtin/#error">error</a>  <span class="comment">// error returned by the [DNSError.Unwrap] method, might be nil; added in Go 1.23</span>
<span id="DNSError.Err"></span>    Err         <a href="/pkg/builtin/#string">string</a> <span class="comment">// description of the error</span>
<span id="DNSError.Name"></span>    Name        <a href="/pkg/builtin/#string">string</a> <span class="comment">// name looked for</span>
<span id="DNSError.Server"></span>    Server      <a href="/pkg/builtin/#string">string</a> <span class="comment">// server used</span>
<span id="DNSError.IsTimeout"></span>    IsTimeout   <a href="/pkg/builtin/#bool">bool</a>   <span class="comment">// if true, timed out; not all timeouts set this</span>
<span id="DNSError.IsTemporary"></span>    IsTemporary <a href="/pkg/builtin/#bool">bool</a>   <span class="comment">// if true, error is temporary; not all errors set this; added in Go 1.6</span>

<span id="DNSError.IsNotFound"></span>    <span class="comment">// IsNotFound is set to true when the requested name does not</span>
    <span class="comment">// contain any records of the requested type (data not found),</span>
    <span class="comment">// or the name itself was not found (NXDOMAIN).</span>
    IsNotFound <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// Go 1.13</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="DNSError.Error">func (*DNSError) <a href="/src/net/net.go?s=22616:22649#L697">Error</a>
					<a class="permalink" href="#DNSError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#DNSError">DNSError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="DNSError.Temporary">func (*DNSError) <a href="/src/net/net.go?s=23256:23291#L717">Temporary</a>
					<a class="permalink" href="#DNSError.Temporary">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#DNSError">DNSError</a>) Temporary() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Temporary reports whether the DNS error is known to be temporary.
This is not always known; a DNS lookup may fail due to a temporary
error and return a <a href="#DNSError">DNSError</a> for which Temporary returns false.

				
				
				
			
				
				<h3 id="DNSError.Timeout">func (*DNSError) <a href="/src/net/net.go?s=22991:23024#L712">Timeout</a>
					<a class="permalink" href="#DNSError.Timeout">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#DNSError">DNSError</a>) Timeout() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Timeout reports whether the DNS lookup is known to have timed out.
This is not always known; a DNS lookup may fail due to a timeout
and return a <a href="#DNSError">DNSError</a> for which Timeout returns false.

				
				
				
			
				
				<h3 id="DNSError.Unwrap">func (*DNSError) <a href="/src/net/net.go?s=22558:22591#L695">Unwrap</a>
					<a class="permalink" href="#DNSError.Unwrap">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (e *<a href="#DNSError">DNSError</a>) Unwrap() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Unwrap returns e.UnwrapErr.

				
				
				
			
		
			
			
			<h2 id="Dialer">type <a href="/src/net/dial.go?s=1857:5830#L68">Dialer</a>
				<a class="permalink" href="#Dialer">&#xb6;</a>
				
				<span title="Added in Go 1.1">1.1</span>
			</h2>
			<p>A Dialer contains options for connecting to an address.
<p>The zero value for each field is equivalent to dialing
without that option. Dialing with the zero value of Dialer
is therefore equivalent to just calling the <a href="#Dial">Dial</a> function.
<p>It is safe to call Dialer&apos;s methods concurrently.

			<pre>type Dialer struct {
<span id="Dialer.Timeout"></span>    <span class="comment">// Timeout is the maximum amount of time a dial will wait for</span>
    <span class="comment">// a connect to complete. If Deadline is also set, it may fail</span>
    <span class="comment">// earlier.</span>
    <span class="comment">//</span>
    <span class="comment">// The default is no timeout.</span>
    <span class="comment">//</span>
    <span class="comment">// When using TCP and dialing a host name with multiple IP</span>
    <span class="comment">// addresses, the timeout may be divided between them.</span>
    <span class="comment">//</span>
    <span class="comment">// With or without a timeout, the operating system may impose</span>
    <span class="comment">// its own earlier timeout. For instance, TCP timeouts are</span>
    <span class="comment">// often around 3 minutes.</span>
    Timeout <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a>

<span id="Dialer.Deadline"></span>    <span class="comment">// Deadline is the absolute point in time after which dials</span>
    <span class="comment">// will fail. If Timeout is set, it may fail earlier.</span>
    <span class="comment">// Zero means no deadline, or dependent on the operating system</span>
    <span class="comment">// as with the Timeout option.</span>
    Deadline <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>

<span id="Dialer.LocalAddr"></span>    <span class="comment">// LocalAddr is the local address to use when dialing an</span>
    <span class="comment">// address. The address must be of a compatible type for the</span>
    <span class="comment">// network being dialed.</span>
    <span class="comment">// If nil, a local address is automatically chosen.</span>
    LocalAddr <a href="#Addr">Addr</a>

<span id="Dialer.DualStack"></span>    <span class="comment">// DualStack previously enabled RFC 6555 Fast Fallback</span>
    <span class="comment">// support, also known as &#34;Happy Eyeballs&#34;, in which IPv4 is</span>
    <span class="comment">// tried soon if IPv6 appears to be misconfigured and</span>
    <span class="comment">// hanging.</span>
    <span class="comment">//</span>
    <span class="comment">// Deprecated: Fast Fallback is enabled by default. To</span>
    <span class="comment">// disable, set FallbackDelay to a negative value.</span>
    DualStack <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// Go 1.2</span>

<span id="Dialer.FallbackDelay"></span>    <span class="comment">// FallbackDelay specifies the length of time to wait before</span>
    <span class="comment">// spawning a RFC 6555 Fast Fallback connection. That is, this</span>
    <span class="comment">// is the amount of time to wait for IPv6 to succeed before</span>
    <span class="comment">// assuming that IPv6 is misconfigured and falling back to</span>
    <span class="comment">// IPv4.</span>
    <span class="comment">//</span>
    <span class="comment">// If zero, a default delay of 300ms is used.</span>
    <span class="comment">// A negative value disables Fast Fallback support.</span>
    FallbackDelay <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a> <span class="comment">// Go 1.5</span>

<span id="Dialer.KeepAlive"></span>    <span class="comment">// KeepAlive specifies the interval between keep-alive</span>
    <span class="comment">// probes for an active network connection.</span>
    <span class="comment">//</span>
    <span class="comment">// KeepAlive is ignored if KeepAliveConfig.Enable is true.</span>
    <span class="comment">//</span>
    <span class="comment">// If zero, keep-alive probes are sent with a default value</span>
    <span class="comment">// (currently 15 seconds), if supported by the protocol and operating</span>
    <span class="comment">// system. Network protocols or operating systems that do</span>
    <span class="comment">// not support keep-alive ignore this field.</span>
    <span class="comment">// If negative, keep-alive probes are disabled.</span>
    KeepAlive <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a> <span class="comment">// Go 1.3</span>

<span id="Dialer.KeepAliveConfig"></span>    <span class="comment">// KeepAliveConfig specifies the keep-alive probe configuration</span>
    <span class="comment">// for an active network connection, when supported by the</span>
    <span class="comment">// protocol and operating system.</span>
    <span class="comment">//</span>
    <span class="comment">// If KeepAliveConfig.Enable is true, keep-alive probes are enabled.</span>
    <span class="comment">// If KeepAliveConfig.Enable is false and KeepAlive is negative,</span>
    <span class="comment">// keep-alive probes are disabled.</span>
    KeepAliveConfig <a href="#KeepAliveConfig">KeepAliveConfig</a> <span class="comment">// Go 1.23</span>

<span id="Dialer.Resolver"></span>    <span class="comment">// Resolver optionally specifies an alternate resolver to use.</span>
    Resolver *<a href="#Resolver">Resolver</a> <span class="comment">// Go 1.8</span>

<span id="Dialer.Cancel"></span>    <span class="comment">// Cancel is an optional channel whose closure indicates that</span>
    <span class="comment">// the dial should be canceled. Not all types of dials support</span>
    <span class="comment">// cancellation.</span>
    <span class="comment">//</span>
    <span class="comment">// Deprecated: Use DialContext instead.</span>
    Cancel &lt;-chan struct{} <span class="comment">// Go 1.6</span>

    <span class="comment">// If Control is not nil, it is called after creating the network</span>
    <span class="comment">// connection but before actually dialing.</span>
    <span class="comment">//</span>
    <span class="comment">// Network and address parameters passed to Control function are not</span>
    <span class="comment">// necessarily the ones passed to Dial. For example, passing &#34;tcp&#34; to Dial</span>
    <span class="comment">// will cause the Control function to be called with &#34;tcp4&#34; or &#34;tcp6&#34;.</span>
    <span class="comment">//</span>
<span id="Dialer.Control"></span>    <span class="comment">// Control is ignored if ControlContext is not nil.</span>
    Control func(network, address <a href="/pkg/builtin/#string">string</a>, c <a href="/pkg/syscall/">syscall</a>.<a href="/pkg/syscall/#RawConn">RawConn</a>) <a href="/pkg/builtin/#error">error</a> <span class="comment">// Go 1.11</span>

    <span class="comment">// If ControlContext is not nil, it is called after creating the network</span>
    <span class="comment">// connection but before actually dialing.</span>
    <span class="comment">//</span>
    <span class="comment">// Network and address parameters passed to ControlContext function are not</span>
    <span class="comment">// necessarily the ones passed to Dial. For example, passing &#34;tcp&#34; to Dial</span>
    <span class="comment">// will cause the ControlContext function to be called with &#34;tcp4&#34; or &#34;tcp6&#34;.</span>
    <span class="comment">//</span>
    <span class="comment">// If ControlContext is not nil, Control is ignored.</span>
<span id="Dialer.ControlContext"></span>    ControlContext func(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, network, address <a href="/pkg/builtin/#string">string</a>, c <a href="/pkg/syscall/">syscall</a>.<a href="/pkg/syscall/#RawConn">RawConn</a>) <a href="/pkg/builtin/#error">error</a> <span class="comment">// Go 1.20</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			<div id="example_Dialer" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
var d net.Dialer
ctx, cancel := context.WithTimeout(context.Background(), time.Minute)
defer cancel()

conn, err := d.DialContext(ctx, &#34;tcp&#34;, &#34;localhost:12345&#34;)
if err != nil {
    log.Fatalf(&#34;Failed to dial: %v&#34;, err)
}
defer conn.Close()

if _, err := conn.Write([]byte(&#34;Hello, World!&#34;)); err != nil {
    log.Fatal(err)
}
</pre>
			
		
	</div>
</div>
<div id="example_Dialer_unix" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (Unix)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (Unix)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// DialUnix does not take a context.Context parameter. This example shows</span>
<span class="comment">// how to dial a Unix socket with a Context. Note that the Context only</span>
<span class="comment">// applies to the dial operation; it does not apply to the connection once</span>
<span class="comment">// it has been established.</span>
var d net.Dialer
ctx, cancel := context.WithTimeout(context.Background(), time.Minute)
defer cancel()

d.LocalAddr = nil <span class="comment">// if you have a local addr, add it here</span>
raddr := net.UnixAddr{Name: &#34;/path/to/unix.sock&#34;, Net: &#34;unix&#34;}
conn, err := d.DialContext(ctx, &#34;unix&#34;, raddr.String())
if err != nil {
    log.Fatalf(&#34;Failed to dial: %v&#34;, err)
}
defer conn.Close()
if _, err := conn.Write([]byte(&#34;Hello, socket!&#34;)); err != nil {
    log.Fatal(err)
}
</pre>
			
		
	</div>
</div>

			
			

			

			
				
				<h3 id="Dialer.Dial">func (*Dialer) <a href="/src/net/dial.go?s=13972:14032#L442">Dial</a>
					<a class="permalink" href="#Dialer.Dial">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (d *<a href="#Dialer">Dialer</a>) Dial(network, address <a href="/pkg/builtin/#string">string</a>) (<a href="#Conn">Conn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Dial connects to the address on the named network.
<p>See func Dial for a description of the network and address
parameters.
<p>Dial uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Dialer.DialContext">Dialer.DialContext</a>.

				
				
				
			
				
				<h3 id="Dialer.DialContext">func (*Dialer) <a href="/src/net/dial.go?s=14937:15025#L464">DialContext</a>
					<a class="permalink" href="#Dialer.DialContext">&#xb6;</a>
					
					<span title="Added in Go 1.7">1.7</span>
				</h3>
				<pre>func (d *<a href="#Dialer">Dialer</a>) DialContext(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, network, address <a href="/pkg/builtin/#string">string</a>) (<a href="#Conn">Conn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>DialContext connects to the address on the named network using
the provided context.
<p>The provided Context must be non-nil. If the context expires before
the connection is complete, an error is returned. Once successfully
connected, any expiration of the context will not affect the
connection.
<p>When using TCP, and the host in the address parameter resolves to multiple
network addresses, any dial timeout (from d.Timeout or ctx) is spread
over each consecutive dial, such that each is given an appropriate
fraction of the time to connect.
For example, if a host has 4 IP addresses and the timeout is 1 minute,
the connect to each single address will be given 15 seconds to complete
before trying the next one.
<p>See func <a href="#Dial">Dial</a> for a description of the network and address
parameters.

				
				
				
			
				
				<h3 id="Dialer.MultipathTCP">func (*Dialer) <a href="/src/net/dial.go?s=10432:10468#L346">MultipathTCP</a>
					<a class="permalink" href="#Dialer.MultipathTCP">&#xb6;</a>
					
					<span title="Added in Go 1.21">1.21</span>
				</h3>
				<pre>func (d *<a href="#Dialer">Dialer</a>) MultipathTCP() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>MultipathTCP reports whether MPTCP will be used.
<p>This method doesn&apos;t check if MPTCP is supported by the operating
system or not.

				
				
				
			
				
				<h3 id="Dialer.SetMultipathTCP">func (*Dialer) <a href="/src/net/dial.go?s=10828:10870#L356">SetMultipathTCP</a>
					<a class="permalink" href="#Dialer.SetMultipathTCP">&#xb6;</a>
					
					<span title="Added in Go 1.21">1.21</span>
				</h3>
				<pre>func (d *<a href="#Dialer">Dialer</a>) SetMultipathTCP(use <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>SetMultipathTCP directs the <a href="#Dial">Dial</a> methods to use, or not use, MPTCP,
if supported by the operating system. This method overrides the
system default and the GODEBUG=multipathtcp=... setting if any.
<p>If MPTCP is not available on the host or not supported by the server,
the Dial methods will fall back to TCP.

				
				
				
			
		
			
			
			<h2 id="Error">type <a href="/src/net/net.go?s=14371:14628#L405">Error</a>
				<a class="permalink" href="#Error">&#xb6;</a>
				
				
			</h2>
			<p>An Error represents a network error.

			<pre>type Error interface {
    <a href="/pkg/builtin/#error">error</a>
    Timeout() <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// Is the error a timeout?</span>

    <span class="comment">// Deprecated: Temporary errors are not well-defined.</span>
    <span class="comment">// Most &#34;temporary&#34; errors are timeouts, and the few exceptions are surprising.</span>
    <span class="comment">// Do not use this method.</span>
    Temporary() <a href="/pkg/builtin/#bool">bool</a>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Flags">type <a href="/src/net/interface.go?s=1663:1678#L40">Flags</a>
				<a class="permalink" href="#Flags">&#xb6;</a>
				
				
			</h2>
			
			<pre>type Flags <a href="/pkg/builtin/#uint">uint</a></pre>

			
				
				<pre>const (
    <span id="FlagUp">FlagUp</span>           <a href="#Flags">Flags</a> = 1 &lt;&lt; <a href="/pkg/builtin/#iota">iota</a> <span class="comment">// interface is administratively up</span>
    <span id="FlagBroadcast">FlagBroadcast</span>                      <span class="comment">// interface supports broadcast access capability</span>
    <span id="FlagLoopback">FlagLoopback</span>                       <span class="comment">// interface is a loopback interface</span>
    <span id="FlagPointToPoint">FlagPointToPoint</span>                   <span class="comment">// interface belongs to a point-to-point link</span>
    <span id="FlagMulticast">FlagMulticast</span>                      <span class="comment">// interface supports multicast access capability</span>
    <span id="FlagRunning">FlagRunning</span>                        <span class="comment">// interface is in running state</span>
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="Flags.String">func (Flags) <a href="/src/net/interface.go?s=2265:2295#L60">String</a>
					<a class="permalink" href="#Flags.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (f <a href="#Flags">Flags</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="HardwareAddr">type <a href="/src/net/mac.go?s=268:292#L1">HardwareAddr</a>
				<a class="permalink" href="#HardwareAddr">&#xb6;</a>
				
				
			</h2>
			<p>A HardwareAddr represents a physical hardware address.

			<pre>type HardwareAddr []<a href="/pkg/builtin/#byte">byte</a></pre>

			

			

			
			
			

			
				
				<h3 id="ParseMAC">func <a href="/src/net/mac.go?s=1038:1090#L29">ParseMAC</a>
					<a class="permalink" href="#ParseMAC">&#xb6;</a>
					
					
				</h3>
				<pre>func ParseMAC(s <a href="/pkg/builtin/#string">string</a>) (hw <a href="#HardwareAddr">HardwareAddr</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet
IP over InfiniBand link-layer address using one of the following formats:
<pre>00:00:5e:00:53:01
02:00:5e:10:00:00:00:01
00:00:00:00:fe:80:00:00:00:00:00:00:02:00:5e:10:00:00:00:01
00-00-5e-00-53-01
02-00-5e-10-00-00-00-01
00-00-00-00-fe-80-00-00-00-00-00-00-02-00-5e-10-00-00-00-01
0000.5e00.5301
0200.5e10.0000.0001
0000.0000.fe80.0000.0000.0000.0200.5e10.0000.0001
</pre>

				
				
			

			
				
				<h3 id="HardwareAddr.String">func (HardwareAddr) <a href="/src/net/mac.go?s=294:331#L2">String</a>
					<a class="permalink" href="#HardwareAddr.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a <a href="#HardwareAddr">HardwareAddr</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="IP">type <a href="/src/net/ip.go?s=1005:1019#L27">IP</a>
				<a class="permalink" href="#IP">&#xb6;</a>
				
				
			</h2>
			<p>An IP is a single IP address, a slice of bytes.
Functions in this package accept either 4-byte (IPv4)
or 16-byte (IPv6) slices as input.
<p>Note that in this documentation, referring to an
IP address as an IPv4 address or an IPv6 address
is a semantic property of the address, not just the
length of the byte slice: a 16-byte slice can still
be an IPv4 address.

			<pre>type IP []<a href="/pkg/builtin/#byte">byte</a></pre>

			

			

			<div id="example_IP_to4" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (To4)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (To4)</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">ipv6 := net.IP{0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
ipv4 := net.IPv4(10, 255, 0, 0)

fmt.Println(ipv6.To4())
fmt.Println(ipv4.To4())

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">&lt;nil&gt;
10.255.0.0
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="IPv4">func <a href="/src/net/ip.go?s=1404:1433#L43">IPv4</a>
					<a class="permalink" href="#IPv4">&#xb6;</a>
					
					
				</h3>
				<pre>func IPv4(a, b, c, d <a href="/pkg/builtin/#byte">byte</a>) <a href="#IP">IP</a></pre>
				<p>IPv4 returns the IP address (in 16-byte form) of the
IPv4 address a.b.c.d.

				<div id="example_IPv4" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(net.IPv4(8, 8, 8, 8))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">8.8.8.8
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="LookupIP">func <a href="/src/net/lookup.go?s=6831:6871#L195">LookupIP</a>
					<a class="permalink" href="#LookupIP">&#xb6;</a>
					
					
				</h3>
				<pre>func LookupIP(host <a href="/pkg/builtin/#string">string</a>) ([]<a href="#IP">IP</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LookupIP looks up host using the local resolver.
It returns a slice of that host&apos;s IPv4 and IPv6 addresses.

				
				
			
				
				<h3 id="ParseIP">func <a href="/src/net/ip.go?s=13019:13044#L486">ParseIP</a>
					<a class="permalink" href="#ParseIP">&#xb6;</a>
					
					
				</h3>
				<pre>func ParseIP(s <a href="/pkg/builtin/#string">string</a>) <a href="#IP">IP</a></pre>
				<p>ParseIP parses s as an IP address, returning the result.
The string s can be in IPv4 dotted decimal (&quot;192.0.2.1&quot;), IPv6
(&quot;2001:db8::68&quot;), or IPv4-mapped IPv6 (&quot;::ffff:192.0.2.1&quot;) form.
If s is not a valid textual representation of an IP address,
ParseIP returns nil. The returned address is always 16 bytes,
IPv4 addresses are returned in IPv4-mapped IPv6 form.

				<div id="example_ParseIP" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(net.ParseIP(&#34;192.0.2.1&#34;))
fmt.Println(net.ParseIP(&#34;2001:db8::68&#34;))
fmt.Println(net.ParseIP(&#34;192.0.2&#34;))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">192.0.2.1
2001:db8::68
&lt;nil&gt;
</pre>
			
		
	</div>
</div>

				
			

			
				
				<h3 id="IP.DefaultMask">func (IP) <a href="/src/net/ip.go?s=7055:7088#L238">DefaultMask</a>
					<a class="permalink" href="#IP.DefaultMask">&#xb6;</a>
					
					
				</h3>
				<pre>func (ip <a href="#IP">IP</a>) DefaultMask() <a href="#IPMask">IPMask</a></pre>
				<p>DefaultMask returns the default IP mask for the IP address ip.
Only IPv4 addresses have default masks; DefaultMask returns
nil if ip is not a valid IPv4 address.

				
				<div id="example_IP_DefaultMask" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">ip := net.ParseIP(&#34;192.0.2.1&#34;)
fmt.Println(ip.DefaultMask())

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">ffffff00
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="IP.Equal">func (IP) <a href="/src/net/ip.go?s=9805:9834#L350">Equal</a>
					<a class="permalink" href="#IP.Equal">&#xb6;</a>
					
					
				</h3>
				<pre>func (ip <a href="#IP">IP</a>) Equal(x <a href="#IP">IP</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Equal reports whether ip and x are the same IP address.
An IPv4 address and that same address in IPv6 form are
considered to be equal.

				
				<div id="example_IP_Equal" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">ipv4DNS := net.ParseIP(&#34;8.8.8.8&#34;)
ipv4Lo := net.ParseIP(&#34;127.0.0.1&#34;)
ipv6DNS := net.ParseIP(&#34;0:0:0:0:0:FFFF:0808:0808&#34;)

fmt.Println(ipv4DNS.Equal(ipv4DNS))
fmt.Println(ipv4DNS.Equal(ipv4Lo))
fmt.Println(ipv4DNS.Equal(ipv6DNS))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
true
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="IP.IsGlobalUnicast">func (IP) <a href="/src/net/ip.go?s=5778:5813#L182">IsGlobalUnicast</a>
					<a class="permalink" href="#IP.IsGlobalUnicast">&#xb6;</a>
					
					
				</h3>
				<pre>func (ip <a href="#IP">IP</a>) IsGlobalUnicast() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsGlobalUnicast reports whether ip is a global unicast
address.
<p>The identification of global unicast addresses uses address type
identification as defined in RFC 1122, RFC 4632 and RFC 4291 with
the exception of IPv4 directed broadcast addresses.
It returns true even if ip is in IPv4 private address space or
local IPv6 unicast address space.

				
				<div id="example_IP_IsGlobalUnicast" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">ipv6Global := net.ParseIP(&#34;2000::&#34;)
ipv6UniqLocal := net.ParseIP(&#34;2000::&#34;)
ipv6Multi := net.ParseIP(&#34;FF00::&#34;)

ipv4Private := net.ParseIP(&#34;10.255.0.0&#34;)
ipv4Public := net.ParseIP(&#34;8.8.8.8&#34;)
ipv4Broadcast := net.ParseIP(&#34;255.255.255.255&#34;)

fmt.Println(ipv6Global.IsGlobalUnicast())
fmt.Println(ipv6UniqLocal.IsGlobalUnicast())
fmt.Println(ipv6Multi.IsGlobalUnicast())

fmt.Println(ipv4Private.IsGlobalUnicast())
fmt.Println(ipv4Public.IsGlobalUnicast())
fmt.Println(ipv4Broadcast.IsGlobalUnicast())

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
true
false
true
true
false
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="IP.IsInterfaceLocalMulticast">func (IP) <a href="/src/net/ip.go?s=4746:4791#L152">IsInterfaceLocalMulticast</a>
					<a class="permalink" href="#IP.IsInterfaceLocalMulticast">&#xb6;</a>
					
					
				</h3>
				<pre>func (ip <a href="#IP">IP</a>) IsInterfaceLocalMulticast() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsInterfaceLocalMulticast reports whether ip is
an interface-local multicast address.

				
				<div id="example_IP_IsInterfaceLocalMulticast" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">ipv6InterfaceLocalMulti := net.ParseIP(&#34;ff01::1&#34;)
ipv6Global := net.ParseIP(&#34;2000::&#34;)
ipv4 := net.ParseIP(&#34;255.0.0.0&#34;)

fmt.Println(ipv6InterfaceLocalMulti.IsInterfaceLocalMulticast())
fmt.Println(ipv6Global.IsInterfaceLocalMulticast())
fmt.Println(ipv4.IsInterfaceLocalMulticast())

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
false
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="IP.IsLinkLocalMulticast">func (IP) <a href="/src/net/ip.go?s=4944:4984#L158">IsLinkLocalMulticast</a>
					<a class="permalink" href="#IP.IsLinkLocalMulticast">&#xb6;</a>
					
					
				</h3>
				<pre>func (ip <a href="#IP">IP</a>) IsLinkLocalMulticast() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsLinkLocalMulticast reports whether ip is a link-local
multicast address.

				
				<div id="example_IP_IsLinkLocalMulticast" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">ipv6LinkLocalMulti := net.ParseIP(&#34;ff02::2&#34;)
ipv6LinkLocalUni := net.ParseIP(&#34;fe80::&#34;)
ipv4LinkLocalMulti := net.ParseIP(&#34;224.0.0.0&#34;)
ipv4LinkLocalUni := net.ParseIP(&#34;169.254.0.0&#34;)

fmt.Println(ipv6LinkLocalMulti.IsLinkLocalMulticast())
fmt.Println(ipv6LinkLocalUni.IsLinkLocalMulticast())
fmt.Println(ipv4LinkLocalMulti.IsLinkLocalMulticast())
fmt.Println(ipv4LinkLocalUni.IsLinkLocalMulticast())

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
true
false
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="IP.IsLinkLocalUnicast">func (IP) <a href="/src/net/ip.go?s=5223:5261#L167">IsLinkLocalUnicast</a>
					<a class="permalink" href="#IP.IsLinkLocalUnicast">&#xb6;</a>
					
					
				</h3>
				<pre>func (ip <a href="#IP">IP</a>) IsLinkLocalUnicast() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsLinkLocalUnicast reports whether ip is a link-local
unicast address.

				
				<div id="example_IP_IsLinkLocalUnicast" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">ipv6LinkLocalUni := net.ParseIP(&#34;fe80::&#34;)
ipv6Global := net.ParseIP(&#34;2000::&#34;)
ipv4LinkLocalUni := net.ParseIP(&#34;169.254.0.0&#34;)
ipv4LinkLocalMulti := net.ParseIP(&#34;224.0.0.0&#34;)

fmt.Println(ipv6LinkLocalUni.IsLinkLocalUnicast())
fmt.Println(ipv6Global.IsLinkLocalUnicast())
fmt.Println(ipv4LinkLocalUni.IsLinkLocalUnicast())
fmt.Println(ipv4LinkLocalMulti.IsLinkLocalUnicast())

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
true
false
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="IP.IsLoopback">func (IP) <a href="/src/net/ip.go?s=3422:3452#L116">IsLoopback</a>
					<a class="permalink" href="#IP.IsLoopback">&#xb6;</a>
					
					
				</h3>
				<pre>func (ip <a href="#IP">IP</a>) IsLoopback() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsLoopback reports whether ip is a loopback address.

				
				<div id="example_IP_IsLoopback" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">ipv6Lo := net.ParseIP(&#34;::1&#34;)
ipv6 := net.ParseIP(&#34;ff02::1&#34;)
ipv4Lo := net.ParseIP(&#34;127.0.0.0&#34;)
ipv4 := net.ParseIP(&#34;128.0.0.0&#34;)

fmt.Println(ipv6Lo.IsLoopback())
fmt.Println(ipv6.IsLoopback())
fmt.Println(ipv4Lo.IsLoopback())
fmt.Println(ipv4.IsLoopback())

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
true
false
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="IP.IsMulticast">func (IP) <a href="/src/net/ip.go?s=4507:4538#L143">IsMulticast</a>
					<a class="permalink" href="#IP.IsMulticast">&#xb6;</a>
					
					
				</h3>
				<pre>func (ip <a href="#IP">IP</a>) IsMulticast() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsMulticast reports whether ip is a multicast address.

				
				<div id="example_IP_IsMulticast" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">ipv6Multi := net.ParseIP(&#34;FF00::&#34;)
ipv6LinkLocalMulti := net.ParseIP(&#34;ff02::1&#34;)
ipv6Lo := net.ParseIP(&#34;::1&#34;)
ipv4Multi := net.ParseIP(&#34;239.0.0.0&#34;)
ipv4LinkLocalMulti := net.ParseIP(&#34;224.0.0.0&#34;)
ipv4Lo := net.ParseIP(&#34;127.0.0.0&#34;)

fmt.Println(ipv6Multi.IsMulticast())
fmt.Println(ipv6LinkLocalMulti.IsMulticast())
fmt.Println(ipv6Lo.IsMulticast())
fmt.Println(ipv4Multi.IsMulticast())
fmt.Println(ipv4LinkLocalMulti.IsMulticast())
fmt.Println(ipv4Lo.IsMulticast())

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
true
false
true
true
false
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="IP.IsPrivate">func (IP) <a href="/src/net/ip.go?s=3676:3705#L125">IsPrivate</a>
					<a class="permalink" href="#IP.IsPrivate">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (ip <a href="#IP">IP</a>) IsPrivate() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsPrivate reports whether ip is a private address, according to
RFC 1918 (IPv4 addresses) and RFC 4193 (IPv6 addresses).

				
				<div id="example_IP_IsPrivate" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">ipv6Private := net.ParseIP(&#34;fc00::&#34;)
ipv6Public := net.ParseIP(&#34;fe00::&#34;)
ipv4Private := net.ParseIP(&#34;10.255.0.0&#34;)
ipv4Public := net.ParseIP(&#34;11.0.0.0&#34;)

fmt.Println(ipv6Private.IsPrivate())
fmt.Println(ipv6Public.IsPrivate())
fmt.Println(ipv4Private.IsPrivate())
fmt.Println(ipv4Public.IsPrivate())

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
true
false
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="IP.IsUnspecified">func (IP) <a href="/src/net/ip.go?s=3271:3304#L111">IsUnspecified</a>
					<a class="permalink" href="#IP.IsUnspecified">&#xb6;</a>
					
					
				</h3>
				<pre>func (ip <a href="#IP">IP</a>) IsUnspecified() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsUnspecified reports whether ip is an unspecified address, either
the IPv4 address &quot;0.0.0.0&quot; or the IPv6 address &quot;::&quot;.

				
				<div id="example_IP_IsUnspecified" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">ipv6Unspecified := net.ParseIP(&#34;::&#34;)
ipv6Specified := net.ParseIP(&#34;fe00::&#34;)
ipv4Unspecified := net.ParseIP(&#34;0.0.0.0&#34;)
ipv4Specified := net.ParseIP(&#34;8.8.8.8&#34;)

fmt.Println(ipv6Unspecified.IsUnspecified())
fmt.Println(ipv6Specified.IsUnspecified())
fmt.Println(ipv4Unspecified.IsUnspecified())
fmt.Println(ipv4Specified.IsUnspecified())

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">true
false
true
false
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="IP.MarshalText">func (IP) <a href="/src/net/ip.go?s=9051:9093#L321">MarshalText</a>
					<a class="permalink" href="#IP.MarshalText">&#xb6;</a>
					
					<span title="Added in Go 1.2">1.2</span>
				</h3>
				<pre>func (ip <a href="#IP">IP</a>) MarshalText() ([]<a href="/pkg/builtin/#byte">byte</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>MarshalText implements the <a href="/encoding#TextMarshaler">encoding.TextMarshaler</a> interface.
The encoding is the same as returned by <a href="#IP.String">IP.String</a>, with one exception:
When len(ip) is zero, it returns an empty slice.

				
				
				
			
				
				<h3 id="IP.Mask">func (IP) <a href="/src/net/ip.go?s=7438:7471#L262">Mask</a>
					<a class="permalink" href="#IP.Mask">&#xb6;</a>
					
					
				</h3>
				<pre>func (ip <a href="#IP">IP</a>) Mask(mask <a href="#IPMask">IPMask</a>) <a href="#IP">IP</a></pre>
				<p>Mask returns the result of masking the IP address ip with mask.

				
				<div id="example_IP_Mask" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">ipv4Addr := net.ParseIP(&#34;192.0.2.1&#34;)
<span class="comment">// This mask corresponds to a /24 subnet for IPv4.</span>
ipv4Mask := net.CIDRMask(24, 32)
fmt.Println(ipv4Addr.Mask(ipv4Mask))

ipv6Addr := net.ParseIP(&#34;2001:db8:a0b:12f0::1&#34;)
<span class="comment">// This mask corresponds to a /32 subnet for IPv6.</span>
ipv6Mask := net.CIDRMask(32, 128)
fmt.Println(ipv6Addr.Mask(ipv6Mask))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">192.0.2.0
2001:db8::
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="IP.String">func (IP) <a href="/src/net/ip.go?s=8178:8206#L286">String</a>
					<a class="permalink" href="#IP.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (ip <a href="#IP">IP</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>String returns the string form of the IP address ip.
It returns one of 4 forms:
<ul>
<li>&quot;&lt;nil&gt;&quot;, if ip has length 0
<li>dotted decimal (&quot;192.0.2.1&quot;), if ip is an IPv4 or IP4-mapped IPv6 address
<li>IPv6 conforming to RFC 5952 (&quot;2001:db8::1&quot;), if ip is a valid IPv6 address
<li>the hexadecimal form of ip, without punctuation, if no other cases apply
</ul>

				
				<div id="example_IP_String" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">ipv6 := net.IP{0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
ipv4 := net.IPv4(10, 255, 0, 0)

fmt.Println(ipv6.String())
fmt.Println(ipv4.String())

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">fc00::
10.255.0.0
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="IP.To16">func (IP) <a href="/src/net/ip.go?s=6569:6591#L218">To16</a>
					<a class="permalink" href="#IP.To16">&#xb6;</a>
					
					
				</h3>
				<pre>func (ip <a href="#IP">IP</a>) To16() <a href="#IP">IP</a></pre>
				<p>To16 converts the IP address ip to a 16-byte representation.
If ip is not an IP address (it is the wrong length), To16 returns nil.

				
				<div id="example_IP_To16" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">ipv6 := net.IP{0xfc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
ipv4 := net.IPv4(10, 255, 0, 0)

fmt.Println(ipv6.To16())
fmt.Println(ipv4.To16())

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">fc00::
10.255.0.0
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="IP.To4">func (IP) <a href="/src/net/ip.go?s=6242:6263#L203">To4</a>
					<a class="permalink" href="#IP.To4">&#xb6;</a>
					
					
				</h3>
				<pre>func (ip <a href="#IP">IP</a>) To4() <a href="#IP">IP</a></pre>
				<p>To4 converts the IPv4 address ip to a 4-byte representation.
If ip is not an IPv4 address, To4 returns nil.

				
				
				
			
				
				<h3 id="IP.UnmarshalText">func (*IP) <a href="/src/net/ip.go?s=9435:9481#L333">UnmarshalText</a>
					<a class="permalink" href="#IP.UnmarshalText">&#xb6;</a>
					
					<span title="Added in Go 1.2">1.2</span>
				</h3>
				<pre>func (ip *<a href="#IP">IP</a>) UnmarshalText(text []<a href="/pkg/builtin/#byte">byte</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>UnmarshalText implements the <a href="/encoding#TextUnmarshaler">encoding.TextUnmarshaler</a> interface.
The IP address is expected in a form accepted by <a href="#ParseIP">ParseIP</a>.

				
				
				
			
		
			
			
			<h2 id="IPAddr">type <a href="/src/net/iprawsock.go?s=1003:1078#L21">IPAddr</a>
				<a class="permalink" href="#IPAddr">&#xb6;</a>
				
				
			</h2>
			<p>IPAddr represents the address of an IP end point.

			<pre>type IPAddr struct {
<span id="IPAddr.IP"></span>    IP   <a href="#IP">IP</a>
<span id="IPAddr.Zone"></span>    Zone <a href="/pkg/builtin/#string">string</a> <span class="comment">// IPv6 scoped addressing zone; added in Go 1.1</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="ResolveIPAddr">func <a href="/src/net/iprawsock.go?s=2069:2129#L67">ResolveIPAddr</a>
					<a class="permalink" href="#ResolveIPAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func ResolveIPAddr(network, address <a href="/pkg/builtin/#string">string</a>) (*<a href="#IPAddr">IPAddr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ResolveIPAddr returns an address of IP end point.
<p>The network must be an IP network name.
<p>If the host in the address parameter is not a literal IP address,
ResolveIPAddr resolves the address to an address of IP end point.
Otherwise, it parses the address as a literal IP address.
The address parameter can use a host name, but this is not
recommended, because it will return at most one of the host name&apos;s
IP addresses.
<p>See func <a href="#Dial">Dial</a> for a description of the network and address
parameters.

				
				
			

			
				
				<h3 id="IPAddr.Network">func (*IPAddr) <a href="/src/net/iprawsock.go?s=1133:1166#L27">Network</a>
					<a class="permalink" href="#IPAddr.Network">&#xb6;</a>
					
					
				</h3>
				<pre>func (a *<a href="#IPAddr">IPAddr</a>) Network() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Network returns the address&apos;s network name, &quot;ip&quot;.

				
				
				
			
				
				<h3 id="IPAddr.String">func (*IPAddr) <a href="/src/net/iprawsock.go?s=1184:1216#L29">String</a>
					<a class="permalink" href="#IPAddr.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a *<a href="#IPAddr">IPAddr</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="IPConn">type <a href="/src/net/iprawsock.go?s=2719:2747#L89">IPConn</a>
				<a class="permalink" href="#IPConn">&#xb6;</a>
				
				
			</h2>
			<p>IPConn is the implementation of the <a href="#Conn">Conn</a> and <a href="#PacketConn">PacketConn</a> interfaces
for IP network connections.

			<pre>type IPConn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="DialIP">func <a href="/src/net/iprawsock.go?s=6166:6232#L201">DialIP</a>
					<a class="permalink" href="#DialIP">&#xb6;</a>
					
					
				</h3>
				<pre>func DialIP(network <a href="/pkg/builtin/#string">string</a>, laddr, raddr *<a href="#IPAddr">IPAddr</a>) (*<a href="#IPConn">IPConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>DialIP acts like <a href="#Dial">Dial</a> for IP networks.
<p>The network must be an IP network name; see func Dial for details.
<p>If laddr is nil, a local address is automatically chosen.
If the IP field of raddr is nil or an unspecified IP address, the
local system is assumed.

				
				
			
				
				<h3 id="ListenIP">func <a href="/src/net/iprawsock.go?s=6925:6986#L220">ListenIP</a>
					<a class="permalink" href="#ListenIP">&#xb6;</a>
					
					
				</h3>
				<pre>func ListenIP(network <a href="/pkg/builtin/#string">string</a>, laddr *<a href="#IPAddr">IPAddr</a>) (*<a href="#IPConn">IPConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ListenIP acts like <a href="#ListenPacket">ListenPacket</a> for IP networks.
<p>The network must be an IP network name; see func Dial for details.
<p>If the IP field of laddr is nil or an unspecified IP address,
ListenIP listens on all available IP addresses of the local system
except multicast IP addresses.

				
				
			

			
				
				<h3 id="IPConn.Close">func (*IPConn) <a href="/src/net/net.go?s=7529:7557#L199">Close</a>
					<a class="permalink" href="#IPConn.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Close closes the connection.

				
				
				
			
				
				<h3 id="IPConn.File">func (*IPConn) <a href="/src/net/net.go?s=10192:10237#L294">File</a>
					<a class="permalink" href="#IPConn.File">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) File() (f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>File returns a copy of the underlying <a href="/os#File">os.File</a>.
It is the caller&apos;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
<p>The returned os.File&apos;s file descriptor is different from the connection&apos;s.
Attempting to change properties of the original using this duplicate
may or may not have the desired effect.

				
				
				
			
				
				<h3 id="IPConn.LocalAddr">func (*IPConn) <a href="/src/net/net.go?s=7886:7917#L213">LocalAddr</a>
					<a class="permalink" href="#IPConn.LocalAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) LocalAddr() <a href="#Addr">Addr</a></pre>
				<p>LocalAddr returns the local network address.
The Addr returned is shared by all invocations of LocalAddr, so
do not modify it.

				
				
				
			
				
				<h3 id="IPConn.Read">func (*IPConn) <a href="/src/net/net.go?s=6948:6990#L175">Read</a>
					<a class="permalink" href="#IPConn.Read">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) Read(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Read implements the Conn Read method.

				
				
				
			
				
				<h3 id="IPConn.ReadFrom">func (*IPConn) <a href="/src/net/iprawsock.go?s=3375:3429#L115">ReadFrom</a>
					<a class="permalink" href="#IPConn.ReadFrom">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) ReadFrom(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="#Addr">Addr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadFrom implements the <a href="#PacketConn">PacketConn</a> ReadFrom method.

				
				
				
			
				
				<h3 id="IPConn.ReadFromIP">func (*IPConn) <a href="/src/net/iprawsock.go?s=3040:3099#L103">ReadFromIP</a>
					<a class="permalink" href="#IPConn.ReadFromIP">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) ReadFromIP(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, *<a href="#IPAddr">IPAddr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadFromIP acts like ReadFrom but returns an IPAddr.

				
				
				
			
				
				<h3 id="IPConn.ReadMsgIP">func (*IPConn) <a href="/src/net/iprawsock.go?s=4098:4185#L136">ReadMsgIP</a>
					<a class="permalink" href="#IPConn.ReadMsgIP">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) ReadMsgIP(b, oob []<a href="/pkg/builtin/#byte">byte</a>) (n, oobn, flags <a href="/pkg/builtin/#int">int</a>, addr *<a href="#IPAddr">IPAddr</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadMsgIP reads a message from c, copying the payload into b and
the associated out-of-band data into oob. It returns the number of
bytes copied into b, the number of bytes copied into oob, the flags
that were set on the message and the source address of the message.
<p>The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be
used to manipulate IP-level socket options in oob.

				
				
				
			
				
				<h3 id="IPConn.RemoteAddr">func (*IPConn) <a href="/src/net/net.go?s=8111:8143#L223">RemoteAddr</a>
					<a class="permalink" href="#IPConn.RemoteAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) RemoteAddr() <a href="#Addr">Addr</a></pre>
				<p>RemoteAddr returns the remote network address.
The Addr returned is shared by all invocations of RemoteAddr, so
do not modify it.

				
				
				
			
				
				<h3 id="IPConn.SetDeadline">func (*IPConn) <a href="/src/net/net.go?s=8253:8298#L231">SetDeadline</a>
					<a class="permalink" href="#IPConn.SetDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetDeadline implements the Conn SetDeadline method.

				
				
				
			
				
				<h3 id="IPConn.SetReadBuffer">func (*IPConn) <a href="/src/net/net.go?s=9217:9262#L265">SetReadBuffer</a>
					<a class="permalink" href="#IPConn.SetReadBuffer">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) SetReadBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetReadBuffer sets the size of the operating system&apos;s
receive buffer associated with the connection.

				
				
				
			
				
				<h3 id="IPConn.SetReadDeadline">func (*IPConn) <a href="/src/net/net.go?s=8553:8602#L242">SetReadDeadline</a>
					<a class="permalink" href="#IPConn.SetReadDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) SetReadDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetReadDeadline implements the Conn SetReadDeadline method.

				
				
				
			
				
				<h3 id="IPConn.SetWriteBuffer">func (*IPConn) <a href="/src/net/net.go?s=9570:9616#L277">SetWriteBuffer</a>
					<a class="permalink" href="#IPConn.SetWriteBuffer">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) SetWriteBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetWriteBuffer sets the size of the operating system&apos;s
transmit buffer associated with the connection.

				
				
				
			
				
				<h3 id="IPConn.SetWriteDeadline">func (*IPConn) <a href="/src/net/net.go?s=8863:8913#L253">SetWriteDeadline</a>
					<a class="permalink" href="#IPConn.SetWriteDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) SetWriteDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetWriteDeadline implements the Conn SetWriteDeadline method.

				
				
				
			
				
				<h3 id="IPConn.SyscallConn">func (*IPConn) <a href="/src/net/iprawsock.go?s=2847:2902#L95">SyscallConn</a>
					<a class="permalink" href="#IPConn.SyscallConn">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) SyscallConn() (<a href="/pkg/syscall/">syscall</a>.<a href="/pkg/syscall/#RawConn">RawConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>SyscallConn returns a raw network connection.
This implements the <a href="/syscall#Conn">syscall.Conn</a> interface.

				
				
				
			
				
				<h3 id="IPConn.Write">func (*IPConn) <a href="/src/net/net.go?s=7251:7294#L187">Write</a>
					<a class="permalink" href="#IPConn.Write">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) Write(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Write implements the Conn Write method.

				
				
				
			
				
				<h3 id="IPConn.WriteMsgIP">func (*IPConn) <a href="/src/net/iprawsock.go?s=5525:5606#L181">WriteMsgIP</a>
					<a class="permalink" href="#IPConn.WriteMsgIP">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) WriteMsgIP(b, oob []<a href="/pkg/builtin/#byte">byte</a>, addr *<a href="#IPAddr">IPAddr</a>) (n, oobn <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteMsgIP writes a message to addr via c, copying the payload from
b and the associated out-of-band data from oob. It returns the
number of payload and out-of-band bytes written.
<p>The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be
used to manipulate IP-level socket options in oob.

				
				
				
			
				
				<h3 id="IPConn.WriteTo">func (*IPConn) <a href="/src/net/iprawsock.go?s=4805:4863#L160">WriteTo</a>
					<a class="permalink" href="#IPConn.WriteTo">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) WriteTo(b []<a href="/pkg/builtin/#byte">byte</a>, addr <a href="#Addr">Addr</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteTo implements the <a href="#PacketConn">PacketConn</a> WriteTo method.

				
				
				
			
				
				<h3 id="IPConn.WriteToIP">func (*IPConn) <a href="/src/net/iprawsock.go?s=4476:4539#L148">WriteToIP</a>
					<a class="permalink" href="#IPConn.WriteToIP">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#IPConn">IPConn</a>) WriteToIP(b []<a href="/pkg/builtin/#byte">byte</a>, addr *<a href="#IPAddr">IPAddr</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteToIP acts like <a href="#IPConn.WriteTo">IPConn.WriteTo</a> but takes an <a href="#IPAddr">IPAddr</a>.

				
				
				
			
		
			
			
			<h2 id="IPMask">type <a href="/src/net/ip.go?s=1182:1200#L33">IPMask</a>
				<a class="permalink" href="#IPMask">&#xb6;</a>
				
				
			</h2>
			<p>An IPMask is a bitmask that can be used to manipulate
IP addresses for IP addressing and routing.
<p>See type <a href="#IPNet">IPNet</a> and func <a href="#ParseCIDR">ParseCIDR</a> for details.

			<pre>type IPMask []<a href="/pkg/builtin/#byte">byte</a></pre>

			

			

			
			
			

			
				
				<h3 id="CIDRMask">func <a href="/src/net/ip.go?s=1993:2029#L69">CIDRMask</a>
					<a class="permalink" href="#CIDRMask">&#xb6;</a>
					
					
				</h3>
				<pre>func CIDRMask(ones, bits <a href="/pkg/builtin/#int">int</a>) <a href="#IPMask">IPMask</a></pre>
				<p>CIDRMask returns an <a href="#IPMask">IPMask</a> consisting of &apos;ones&apos; 1 bits
followed by 0s up to a total length of &apos;bits&apos; bits.
For a mask of this form, CIDRMask is the inverse of <a href="#IPMask.Size">IPMask.Size</a>.

				<div id="example_CIDRMask" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// This mask corresponds to a /31 subnet for IPv4.</span>
fmt.Println(net.CIDRMask(31, 32))

<span class="comment">// This mask corresponds to a /64 subnet for IPv6.</span>
fmt.Println(net.CIDRMask(64, 128))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">fffffffe
ffffffffffffffff0000000000000000
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="IPv4Mask">func <a href="/src/net/ip.go?s=1687:1724#L57">IPv4Mask</a>
					<a class="permalink" href="#IPv4Mask">&#xb6;</a>
					
					
				</h3>
				<pre>func IPv4Mask(a, b, c, d <a href="/pkg/builtin/#byte">byte</a>) <a href="#IPMask">IPMask</a></pre>
				<p>IPv4Mask returns the IP mask (in 4-byte form) of the
IPv4 mask a.b.c.d.

				<div id="example_IPv4Mask" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">fmt.Println(net.IPv4Mask(255, 255, 255, 0))

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">ffffff00
</pre>
			
		
	</div>
</div>

				
			

			
				
				<h3 id="IPMask.Size">func (IPMask) <a href="/src/net/ip.go?s=10937:10976#L399">Size</a>
					<a class="permalink" href="#IPMask.Size">&#xb6;</a>
					
					
				</h3>
				<pre>func (m <a href="#IPMask">IPMask</a>) Size() (ones, bits <a href="/pkg/builtin/#int">int</a>)</pre>
				<p>Size returns the number of leading ones and total bits in the mask.
If the mask is not in the canonical form--ones followed by zeros--then
Size returns 0, 0.

				
				
				
			
				
				<h3 id="IPMask.String">func (IPMask) <a href="/src/net/ip.go?s=11134:11165#L408">String</a>
					<a class="permalink" href="#IPMask.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (m <a href="#IPMask">IPMask</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>String returns the hexadecimal form of m, with no punctuation.

				
				
				
			
		
			
			
			<h2 id="IPNet">type <a href="/src/net/ip.go?s=1240:1321#L36">IPNet</a>
				<a class="permalink" href="#IPNet">&#xb6;</a>
				
				
			</h2>
			<p>An IPNet represents an IP network.

			<pre>type IPNet struct {
<span id="IPNet.IP"></span>    IP   <a href="#IP">IP</a>     <span class="comment">// network number</span>
<span id="IPNet.Mask"></span>    Mask <a href="#IPMask">IPMask</a> <span class="comment">// network mask</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="IPNet.Contains">func (*IPNet) <a href="/src/net/ip.go?s=11630:11666#L439">Contains</a>
					<a class="permalink" href="#IPNet.Contains">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#IPNet">IPNet</a>) Contains(ip <a href="#IP">IP</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Contains reports whether the network includes ip.

				
				
				
			
				
				<h3 id="IPNet.Network">func (*IPNet) <a href="/src/net/ip.go?s=11950:11982#L457">Network</a>
					<a class="permalink" href="#IPNet.Network">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#IPNet">IPNet</a>) Network() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Network returns the address&apos;s network name, &quot;ip+net&quot;.

				
				
				
			
				
				<h3 id="IPNet.String">func (*IPNet) <a href="/src/net/ip.go?s=12354:12385#L465">String</a>
					<a class="permalink" href="#IPNet.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (n *<a href="#IPNet">IPNet</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>String returns the CIDR notation of n like &quot;192.0.2.0/24&quot;
or &quot;2001:db8::/48&quot; as defined in RFC 4632 and RFC 4291.
If the mask is not in the canonical form, it returns the
string which consists of an IP address, followed by a slash
character and a mask expressed as hexadecimal form with no
punctuation like &quot;198.51.100.0/c000ff00&quot;.

				
				
				
			
		
			
			
			<h2 id="Interface">type <a href="/src/net/interface.go?s=1295:1661#L32">Interface</a>
				<a class="permalink" href="#Interface">&#xb6;</a>
				
				
			</h2>
			<p>Interface represents a mapping between network interface name
and index. It also represents network interface facility
information.

			<pre>type Interface struct {
<span id="Interface.Index"></span>    Index        <a href="/pkg/builtin/#int">int</a>          <span class="comment">// positive integer that starts at one, zero is never used</span>
<span id="Interface.MTU"></span>    MTU          <a href="/pkg/builtin/#int">int</a>          <span class="comment">// maximum transmission unit</span>
<span id="Interface.Name"></span>    Name         <a href="/pkg/builtin/#string">string</a>       <span class="comment">// e.g., &#34;en0&#34;, &#34;lo0&#34;, &#34;eth0.100&#34;</span>
<span id="Interface.HardwareAddr"></span>    HardwareAddr <a href="#HardwareAddr">HardwareAddr</a> <span class="comment">// IEEE MAC-48, EUI-48 and EUI-64 form</span>
<span id="Interface.Flags"></span>    Flags        <a href="#Flags">Flags</a>        <span class="comment">// e.g., FlagUp, FlagLoopback, FlagMulticast</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="InterfaceByIndex">func <a href="/src/net/interface.go?s=4245:4297#L132">InterfaceByIndex</a>
					<a class="permalink" href="#InterfaceByIndex">&#xb6;</a>
					
					
				</h3>
				<pre>func InterfaceByIndex(index <a href="/pkg/builtin/#int">int</a>) (*<a href="#Interface">Interface</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>InterfaceByIndex returns the interface specified by index.
<p>On Solaris, it returns one of the logical network interfaces
sharing the logical data link; for more precision use
<a href="#InterfaceByName">InterfaceByName</a>.

				
				
			
				
				<h3 id="InterfaceByName">func <a href="/src/net/interface.go?s=4974:5027#L157">InterfaceByName</a>
					<a class="permalink" href="#InterfaceByName">&#xb6;</a>
					
					
				</h3>
				<pre>func InterfaceByName(name <a href="/pkg/builtin/#string">string</a>) (*<a href="#Interface">Interface</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>InterfaceByName returns the interface specified by name.

				
				
			
				
				<h3 id="Interfaces">func <a href="/src/net/interface.go?s=3382:3420#L103">Interfaces</a>
					<a class="permalink" href="#Interfaces">&#xb6;</a>
					
					
				</h3>
				<pre>func Interfaces() ([]<a href="#Interface">Interface</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Interfaces returns a list of the system&apos;s network interfaces.

				
				
			

			
				
				<h3 id="Interface.Addrs">func (*Interface) <a href="/src/net/interface.go?s=2546:2591#L78">Addrs</a>
					<a class="permalink" href="#Interface.Addrs">&#xb6;</a>
					
					
				</h3>
				<pre>func (ifi *<a href="#Interface">Interface</a>) Addrs() ([]<a href="#Addr">Addr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Addrs returns a list of unicast interface addresses for a specific
interface.

				
				
				
			
				
				<h3 id="Interface.MulticastAddrs">func (*Interface) <a href="/src/net/interface.go?s=2972:3026#L91">MulticastAddrs</a>
					<a class="permalink" href="#Interface.MulticastAddrs">&#xb6;</a>
					
					
				</h3>
				<pre>func (ifi *<a href="#Interface">Interface</a>) MulticastAddrs() ([]<a href="#Addr">Addr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>MulticastAddrs returns a list of multicast, joined group addresses
for a specific interface.

				
				
				
			
		
			
			
			<h2 id="InvalidAddrError">type <a href="/src/net/net.go?s=18949:18977#L587">InvalidAddrError</a>
				<a class="permalink" href="#InvalidAddrError">&#xb6;</a>
				
				
			</h2>
			
			<pre>type InvalidAddrError <a href="/pkg/builtin/#string">string</a></pre>

			

			

			
			
			

			

			
				
				<h3 id="InvalidAddrError.Error">func (InvalidAddrError) <a href="/src/net/net.go?s=18979:19019#L589">Error</a>
					<a class="permalink" href="#InvalidAddrError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e <a href="#InvalidAddrError">InvalidAddrError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="InvalidAddrError.Temporary">func (InvalidAddrError) <a href="/src/net/net.go?s=19103:19145#L591">Temporary</a>
					<a class="permalink" href="#InvalidAddrError.Temporary">&#xb6;</a>
					
					
				</h3>
				<pre>func (e <a href="#InvalidAddrError">InvalidAddrError</a>) Temporary() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="InvalidAddrError.Timeout">func (InvalidAddrError) <a href="/src/net/net.go?s=19043:19083#L590">Timeout</a>
					<a class="permalink" href="#InvalidAddrError.Timeout">&#xb6;</a>
					
					
				</h3>
				<pre>func (e <a href="#InvalidAddrError">InvalidAddrError</a>) Timeout() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="KeepAliveConfig">type <a href="/src/net/tcpsock.go?s=3890:4456#L122">KeepAliveConfig</a>
				<a class="permalink" href="#KeepAliveConfig">&#xb6;</a>
				
				<span title="Added in Go 1.23">1.23</span>
			</h2>
			<p>KeepAliveConfig contains TCP keep-alive options.
<p>If the Idle, Interval, or Count fields are zero, a default value is chosen.
If a field is negative, the corresponding socket-level option will be left unchanged.
<p>Note that prior to Windows 10 version 1709, neither setting Idle and Interval
separately nor changing Count (which is usually 10) is supported.
Therefore, it&apos;s recommended to set both Idle and Interval to non-negative values
in conjunction with a -1 for Count on those old Windows if you intend to customize
the TCP keep-alive settings.
By contrast, if only one of Idle and Interval is set to a non-negative value,
the other will be set to the system default value, and ultimately,
set both Idle and Interval to negative values if you want to leave them unchanged.
<p>Note that Solaris and its derivatives do not support setting Interval to a non-negative value
and Count to a negative value, or vice-versa.

			<pre>type KeepAliveConfig struct {
    <span class="comment">// If Enable is true, keep-alive probes are enabled.</span>
<span id="KeepAliveConfig.Enable"></span>    Enable <a href="/pkg/builtin/#bool">bool</a>

<span id="KeepAliveConfig.Idle"></span>    <span class="comment">// Idle is the time that the connection must be idle before</span>
    <span class="comment">// the first keep-alive probe is sent.</span>
    <span class="comment">// If zero, a default value of 15 seconds is used.</span>
    Idle <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a>

<span id="KeepAliveConfig.Interval"></span>    <span class="comment">// Interval is the time between keep-alive probes.</span>
    <span class="comment">// If zero, a default value of 15 seconds is used.</span>
    Interval <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a>

<span id="KeepAliveConfig.Count"></span>    <span class="comment">// Count is the maximum number of keep-alive probes that</span>
    <span class="comment">// can go unanswered before dropping a connection.</span>
    <span class="comment">// If zero, a default value of 9 is used.</span>
    Count <a href="/pkg/builtin/#int">int</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ListenConfig">type <a href="/src/net/dial.go?s=20787:22236#L681">ListenConfig</a>
				<a class="permalink" href="#ListenConfig">&#xb6;</a>
				
				<span title="Added in Go 1.11">1.11</span>
			</h2>
			<p>ListenConfig contains options for listening to an address.

			<pre>type ListenConfig struct {
    <span class="comment">// If Control is not nil, it is called after creating the network</span>
    <span class="comment">// connection but before binding it to the operating system.</span>
    <span class="comment">//</span>
    <span class="comment">// Network and address parameters passed to Control method are not</span>
    <span class="comment">// necessarily the ones passed to Listen. For example, passing &#34;tcp&#34; to</span>
    <span class="comment">// Listen will cause the Control function to be called with &#34;tcp4&#34; or &#34;tcp6&#34;.</span>
<span id="ListenConfig.Control"></span>    Control func(network, address <a href="/pkg/builtin/#string">string</a>, c <a href="/pkg/syscall/">syscall</a>.<a href="/pkg/syscall/#RawConn">RawConn</a>) <a href="/pkg/builtin/#error">error</a>

<span id="ListenConfig.KeepAlive"></span>    <span class="comment">// KeepAlive specifies the keep-alive period for network</span>
    <span class="comment">// connections accepted by this listener.</span>
    <span class="comment">//</span>
    <span class="comment">// KeepAlive is ignored if KeepAliveConfig.Enable is true.</span>
    <span class="comment">//</span>
    <span class="comment">// If zero, keep-alive are enabled if supported by the protocol</span>
    <span class="comment">// and operating system. Network protocols or operating systems</span>
    <span class="comment">// that do not support keep-alive ignore this field.</span>
    <span class="comment">// If negative, keep-alive are disabled.</span>
    KeepAlive <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a> <span class="comment">// Go 1.13</span>

<span id="ListenConfig.KeepAliveConfig"></span>    <span class="comment">// KeepAliveConfig specifies the keep-alive probe configuration</span>
    <span class="comment">// for an active network connection, when supported by the</span>
    <span class="comment">// protocol and operating system.</span>
    <span class="comment">//</span>
    <span class="comment">// If KeepAliveConfig.Enable is true, keep-alive probes are enabled.</span>
    <span class="comment">// If KeepAliveConfig.Enable is false and KeepAlive is negative,</span>
    <span class="comment">// keep-alive probes are disabled.</span>
    KeepAliveConfig <a href="#KeepAliveConfig">KeepAliveConfig</a> <span class="comment">// Go 1.23</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ListenConfig.Listen">func (*ListenConfig) <a href="/src/net/dial.go?s=22997:23091#L738">Listen</a>
					<a class="permalink" href="#ListenConfig.Listen">&#xb6;</a>
					
					<span title="Added in Go 1.11">1.11</span>
				</h3>
				<pre>func (lc *<a href="#ListenConfig">ListenConfig</a>) Listen(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, network, address <a href="/pkg/builtin/#string">string</a>) (<a href="#Listener">Listener</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Listen announces on the local network address.
<p>See func Listen for a description of the network and address
parameters.

				
				
				
			
				
				<h3 id="ListenConfig.ListenPacket">func (*ListenConfig) <a href="/src/net/dial.go?s=24097:24199#L772">ListenPacket</a>
					<a class="permalink" href="#ListenConfig.ListenPacket">&#xb6;</a>
					
					<span title="Added in Go 1.11">1.11</span>
				</h3>
				<pre>func (lc *<a href="#ListenConfig">ListenConfig</a>) ListenPacket(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, network, address <a href="/pkg/builtin/#string">string</a>) (<a href="#PacketConn">PacketConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ListenPacket announces on the local network address.
<p>See func ListenPacket for a description of the network and address
parameters.

				
				
				
			
				
				<h3 id="ListenConfig.MultipathTCP">func (*ListenConfig) <a href="/src/net/dial.go?s=22379:22422#L720">MultipathTCP</a>
					<a class="permalink" href="#ListenConfig.MultipathTCP">&#xb6;</a>
					
					<span title="Added in Go 1.21">1.21</span>
				</h3>
				<pre>func (lc *<a href="#ListenConfig">ListenConfig</a>) MultipathTCP() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>MultipathTCP reports whether MPTCP will be used.
<p>This method doesn&apos;t check if MPTCP is supported by the operating
system or not.

				
				
				
			
				
				<h3 id="ListenConfig.SetMultipathTCP">func (*ListenConfig) <a href="/src/net/dial.go?s=22785:22834#L730">SetMultipathTCP</a>
					<a class="permalink" href="#ListenConfig.SetMultipathTCP">&#xb6;</a>
					
					<span title="Added in Go 1.21">1.21</span>
				</h3>
				<pre>func (lc *<a href="#ListenConfig">ListenConfig</a>) SetMultipathTCP(use <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>SetMultipathTCP directs the <a href="#Listen">Listen</a> method to use, or not use, MPTCP,
if supported by the operating system. This method overrides the
system default and the GODEBUG=multipathtcp=... setting if any.
<p>If MPTCP is not available on the host or not supported by the client,
the Listen method will fall back to TCP.

				
				
				
			
		
			
			
			<h2 id="Listener">type <a href="/src/net/net.go?s=14027:14329#L392">Listener</a>
				<a class="permalink" href="#Listener">&#xb6;</a>
				
				
			</h2>
			<p>A Listener is a generic network listener for stream-oriented protocols.
<p>Multiple goroutines may invoke methods on a Listener simultaneously.

			<pre>type Listener interface {
    <span class="comment">// Accept waits for and returns the next connection to the listener.</span>
    Accept() (<a href="#Conn">Conn</a>, <a href="/pkg/builtin/#error">error</a>)

    <span class="comment">// Close closes the listener.</span>
    <span class="comment">// Any blocked Accept operations will be unblocked and return errors.</span>
    Close() <a href="/pkg/builtin/#error">error</a>

    <span class="comment">// Addr returns the listener&#39;s network address.</span>
    Addr() <a href="#Addr">Addr</a>
}</pre>

			

			

			<div id="example_Listener" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Listen on TCP port 2000 on all available unicast and</span>
<span class="comment">// anycast IP addresses of the local system.</span>
l, err := net.Listen(&#34;tcp&#34;, &#34;:2000&#34;)
if err != nil {
    log.Fatal(err)
}
defer l.Close()
for {
    <span class="comment">// Wait for a connection.</span>
    conn, err := l.Accept()
    if err != nil {
        log.Fatal(err)
    }
    <span class="comment">// Handle the connection in a new goroutine.</span>
    <span class="comment">// The loop then returns to accepting, so that</span>
    <span class="comment">// multiple connections may be served concurrently.</span>
    go func(c net.Conn) {
        <span class="comment">// Echo all incoming data.</span>
        io.Copy(c, c)
        <span class="comment">// Shut down the connection.</span>
        c.Close()
    }(conn)
}
</pre>
			
		
	</div>
</div>

			
			

			
				
				<h3 id="FileListener">func <a href="/src/net/file.go?s=1072:1126#L23">FileListener</a>
					<a class="permalink" href="#FileListener">&#xb6;</a>
					
					
				</h3>
				<pre>func FileListener(f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>) (ln <a href="#Listener">Listener</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>FileListener returns a copy of the network listener corresponding
to the open file f.
It is the caller&apos;s responsibility to close ln when finished.
Closing ln does not affect f, and closing f does not affect ln.

				
				
			
				
				<h3 id="Listen">func <a href="/src/net/dial.go?s=26078:26132#L827">Listen</a>
					<a class="permalink" href="#Listen">&#xb6;</a>
					
					
				</h3>
				<pre>func Listen(network, address <a href="/pkg/builtin/#string">string</a>) (<a href="#Listener">Listener</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Listen announces on the local network address.
<p>The network must be &quot;tcp&quot;, &quot;tcp4&quot;, &quot;tcp6&quot;, &quot;unix&quot; or &quot;unixpacket&quot;.
<p>For TCP networks, if the host in the address parameter is empty or
a literal unspecified IP address, Listen listens on all available
unicast and anycast IP addresses of the local system.
To only use IPv4, use network &quot;tcp4&quot;.
The address can use a host name, but this is not recommended,
because it will create a listener for at most one of the host&apos;s IP
addresses.
If the port in the address parameter is empty or &quot;0&quot;, as in
&quot;127.0.0.1:&quot; or &quot;[::1]:0&quot;, a port number is automatically chosen.
The <a href="#Addr">Addr</a> method of <a href="#Listener">Listener</a> can be used to discover the chosen
port.
<p>See func <a href="#Dial">Dial</a> for a description of the network and address
parameters.
<p>Listen uses context.Background internally; to specify the context, use
<a href="#ListenConfig.Listen">ListenConfig.Listen</a>.

				
				
			

			
		
			
			
			<h2 id="MX">type <a href="/src/net/dnsclient.go?s=5390:5434#L207">MX</a>
				<a class="permalink" href="#MX">&#xb6;</a>
				
				
			</h2>
			<p>An MX represents a single DNS MX record.

			<pre>type MX struct {
<span id="MX.Host"></span>    Host <a href="/pkg/builtin/#string">string</a>
<span id="MX.Pref"></span>    Pref <a href="/pkg/builtin/#uint16">uint16</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="LookupMX">func <a href="/src/net/lookup.go?s=18668:18709#L534">LookupMX</a>
					<a class="permalink" href="#LookupMX">&#xb6;</a>
					
					
				</h3>
				<pre>func LookupMX(name <a href="/pkg/builtin/#string">string</a>) ([]*<a href="#MX">MX</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LookupMX returns the DNS MX records for the given domain name sorted by preference.
<p>The returned mail server names are validated to be properly
formatted presentation-format domain names. If the response contains
invalid names, those records are filtered out and an error
will be returned alongside the remaining results, if any.
<p>LookupMX uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Resolver.LookupMX">Resolver.LookupMX</a>.

				
				
			

			
		
			
			
			<h2 id="NS">type <a href="/src/net/dnsclient.go?s=5776:5807#L227">NS</a>
				<a class="permalink" href="#NS">&#xb6;</a>
				
				<span title="Added in Go 1.1">1.1</span>
			</h2>
			<p>An NS represents a single DNS NS record.

			<pre>type NS struct {
<span id="NS.Host"></span>    Host <a href="/pkg/builtin/#string">string</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="LookupNS">func <a href="/src/net/lookup.go?s=20052:20093#L574">LookupNS</a>
					<a class="permalink" href="#LookupNS">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func LookupNS(name <a href="/pkg/builtin/#string">string</a>) ([]*<a href="#NS">NS</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LookupNS returns the DNS NS records for the given domain name.
<p>The returned name server names are validated to be properly
formatted presentation-format domain names. If the response contains
invalid names, those records are filtered out and an error
will be returned alongside the remaining results, if any.
<p>LookupNS uses <a href="/context#Background">context.Background</a> internally; to specify the context, use
<a href="#Resolver.LookupNS">Resolver.LookupNS</a>.

				
				
			

			
		
			
			
			<h2 id="OpError">type <a href="/src/net/net.go?s=15750:16573#L452">OpError</a>
				<a class="permalink" href="#OpError">&#xb6;</a>
				
				
			</h2>
			<p>OpError is the error type usually returned by functions in the net
package. It describes the operation, network type, and address of
an error.

			<pre>type OpError struct {
<span id="OpError.Op"></span>    <span class="comment">// Op is the operation which caused the error, such as</span>
    <span class="comment">// &#34;read&#34; or &#34;write&#34;.</span>
    Op <a href="/pkg/builtin/#string">string</a>

<span id="OpError.Net"></span>    <span class="comment">// Net is the network type on which this error occurred,</span>
    <span class="comment">// such as &#34;tcp&#34; or &#34;udp6&#34;.</span>
    Net <a href="/pkg/builtin/#string">string</a>

    <span class="comment">// For operations involving a remote network connection, like</span>
    <span class="comment">// Dial, Read, or Write, Source is the corresponding local</span>
    <span class="comment">// network address.</span>
<span id="OpError.Source"></span>    Source <a href="#Addr">Addr</a> <span class="comment">// Go 1.5</span>

<span id="OpError.Addr"></span>    <span class="comment">// Addr is the network address for which this error occurred.</span>
    <span class="comment">// For local operations, like Listen or SetDeadline, Addr is</span>
    <span class="comment">// the address of the local endpoint being manipulated.</span>
    <span class="comment">// For operations involving a remote network connection, like</span>
    <span class="comment">// Dial, Read, or Write, Addr is the remote address of that</span>
    <span class="comment">// connection.</span>
    Addr <a href="#Addr">Addr</a>

<span id="OpError.Err"></span>    <span class="comment">// Err is the error that occurred during the operation.</span>
    <span class="comment">// The Error method panics if the error is nil.</span>
    Err <a href="/pkg/builtin/#error">error</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="OpError.Error">func (*OpError) <a href="/src/net/net.go?s=16626:16658#L481">Error</a>
					<a class="permalink" href="#OpError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#OpError">OpError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="OpError.Temporary">func (*OpError) <a href="/src/net/net.go?s=17552:17586#L532">Temporary</a>
					<a class="permalink" href="#OpError.Temporary">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#OpError">OpError</a>) Temporary() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="OpError.Timeout">func (*OpError) <a href="/src/net/net.go?s=17311:17343#L519">Timeout</a>
					<a class="permalink" href="#OpError.Timeout">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#OpError">OpError</a>) Timeout() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="OpError.Unwrap">func (*OpError) <a href="/src/net/net.go?s=16575:16607#L479">Unwrap</a>
					<a class="permalink" href="#OpError.Unwrap">&#xb6;</a>
					
					<span title="Added in Go 1.13">1.13</span>
				</h3>
				<pre>func (e *<a href="#OpError">OpError</a>) Unwrap() <a href="/pkg/builtin/#error">error</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="PacketConn">type <a href="/src/net/net.go?s=10524:13225#L305">PacketConn</a>
				<a class="permalink" href="#PacketConn">&#xb6;</a>
				
				
			</h2>
			<p>PacketConn is a generic packet-oriented network connection.
<p>Multiple goroutines may invoke methods on a PacketConn simultaneously.

			<pre>type PacketConn interface {
    <span class="comment">// ReadFrom reads a packet from the connection,</span>
    <span class="comment">// copying the payload into p. It returns the number of</span>
    <span class="comment">// bytes copied into p and the return address that</span>
    <span class="comment">// was on the packet.</span>
    <span class="comment">// It returns the number of bytes read (0 &lt;= n &lt;= len(p))</span>
    <span class="comment">// and any error encountered. Callers should always process</span>
    <span class="comment">// the n &gt; 0 bytes returned before considering the error err.</span>
    <span class="comment">// ReadFrom can be made to time out and return an error after a</span>
    <span class="comment">// fixed time limit; see SetDeadline and SetReadDeadline.</span>
    ReadFrom(p []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, addr <a href="#Addr">Addr</a>, err <a href="/pkg/builtin/#error">error</a>)

    <span class="comment">// WriteTo writes a packet with payload p to addr.</span>
    <span class="comment">// WriteTo can be made to time out and return an Error after a</span>
    <span class="comment">// fixed time limit; see SetDeadline and SetWriteDeadline.</span>
    <span class="comment">// On packet-oriented connections, write timeouts are rare.</span>
    WriteTo(p []<a href="/pkg/builtin/#byte">byte</a>, addr <a href="#Addr">Addr</a>) (n <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)

    <span class="comment">// Close closes the connection.</span>
    <span class="comment">// Any blocked ReadFrom or WriteTo operations will be unblocked and return errors.</span>
    Close() <a href="/pkg/builtin/#error">error</a>

    <span class="comment">// LocalAddr returns the local network address, if known.</span>
    LocalAddr() <a href="#Addr">Addr</a>

    <span class="comment">// SetDeadline sets the read and write deadlines associated</span>
    <span class="comment">// with the connection. It is equivalent to calling both</span>
    <span class="comment">// SetReadDeadline and SetWriteDeadline.</span>
    <span class="comment">//</span>
    <span class="comment">// A deadline is an absolute time after which I/O operations</span>
    <span class="comment">// fail instead of blocking. The deadline applies to all future</span>
    <span class="comment">// and pending I/O, not just the immediately following call to</span>
    <span class="comment">// Read or Write. After a deadline has been exceeded, the</span>
    <span class="comment">// connection can be refreshed by setting a deadline in the future.</span>
    <span class="comment">//</span>
    <span class="comment">// If the deadline is exceeded a call to Read or Write or to other</span>
    <span class="comment">// I/O methods will return an error that wraps os.ErrDeadlineExceeded.</span>
    <span class="comment">// This can be tested using errors.Is(err, os.ErrDeadlineExceeded).</span>
    <span class="comment">// The error&#39;s Timeout method will return true, but note that there</span>
    <span class="comment">// are other possible errors for which the Timeout method will</span>
    <span class="comment">// return true even if the deadline has not been exceeded.</span>
    <span class="comment">//</span>
    <span class="comment">// An idle timeout can be implemented by repeatedly extending</span>
    <span class="comment">// the deadline after successful ReadFrom or WriteTo calls.</span>
    <span class="comment">//</span>
    <span class="comment">// A zero value for t means I/O operations will not time out.</span>
    SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a>

    <span class="comment">// SetReadDeadline sets the deadline for future ReadFrom calls</span>
    <span class="comment">// and any currently-blocked ReadFrom call.</span>
    <span class="comment">// A zero value for t means ReadFrom will not time out.</span>
    SetReadDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a>

    <span class="comment">// SetWriteDeadline sets the deadline for future WriteTo calls</span>
    <span class="comment">// and any currently-blocked WriteTo call.</span>
    <span class="comment">// Even if write times out, it may return n &gt; 0, indicating that</span>
    <span class="comment">// some of the data was successfully written.</span>
    <span class="comment">// A zero value for t means WriteTo will not time out.</span>
    SetWriteDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a>
}</pre>

			

			

			
			
			

			
				
				<h3 id="FilePacketConn">func <a href="/src/net/file.go?s=1513:1570#L35">FilePacketConn</a>
					<a class="permalink" href="#FilePacketConn">&#xb6;</a>
					
					
				</h3>
				<pre>func FilePacketConn(f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>) (c <a href="#PacketConn">PacketConn</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>FilePacketConn returns a copy of the packet network connection
corresponding to the open file f.
It is the caller&apos;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.

				
				
			
				
				<h3 id="ListenPacket">func <a href="/src/net/dial.go?s=27347:27409#L857">ListenPacket</a>
					<a class="permalink" href="#ListenPacket">&#xb6;</a>
					
					
				</h3>
				<pre>func ListenPacket(network, address <a href="/pkg/builtin/#string">string</a>) (<a href="#PacketConn">PacketConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ListenPacket announces on the local network address.
<p>The network must be &quot;udp&quot;, &quot;udp4&quot;, &quot;udp6&quot;, &quot;unixgram&quot;, or an IP
transport. The IP transports are &quot;ip&quot;, &quot;ip4&quot;, or &quot;ip6&quot; followed by
a colon and a literal protocol number or a protocol name, as in
&quot;ip:1&quot; or &quot;ip:icmp&quot;.
<p>For UDP and IP networks, if the host in the address parameter is
empty or a literal unspecified IP address, ListenPacket listens on
all available IP addresses of the local system except multicast IP
addresses.
To only use IPv4, use network &quot;udp4&quot; or &quot;ip4:proto&quot;.
The address can use a host name, but this is not recommended,
because it will create a listener for at most one of the host&apos;s IP
addresses.
If the port in the address parameter is empty or &quot;0&quot;, as in
&quot;127.0.0.1:&quot; or &quot;[::1]:0&quot;, a port number is automatically chosen.
The LocalAddr method of <a href="#PacketConn">PacketConn</a> can be used to discover the
chosen port.
<p>See func <a href="#Dial">Dial</a> for a description of the network and address
parameters.
<p>ListenPacket uses context.Background internally; to specify the context, use
<a href="#ListenConfig.ListenPacket">ListenConfig.ListenPacket</a>.

				
				
			

			
		
			
			
			<h2 id="ParseError">type <a href="/src/net/net.go?s=18002:18186#L548">ParseError</a>
				<a class="permalink" href="#ParseError">&#xb6;</a>
				
				
			</h2>
			<p>A ParseError is the error type of literal network address parsers.

			<pre>type ParseError struct {
<span id="ParseError.Type"></span>    <span class="comment">// Type is the type of string that was expected, such as</span>
    <span class="comment">// &#34;IP address&#34;, &#34;CIDR address&#34;.</span>
    Type <a href="/pkg/builtin/#string">string</a>

<span id="ParseError.Text"></span>    <span class="comment">// Text is the malformed text string.</span>
    Text <a href="/pkg/builtin/#string">string</a>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ParseError.Error">func (*ParseError) <a href="/src/net/net.go?s=18188:18223#L557">Error</a>
					<a class="permalink" href="#ParseError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e *<a href="#ParseError">ParseError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="ParseError.Temporary">func (*ParseError) <a href="/src/net/net.go?s=18327:18364#L560">Temporary</a>
					<a class="permalink" href="#ParseError.Temporary">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (e *<a href="#ParseError">ParseError</a>) Temporary() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="ParseError.Timeout">func (*ParseError) <a href="/src/net/net.go?s=18272:18307#L559">Timeout</a>
					<a class="permalink" href="#ParseError.Timeout">&#xb6;</a>
					
					<span title="Added in Go 1.17">1.17</span>
				</h3>
				<pre>func (e *<a href="#ParseError">ParseError</a>) Timeout() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Resolver">type <a href="/src/net/lookup.go?s=3834:5615#L123">Resolver</a>
				<a class="permalink" href="#Resolver">&#xb6;</a>
				
				<span title="Added in Go 1.8">1.8</span>
			</h2>
			<p>A Resolver looks up names and numbers.
<p>A nil *Resolver is equivalent to a zero Resolver.

			<pre>type Resolver struct {
<span id="Resolver.PreferGo"></span>    <span class="comment">// PreferGo controls whether Go&#39;s built-in DNS resolver is preferred</span>
    <span class="comment">// on platforms where it&#39;s available. It is equivalent to setting</span>
    <span class="comment">// GODEBUG=netdns=go, but scoped to just this resolver.</span>
    PreferGo <a href="/pkg/builtin/#bool">bool</a>

<span id="Resolver.StrictErrors"></span>    <span class="comment">// StrictErrors controls the behavior of temporary errors</span>
    <span class="comment">// (including timeout, socket errors, and SERVFAIL) when using</span>
    <span class="comment">// Go&#39;s built-in resolver. For a query composed of multiple</span>
    <span class="comment">// sub-queries (such as an A+AAAA address lookup, or walking the</span>
    <span class="comment">// DNS search list), this option causes such errors to abort the</span>
    <span class="comment">// whole query instead of returning a partial result. This is</span>
    <span class="comment">// not enabled by default because it may affect compatibility</span>
    <span class="comment">// with resolvers that process AAAA queries incorrectly.</span>
    StrictErrors <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// Go 1.9</span>

<span id="Resolver.Dial"></span>    <span class="comment">// Dial optionally specifies an alternate dialer for use by</span>
    <span class="comment">// Go&#39;s built-in DNS resolver to make TCP and UDP connections</span>
    <span class="comment">// to DNS services. The host in the address parameter will</span>
    <span class="comment">// always be a literal IP address and not a host name, and the</span>
    <span class="comment">// port in the address parameter will be a literal port number</span>
    <span class="comment">// and not a service name.</span>
    <span class="comment">// If the Conn returned is also a PacketConn, sent and received DNS</span>
    <span class="comment">// messages must adhere to RFC 1035 section 4.2.1, &#34;UDP usage&#34;.</span>
    <span class="comment">// Otherwise, DNS messages transmitted over Conn must adhere</span>
    <span class="comment">// to RFC 7766 section 5, &#34;Transport Protocol Selection&#34;.</span>
    <span class="comment">// If nil, the default dialer is used.</span>
    Dial func(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, network, address <a href="/pkg/builtin/#string">string</a>) (<a href="#Conn">Conn</a>, <a href="/pkg/builtin/#error">error</a>) <span class="comment">// Go 1.9</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Resolver.LookupAddr">func (*Resolver) <a href="/src/net/lookup.go?s=22556:22637#L640">LookupAddr</a>
					<a class="permalink" href="#Resolver.LookupAddr">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (r *<a href="#Resolver">Resolver</a>) LookupAddr(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, addr <a href="/pkg/builtin/#string">string</a>) ([]<a href="/pkg/builtin/#string">string</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LookupAddr performs a reverse lookup for the given address, returning a list
of names mapping to that address.
<p>The returned names are validated to be properly formatted presentation-format
domain names. If the response contains invalid names, those records are filtered
out and an error will be returned alongside the remaining results, if any.

				
				
				
			
				
				<h3 id="Resolver.LookupCNAME">func (*Resolver) <a href="/src/net/lookup.go?s=15557:15637#L458">LookupCNAME</a>
					<a class="permalink" href="#Resolver.LookupCNAME">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (r *<a href="#Resolver">Resolver</a>) LookupCNAME(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, host <a href="/pkg/builtin/#string">string</a>) (<a href="/pkg/builtin/#string">string</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LookupCNAME returns the canonical name for the given host.
Callers that do not care about the canonical name can call
<a href="#LookupHost">LookupHost</a> or <a href="#LookupIP">LookupIP</a> directly; both take care of resolving
the canonical name as part of the lookup.
<p>A canonical name is the final name after following zero
or more CNAME records.
LookupCNAME does not return an error if host does not
contain DNS &quot;CNAME&quot; records, as long as host resolves to
address records.
<p>The returned canonical name is validated to be a properly
formatted presentation-format domain name.

				
				
				
			
				
				<h3 id="Resolver.LookupHost">func (*Resolver) <a href="/src/net/lookup.go?s=6366:6457#L182">LookupHost</a>
					<a class="permalink" href="#Resolver.LookupHost">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (r *<a href="#Resolver">Resolver</a>) LookupHost(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, host <a href="/pkg/builtin/#string">string</a>) (addrs []<a href="/pkg/builtin/#string">string</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LookupHost looks up the given host using the local resolver.
It returns a slice of that host&apos;s addresses.

				
				
				
			
				
				<h3 id="Resolver.LookupIP">func (*Resolver) <a href="/src/net/lookup.go?s=7539:7623#L217">LookupIP</a>
					<a class="permalink" href="#Resolver.LookupIP">&#xb6;</a>
					
					<span title="Added in Go 1.15">1.15</span>
				</h3>
				<pre>func (r *<a href="#Resolver">Resolver</a>) LookupIP(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, network, host <a href="/pkg/builtin/#string">string</a>) ([]<a href="#IP">IP</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LookupIP looks up host for the given network using the local resolver.
It returns a slice of that host&apos;s IP addresses of the type specified by
network.
network must be one of &quot;ip&quot;, &quot;ip4&quot; or &quot;ip6&quot;.

				
				
				
			
				
				<h3 id="Resolver.LookupIPAddr">func (*Resolver) <a href="/src/net/lookup.go?s=7201:7284#L209">LookupIPAddr</a>
					<a class="permalink" href="#Resolver.LookupIPAddr">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (r *<a href="#Resolver">Resolver</a>) LookupIPAddr(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, host <a href="/pkg/builtin/#string">string</a>) ([]<a href="#IPAddr">IPAddr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LookupIPAddr looks up host using the local resolver.
It returns a slice of that host&apos;s IPv4 and IPv6 addresses.

				
				
				
			
				
				<h3 id="Resolver.LookupMX">func (*Resolver) <a href="/src/net/lookup.go?s=19124:19200#L544">LookupMX</a>
					<a class="permalink" href="#Resolver.LookupMX">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (r *<a href="#Resolver">Resolver</a>) LookupMX(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, name <a href="/pkg/builtin/#string">string</a>) ([]*<a href="#MX">MX</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LookupMX returns the DNS MX records for the given domain name sorted by preference.
<p>The returned mail server names are validated to be properly
formatted presentation-format domain names. If the response contains
invalid names, those records are filtered out and an error
will be returned alongside the remaining results, if any.

				
				
				
			
				
				<h3 id="Resolver.LookupNS">func (*Resolver) <a href="/src/net/lookup.go?s=20487:20563#L584">LookupNS</a>
					<a class="permalink" href="#Resolver.LookupNS">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (r *<a href="#Resolver">Resolver</a>) LookupNS(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, name <a href="/pkg/builtin/#string">string</a>) ([]*<a href="#NS">NS</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LookupNS returns the DNS NS records for the given domain name.
<p>The returned name server names are validated to be properly
formatted presentation-format domain names. If the response contains
invalid names, those records are filtered out and an error
will be returned alongside the remaining results, if any.

				
				
				
			
				
				<h3 id="Resolver.LookupNetIP">func (*Resolver) <a href="/src/net/lookup.go?s=8297:8392#L247">LookupNetIP</a>
					<a class="permalink" href="#Resolver.LookupNetIP">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (r *<a href="#Resolver">Resolver</a>) LookupNetIP(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, network, host <a href="/pkg/builtin/#string">string</a>) ([]<a href="/pkg/net/netip/">netip</a>.<a href="/pkg/net/netip/#Addr">Addr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LookupNetIP looks up host using the local resolver.
It returns a slice of that host&apos;s IP addresses of the type specified by
network.
The network must be one of &quot;ip&quot;, &quot;ip4&quot; or &quot;ip6&quot;.

				
				
				
			
				
				<h3 id="Resolver.LookupPort">func (*Resolver) <a href="/src/net/lookup.go?s=13575:13672#L404">LookupPort</a>
					<a class="permalink" href="#Resolver.LookupPort">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (r *<a href="#Resolver">Resolver</a>) LookupPort(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, network, service <a href="/pkg/builtin/#string">string</a>) (port <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LookupPort looks up the port for the given network and service.
<p>The network must be one of &quot;tcp&quot;, &quot;tcp4&quot;, &quot;tcp6&quot;, &quot;udp&quot;, &quot;udp4&quot;, &quot;udp6&quot; or &quot;ip&quot;.

				
				
				
			
				
				<h3 id="Resolver.LookupSRV">func (*Resolver) <a href="/src/net/lookup.go?s=17510:17612#L501">LookupSRV</a>
					<a class="permalink" href="#Resolver.LookupSRV">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (r *<a href="#Resolver">Resolver</a>) LookupSRV(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, service, proto, name <a href="/pkg/builtin/#string">string</a>) (<a href="/pkg/builtin/#string">string</a>, []*<a href="#SRV">SRV</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LookupSRV tries to resolve an <a href="#SRV">SRV</a> query of the given service,
protocol, and domain name. The proto is &quot;tcp&quot; or &quot;udp&quot;.
The returned records are sorted by priority and randomized
by weight within a priority.
<p>LookupSRV constructs the DNS name to look up following RFC 2782.
That is, it looks up _service._proto.name. To accommodate services
publishing SRV records under non-standard names, if both service
and proto are empty strings, LookupSRV looks up name directly.
<p>The returned service names are validated to be properly
formatted presentation-format domain names. If the response contains
invalid names, those records are filtered out and an error
will be returned alongside the remaining results, if any.

				
				
				
			
				
				<h3 id="Resolver.LookupTXT">func (*Resolver) <a href="/src/net/lookup.go?s=21339:21419#L614">LookupTXT</a>
					<a class="permalink" href="#Resolver.LookupTXT">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (r *<a href="#Resolver">Resolver</a>) LookupTXT(ctx <a href="/pkg/context/">context</a>.<a href="/pkg/context/#Context">Context</a>, name <a href="/pkg/builtin/#string">string</a>) ([]<a href="/pkg/builtin/#string">string</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LookupTXT returns the DNS TXT records for the given domain name.

				
				
				
			
		
			
			
			<h2 id="SRV">type <a href="/src/net/dnsclient.go?s=4242:4329#L154">SRV</a>
				<a class="permalink" href="#SRV">&#xb6;</a>
				
				
			</h2>
			<p>An SRV represents a single DNS SRV record.

			<pre>type SRV struct {
<span id="SRV.Target"></span>    Target   <a href="/pkg/builtin/#string">string</a>
<span id="SRV.Port"></span>    Port     <a href="/pkg/builtin/#uint16">uint16</a>
<span id="SRV.Priority"></span>    Priority <a href="/pkg/builtin/#uint16">uint16</a>
<span id="SRV.Weight"></span>    Weight   <a href="/pkg/builtin/#uint16">uint16</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="LookupSRV">func <a href="/src/net/lookup.go?s=16591:16674#L483">LookupSRV</a>
					<a class="permalink" href="#LookupSRV">&#xb6;</a>
					
					
				</h3>
				<pre>func LookupSRV(service, proto, name <a href="/pkg/builtin/#string">string</a>) (cname <a href="/pkg/builtin/#string">string</a>, addrs []*<a href="#SRV">SRV</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>LookupSRV tries to resolve an <a href="#SRV">SRV</a> query of the given service,
protocol, and domain name. The proto is &quot;tcp&quot; or &quot;udp&quot;.
The returned records are sorted by priority and randomized
by weight within a priority.
<p>LookupSRV constructs the DNS name to look up following RFC 2782.
That is, it looks up _service._proto.name. To accommodate services
publishing SRV records under non-standard names, if both service
and proto are empty strings, LookupSRV looks up name directly.
<p>The returned service names are validated to be properly
formatted presentation-format domain names. If the response contains
invalid names, those records are filtered out and an error
will be returned alongside the remaining results, if any.

				
				
			

			
		
			
			
			<h2 id="TCPAddr">type <a href="/src/net/tcpsock.go?s=412:498#L11">TCPAddr</a>
				<a class="permalink" href="#TCPAddr">&#xb6;</a>
				
				
			</h2>
			<p>TCPAddr represents the address of a TCP end point.

			<pre>type TCPAddr struct {
<span id="TCPAddr.IP"></span>    IP   <a href="#IP">IP</a>
<span id="TCPAddr.Port"></span>    Port <a href="/pkg/builtin/#int">int</a>
<span id="TCPAddr.Zone"></span>    Zone <a href="/pkg/builtin/#string">string</a> <span class="comment">// IPv6 scoped addressing zone; added in Go 1.1</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="ResolveTCPAddr">func <a href="/src/net/tcpsock.go?s=2005:2067#L74">ResolveTCPAddr</a>
					<a class="permalink" href="#ResolveTCPAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func ResolveTCPAddr(network, address <a href="/pkg/builtin/#string">string</a>) (*<a href="#TCPAddr">TCPAddr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ResolveTCPAddr returns an address of TCP end point.
<p>The network must be a TCP network name.
<p>If the host in the address parameter is not a literal IP address or
the port is not a literal port number, ResolveTCPAddr resolves the
address to an address of TCP end point.
Otherwise, it parses the address as a pair of literal IP address
and port number.
The address parameter can use a host name, but this is not
recommended, because it will return at most one of the host name&apos;s
IP addresses.
<p>See func <a href="#Dial">Dial</a> for a description of the network and address
parameters.

				
				
			
				
				<h3 id="TCPAddrFromAddrPort">func <a href="/src/net/tcpsock.go?s=2641:2695#L92">TCPAddrFromAddrPort</a>
					<a class="permalink" href="#TCPAddrFromAddrPort">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func TCPAddrFromAddrPort(addr <a href="/pkg/net/netip/">netip</a>.<a href="/pkg/net/netip/#AddrPort">AddrPort</a>) *<a href="#TCPAddr">TCPAddr</a></pre>
				<p>TCPAddrFromAddrPort returns addr as a <a href="#TCPAddr">TCPAddr</a>. If addr.IsValid() is false,
then the returned TCPAddr will contain a nil IP field, indicating an
address family-agnostic unspecified address.

				
				
			

			
				
				<h3 id="TCPAddr.AddrPort">func (*TCPAddr) <a href="/src/net/tcpsock.go?s=671:714#L22">AddrPort</a>
					<a class="permalink" href="#TCPAddr.AddrPort">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (a *<a href="#TCPAddr">TCPAddr</a>) AddrPort() <a href="/pkg/net/netip/">netip</a>.<a href="/pkg/net/netip/#AddrPort">AddrPort</a></pre>
				<p>AddrPort returns the <a href="#TCPAddr">TCPAddr</a> a as a <a href="/net/netip#AddrPort">netip.AddrPort</a>.
<p>If a.Port does not fit in a uint16, it&apos;s silently truncated.
<p>If a is nil, a zero value is returned.

				
				
				
			
				
				<h3 id="TCPAddr.Network">func (*TCPAddr) <a href="/src/net/tcpsock.go?s=927:961#L32">Network</a>
					<a class="permalink" href="#TCPAddr.Network">&#xb6;</a>
					
					
				</h3>
				<pre>func (a *<a href="#TCPAddr">TCPAddr</a>) Network() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Network returns the address&apos;s network name, &quot;tcp&quot;.

				
				
				
			
				
				<h3 id="TCPAddr.String">func (*TCPAddr) <a href="/src/net/tcpsock.go?s=980:1013#L34">String</a>
					<a class="permalink" href="#TCPAddr.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a *<a href="#TCPAddr">TCPAddr</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="TCPConn">type <a href="/src/net/tcpsock.go?s=2895:2924#L102">TCPConn</a>
				<a class="permalink" href="#TCPConn">&#xb6;</a>
				
				
			</h2>
			<p>TCPConn is an implementation of the <a href="#Conn">Conn</a> interface for TCP network
connections.

			<pre>type TCPConn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="DialTCP">func <a href="/src/net/tcpsock.go?s=9687:9756#L307">DialTCP</a>
					<a class="permalink" href="#DialTCP">&#xb6;</a>
					
					
				</h3>
				<pre>func DialTCP(network <a href="/pkg/builtin/#string">string</a>, laddr, raddr *<a href="#TCPAddr">TCPAddr</a>) (*<a href="#TCPConn">TCPConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>DialTCP acts like <a href="#Dial">Dial</a> for TCP networks.
<p>The network must be a TCP network name; see func Dial for details.
<p>If laddr is nil, a local address is automatically chosen.
If the IP field of raddr is nil or an unspecified IP address, the
local system is assumed.

				
				
			

			
				
				<h3 id="TCPConn.Close">func (*TCPConn) <a href="/src/net/net.go?s=7529:7557#L199">Close</a>
					<a class="permalink" href="#TCPConn.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Close closes the connection.

				
				
				
			
				
				<h3 id="TCPConn.CloseRead">func (*TCPConn) <a href="/src/net/tcpsock.go?s=5462:5497#L176">CloseRead</a>
					<a class="permalink" href="#TCPConn.CloseRead">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) CloseRead() <a href="/pkg/builtin/#error">error</a></pre>
				<p>CloseRead shuts down the reading side of the TCP connection.
Most callers should just use Close.

				
				
				
			
				
				<h3 id="TCPConn.CloseWrite">func (*TCPConn) <a href="/src/net/tcpsock.go?s=5799:5835#L188">CloseWrite</a>
					<a class="permalink" href="#TCPConn.CloseWrite">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) CloseWrite() <a href="/pkg/builtin/#error">error</a></pre>
				<p>CloseWrite shuts down the writing side of the TCP connection.
Most callers should just use Close.

				
				
				
			
				
				<h3 id="TCPConn.File">func (*TCPConn) <a href="/src/net/net.go?s=10192:10237#L294">File</a>
					<a class="permalink" href="#TCPConn.File">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) File() (f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>File returns a copy of the underlying <a href="/os#File">os.File</a>.
It is the caller&apos;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
<p>The returned os.File&apos;s file descriptor is different from the connection&apos;s.
Attempting to change properties of the original using this duplicate
may or may not have the desired effect.

				
				
				
			
				
				<h3 id="TCPConn.LocalAddr">func (*TCPConn) <a href="/src/net/net.go?s=7886:7917#L213">LocalAddr</a>
					<a class="permalink" href="#TCPConn.LocalAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) LocalAddr() <a href="#Addr">Addr</a></pre>
				<p>LocalAddr returns the local network address.
The Addr returned is shared by all invocations of LocalAddr, so
do not modify it.

				
				
				
			
				
				<h3 id="TCPConn.MultipathTCP">func (*TCPConn) <a href="/src/net/tcpsock.go?s=8722:8768#L272">MultipathTCP</a>
					<a class="permalink" href="#TCPConn.MultipathTCP">&#xb6;</a>
					
					<span title="Added in Go 1.21">1.21</span>
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) MultipathTCP() (<a href="/pkg/builtin/#bool">bool</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>MultipathTCP reports whether the ongoing connection is using MPTCP.
<p>If Multipath TCP is not supported by the host, by the other peer or
intentionally / accidentally filtered out by a device in between, a
fallback to TCP will be done. This method does its best to check if
MPTCP is still being used or not.
<p>On Linux, more conditions are verified on kernels &gt;= v5.16, improving
the results.

				
				
				
			
				
				<h3 id="TCPConn.Read">func (*TCPConn) <a href="/src/net/net.go?s=6948:6990#L175">Read</a>
					<a class="permalink" href="#TCPConn.Read">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) Read(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Read implements the Conn Read method.

				
				
				
			
				
				<h3 id="TCPConn.ReadFrom">func (*TCPConn) <a href="/src/net/tcpsock.go?s=4754:4808#L151">ReadFrom</a>
					<a class="permalink" href="#TCPConn.ReadFrom">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) ReadFrom(r <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Reader">Reader</a>) (<a href="/pkg/builtin/#int64">int64</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadFrom implements the <a href="/io#ReaderFrom">io.ReaderFrom</a> ReadFrom method.

				
				
				
			
				
				<h3 id="TCPConn.RemoteAddr">func (*TCPConn) <a href="/src/net/net.go?s=8111:8143#L223">RemoteAddr</a>
					<a class="permalink" href="#TCPConn.RemoteAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) RemoteAddr() <a href="#Addr">Addr</a></pre>
				<p>RemoteAddr returns the remote network address.
The Addr returned is shared by all invocations of RemoteAddr, so
do not modify it.

				
				
				
			
				
				<h3 id="TCPConn.SetDeadline">func (*TCPConn) <a href="/src/net/net.go?s=8253:8298#L231">SetDeadline</a>
					<a class="permalink" href="#TCPConn.SetDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetDeadline implements the Conn SetDeadline method.

				
				
				
			
				
				<h3 id="TCPConn.SetKeepAlive">func (*TCPConn) <a href="/src/net/tcpsock.go?s=6989:7041#L224">SetKeepAlive</a>
					<a class="permalink" href="#TCPConn.SetKeepAlive">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetKeepAlive(keepalive <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetKeepAlive sets whether the operating system should send
keep-alive messages on the connection.

				
				
				
			
				
				<h3 id="TCPConn.SetKeepAliveConfig">func (*TCPConn) <a href="/src/net/tcpsock_unix.go?s=320:386#L2">SetKeepAliveConfig</a>
					<a class="permalink" href="#TCPConn.SetKeepAliveConfig">&#xb6;</a>
					
					<span title="Added in Go 1.23">1.23</span>
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetKeepAliveConfig(config <a href="#KeepAliveConfig">KeepAliveConfig</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetKeepAliveConfig configures keep-alive messages sent by the operating system.

				
				
				
			
				
				<h3 id="TCPConn.SetKeepAlivePeriod">func (*TCPConn) <a href="/src/net/tcpsock.go?s=7546:7605#L239">SetKeepAlivePeriod</a>
					<a class="permalink" href="#TCPConn.SetKeepAlivePeriod">&#xb6;</a>
					
					<span title="Added in Go 1.2">1.2</span>
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetKeepAlivePeriod(d <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Duration">Duration</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetKeepAlivePeriod sets the duration the connection needs to
remain idle before TCP starts sending keepalive probes.
<p>Note that calling this method on Windows prior to Windows 10 version 1709
will reset the KeepAliveInterval to the default system value, which is normally 1 second.

				
				
				
			
				
				<h3 id="TCPConn.SetLinger">func (*TCPConn) <a href="/src/net/tcpsock.go?s=6643:6685#L212">SetLinger</a>
					<a class="permalink" href="#TCPConn.SetLinger">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetLinger(sec <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetLinger sets the behavior of Close on a connection which still
has data waiting to be sent or to be acknowledged.
<p>If sec &lt; 0 (the default), the operating system finishes sending the
data in the background.
<p>If sec == 0, the operating system discards any unsent or
unacknowledged data.
<p>If sec &gt; 0, the data is sent in the background as with sec &lt; 0.
On some operating systems including Linux, this may cause Close to block
until all data has been sent or discarded.
On some operating systems after sec seconds have elapsed any remaining
unsent data may be discarded.

				
				
				
			
				
				<h3 id="TCPConn.SetNoDelay">func (*TCPConn) <a href="/src/net/tcpsock.go?s=8053:8101#L253">SetNoDelay</a>
					<a class="permalink" href="#TCPConn.SetNoDelay">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetNoDelay(noDelay <a href="/pkg/builtin/#bool">bool</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetNoDelay controls whether the operating system should delay
packet transmission in hopes of sending fewer packets (Nagle&apos;s
algorithm).  The default is true (no delay), meaning that data is
sent as soon as possible after a Write.

				
				
				
			
				
				<h3 id="TCPConn.SetReadBuffer">func (*TCPConn) <a href="/src/net/net.go?s=9217:9262#L265">SetReadBuffer</a>
					<a class="permalink" href="#TCPConn.SetReadBuffer">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetReadBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetReadBuffer sets the size of the operating system&apos;s
receive buffer associated with the connection.

				
				
				
			
				
				<h3 id="TCPConn.SetReadDeadline">func (*TCPConn) <a href="/src/net/net.go?s=8553:8602#L242">SetReadDeadline</a>
					<a class="permalink" href="#TCPConn.SetReadDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetReadDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetReadDeadline implements the Conn SetReadDeadline method.

				
				
				
			
				
				<h3 id="TCPConn.SetWriteBuffer">func (*TCPConn) <a href="/src/net/net.go?s=9570:9616#L277">SetWriteBuffer</a>
					<a class="permalink" href="#TCPConn.SetWriteBuffer">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetWriteBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetWriteBuffer sets the size of the operating system&apos;s
transmit buffer associated with the connection.

				
				
				
			
				
				<h3 id="TCPConn.SetWriteDeadline">func (*TCPConn) <a href="/src/net/net.go?s=8863:8913#L253">SetWriteDeadline</a>
					<a class="permalink" href="#TCPConn.SetWriteDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SetWriteDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetWriteDeadline implements the Conn SetWriteDeadline method.

				
				
				
			
				
				<h3 id="TCPConn.SyscallConn">func (*TCPConn) <a href="/src/net/tcpsock.go?s=4556:4612#L143">SyscallConn</a>
					<a class="permalink" href="#TCPConn.SyscallConn">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) SyscallConn() (<a href="/pkg/syscall/">syscall</a>.<a href="/pkg/syscall/#RawConn">RawConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>SyscallConn returns a raw network connection.
This implements the <a href="/syscall#Conn">syscall.Conn</a> interface.

				
				
				
			
				
				<h3 id="TCPConn.Write">func (*TCPConn) <a href="/src/net/net.go?s=7251:7294#L187">Write</a>
					<a class="permalink" href="#TCPConn.Write">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) Write(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Write implements the Conn Write method.

				
				
				
			
				
				<h3 id="TCPConn.WriteTo">func (*TCPConn) <a href="/src/net/tcpsock.go?s=5085:5138#L163">WriteTo</a>
					<a class="permalink" href="#TCPConn.WriteTo">&#xb6;</a>
					
					<span title="Added in Go 1.22">1.22</span>
				</h3>
				<pre>func (c *<a href="#TCPConn">TCPConn</a>) WriteTo(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>) (<a href="/pkg/builtin/#int64">int64</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteTo implements the io.WriterTo WriteTo method.

				
				
				
			
		
			
			
			<h2 id="TCPListener">type <a href="/src/net/tcpsock.go?s=10469:10524#L326">TCPListener</a>
				<a class="permalink" href="#TCPListener">&#xb6;</a>
				
				
			</h2>
			<p>TCPListener is a TCP network listener. Clients should typically
use variables of type <a href="#Listener">Listener</a> instead of assuming TCP.

			<pre>type TCPListener struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="ListenTCP">func <a href="/src/net/tcpsock.go?s=13299:13367#L422">ListenTCP</a>
					<a class="permalink" href="#ListenTCP">&#xb6;</a>
					
					
				</h3>
				<pre>func ListenTCP(network <a href="/pkg/builtin/#string">string</a>, laddr *<a href="#TCPAddr">TCPAddr</a>) (*<a href="#TCPListener">TCPListener</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ListenTCP acts like <a href="#Listen">Listen</a> for TCP networks.
<p>The network must be a TCP network name; see func Dial for details.
<p>If the IP field of laddr is nil or an unspecified IP address,
ListenTCP listens on all available unicast and anycast IP addresses
of the local system.
If the Port field of laddr is 0, a port number is automatically
chosen.

				
				
			

			
				
				<h3 id="TCPListener.Accept">func (*TCPListener) <a href="/src/net/tcpsock.go?s=11323:11367#L358">Accept</a>
					<a class="permalink" href="#TCPListener.Accept">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#TCPListener">TCPListener</a>) Accept() (<a href="#Conn">Conn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Accept implements the Accept method in the <a href="#Listener">Listener</a> interface; it
waits for the next call and returns a generic <a href="#Conn">Conn</a>.

				
				
				
			
				
				<h3 id="TCPListener.AcceptTCP">func (*TCPListener) <a href="/src/net/tcpsock.go?s=10942:10993#L345">AcceptTCP</a>
					<a class="permalink" href="#TCPListener.AcceptTCP">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#TCPListener">TCPListener</a>) AcceptTCP() (*<a href="#TCPConn">TCPConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>AcceptTCP accepts the next incoming call and returns the new
connection.

				
				
				
			
				
				<h3 id="TCPListener.Addr">func (*TCPListener) <a href="/src/net/tcpsock.go?s=12026:12059#L384">Addr</a>
					<a class="permalink" href="#TCPListener.Addr">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#TCPListener">TCPListener</a>) Addr() <a href="#Addr">Addr</a></pre>
				<p>Addr returns the listener&apos;s network address, a <a href="#TCPAddr">*TCPAddr</a>.
The Addr returned is shared by all invocations of Addr, so
do not modify it.

				
				
				
			
				
				<h3 id="TCPListener.Close">func (*TCPListener) <a href="/src/net/tcpsock.go?s=11662:11697#L371">Close</a>
					<a class="permalink" href="#TCPListener.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#TCPListener">TCPListener</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Close stops listening on the TCP address.
Already Accepted connections are not closed.

				
				
				
			
				
				<h3 id="TCPListener.File">func (*TCPListener) <a href="/src/net/tcpsock.go?s=12693:12745#L402">File</a>
					<a class="permalink" href="#TCPListener.File">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#TCPListener">TCPListener</a>) File() (f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>File returns a copy of the underlying <a href="/os#File">os.File</a>.
It is the caller&apos;s responsibility to close f when finished.
Closing l does not affect f, and closing f does not affect l.
<p>The returned os.File&apos;s file descriptor is different from the
connection&apos;s. Attempting to change properties of the original
using this duplicate may or may not have the desired effect.

				
				
				
			
				
				<h3 id="TCPListener.SetDeadline">func (*TCPListener) <a href="/src/net/tcpsock.go?s=12190:12242#L388">SetDeadline</a>
					<a class="permalink" href="#TCPListener.SetDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#TCPListener">TCPListener</a>) SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetDeadline sets the deadline associated with the listener.
A zero time value disables the deadline.

				
				
				
			
				
				<h3 id="TCPListener.SyscallConn">func (*TCPListener) <a href="/src/net/tcpsock.go?s=10717:10777#L336">SyscallConn</a>
					<a class="permalink" href="#TCPListener.SyscallConn">&#xb6;</a>
					
					<span title="Added in Go 1.10">1.10</span>
				</h3>
				<pre>func (l *<a href="#TCPListener">TCPListener</a>) SyscallConn() (<a href="/pkg/syscall/">syscall</a>.<a href="/pkg/syscall/#RawConn">RawConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>SyscallConn returns a raw network connection.
This implements the <a href="/syscall#Conn">syscall.Conn</a> interface.
<p>The returned RawConn only supports calling Control. Read and
Write return an error.

				
				
				
			
		
			
			
			<h2 id="UDPAddr">type <a href="/src/net/udpsock.go?s=558:644#L14">UDPAddr</a>
				<a class="permalink" href="#UDPAddr">&#xb6;</a>
				
				
			</h2>
			<p>UDPAddr represents the address of a UDP end point.

			<pre>type UDPAddr struct {
<span id="UDPAddr.IP"></span>    IP   <a href="#IP">IP</a>
<span id="UDPAddr.Port"></span>    Port <a href="/pkg/builtin/#int">int</a>
<span id="UDPAddr.Zone"></span>    Zone <a href="/pkg/builtin/#string">string</a> <span class="comment">// IPv6 scoped addressing zone; added in Go 1.1</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="ResolveUDPAddr">func <a href="/src/net/udpsock.go?s=2145:2207#L77">ResolveUDPAddr</a>
					<a class="permalink" href="#ResolveUDPAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func ResolveUDPAddr(network, address <a href="/pkg/builtin/#string">string</a>) (*<a href="#UDPAddr">UDPAddr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ResolveUDPAddr returns an address of UDP end point.
<p>The network must be a UDP network name.
<p>If the host in the address parameter is not a literal IP address or
the port is not a literal port number, ResolveUDPAddr resolves the
address to an address of UDP end point.
Otherwise, it parses the address as a pair of literal IP address
and port number.
The address parameter can use a host name, but this is not
recommended, because it will return at most one of the host name&apos;s
IP addresses.
<p>See func Dial for a description of the network and address
parameters.

				
				
			
				
				<h3 id="UDPAddrFromAddrPort">func <a href="/src/net/udpsock.go?s=2779:2833#L95">UDPAddrFromAddrPort</a>
					<a class="permalink" href="#UDPAddrFromAddrPort">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func UDPAddrFromAddrPort(addr <a href="/pkg/net/netip/">netip</a>.<a href="/pkg/net/netip/#AddrPort">AddrPort</a>) *<a href="#UDPAddr">UDPAddr</a></pre>
				<p>UDPAddrFromAddrPort returns addr as a UDPAddr. If addr.IsValid() is false,
then the returned UDPAddr will contain a nil IP field, indicating an
address family-agnostic unspecified address.

				
				
			

			
				
				<h3 id="UDPAddr.AddrPort">func (*UDPAddr) <a href="/src/net/udpsock.go?s=813:856#L25">AddrPort</a>
					<a class="permalink" href="#UDPAddr.AddrPort">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (a *<a href="#UDPAddr">UDPAddr</a>) AddrPort() <a href="/pkg/net/netip/">netip</a>.<a href="/pkg/net/netip/#AddrPort">AddrPort</a></pre>
				<p>AddrPort returns the UDPAddr a as a netip.AddrPort.
<p>If a.Port does not fit in a uint16, it&apos;s silently truncated.
<p>If a is nil, a zero value is returned.

				
				
				
			
				
				<h3 id="UDPAddr.Network">func (*UDPAddr) <a href="/src/net/udpsock.go?s=1069:1103#L35">Network</a>
					<a class="permalink" href="#UDPAddr.Network">&#xb6;</a>
					
					
				</h3>
				<pre>func (a *<a href="#UDPAddr">UDPAddr</a>) Network() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Network returns the address&apos;s network name, &quot;udp&quot;.

				
				
				
			
				
				<h3 id="UDPAddr.String">func (*UDPAddr) <a href="/src/net/udpsock.go?s=1122:1155#L37">String</a>
					<a class="permalink" href="#UDPAddr.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a *<a href="#UDPAddr">UDPAddr</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="UDPConn">type <a href="/src/net/udpsock.go?s=3250:3279#L112">UDPConn</a>
				<a class="permalink" href="#UDPConn">&#xb6;</a>
				
				
			</h2>
			<p>UDPConn is the implementation of the Conn and PacketConn interfaces
for UDP network connections.

			<pre>type UDPConn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="DialUDP">func <a href="/src/net/udpsock.go?s=8903:8972#L280">DialUDP</a>
					<a class="permalink" href="#DialUDP">&#xb6;</a>
					
					
				</h3>
				<pre>func DialUDP(network <a href="/pkg/builtin/#string">string</a>, laddr, raddr *<a href="#UDPAddr">UDPAddr</a>) (*<a href="#UDPConn">UDPConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>DialUDP acts like Dial for UDP networks.
<p>The network must be a UDP network name; see func Dial for details.
<p>If laddr is nil, a local address is automatically chosen.
If the IP field of raddr is nil or an unspecified IP address, the
local system is assumed.

				
				
			
				
				<h3 id="ListenMulticastUDP">func <a href="/src/net/udpsock.go?s=11430:11519#L343">ListenMulticastUDP</a>
					<a class="permalink" href="#ListenMulticastUDP">&#xb6;</a>
					
					
				</h3>
				<pre>func ListenMulticastUDP(network <a href="/pkg/builtin/#string">string</a>, ifi *<a href="#Interface">Interface</a>, gaddr *<a href="#UDPAddr">UDPAddr</a>) (*<a href="#UDPConn">UDPConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ListenMulticastUDP acts like ListenPacket for UDP networks but
takes a group address on a specific network interface.
<p>The network must be a UDP network name; see func Dial for details.
<p>ListenMulticastUDP listens on all available IP addresses of the
local system including the group, multicast IP address.
If ifi is nil, ListenMulticastUDP uses the system-assigned
multicast interface, although this is not recommended because the
assignment depends on platforms and sometimes it might require
routing configuration.
If the Port field of gaddr is 0, a port number is automatically
chosen.
<p>ListenMulticastUDP is just for convenience of simple, small
applications. There are golang.org/x/net/ipv4 and
golang.org/x/net/ipv6 packages for general purpose uses.
<p>Note that ListenMulticastUDP will set the IP_MULTICAST_LOOP socket option
to 0 under IPPROTO_IP, to disable loopback of multicast packets.

				
				
			
				
				<h3 id="ListenUDP">func <a href="/src/net/udpsock.go?s=9935:9999#L306">ListenUDP</a>
					<a class="permalink" href="#ListenUDP">&#xb6;</a>
					
					
				</h3>
				<pre>func ListenUDP(network <a href="/pkg/builtin/#string">string</a>, laddr *<a href="#UDPAddr">UDPAddr</a>) (*<a href="#UDPConn">UDPConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ListenUDP acts like ListenPacket for UDP networks.
<p>The network must be a UDP network name; see func Dial for details.
<p>If the IP field of laddr is nil or an unspecified IP address,
ListenUDP listens on all available IP addresses of the local system
except multicast IP addresses.
If the Port field of laddr is 0, a port number is automatically
chosen.

				
				
			

			
				
				<h3 id="UDPConn.Close">func (*UDPConn) <a href="/src/net/net.go?s=7529:7557#L199">Close</a>
					<a class="permalink" href="#UDPConn.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Close closes the connection.

				
				
				
			
				
				<h3 id="UDPConn.File">func (*UDPConn) <a href="/src/net/net.go?s=10192:10237#L294">File</a>
					<a class="permalink" href="#UDPConn.File">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) File() (f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>File returns a copy of the underlying <a href="/os#File">os.File</a>.
It is the caller&apos;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
<p>The returned os.File&apos;s file descriptor is different from the connection&apos;s.
Attempting to change properties of the original using this duplicate
may or may not have the desired effect.

				
				
				
			
				
				<h3 id="UDPConn.LocalAddr">func (*UDPConn) <a href="/src/net/net.go?s=7886:7917#L213">LocalAddr</a>
					<a class="permalink" href="#UDPConn.LocalAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) LocalAddr() <a href="#Addr">Addr</a></pre>
				<p>LocalAddr returns the local network address.
The Addr returned is shared by all invocations of LocalAddr, so
do not modify it.

				
				
				
			
				
				<h3 id="UDPConn.Read">func (*UDPConn) <a href="/src/net/net.go?s=6948:6990#L175">Read</a>
					<a class="permalink" href="#UDPConn.Read">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) Read(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Read implements the Conn Read method.

				
				
				
			
				
				<h3 id="UDPConn.ReadFrom">func (*UDPConn) <a href="/src/net/udpsock.go?s=4340:4395#L147">ReadFrom</a>
					<a class="permalink" href="#UDPConn.ReadFrom">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) ReadFrom(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="#Addr">Addr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadFrom implements the PacketConn ReadFrom method.

				
				
				
			
				
				<h3 id="UDPConn.ReadFromUDP">func (*UDPConn) <a href="/src/net/udpsock.go?s=3572:3645#L126">ReadFromUDP</a>
					<a class="permalink" href="#UDPConn.ReadFromUDP">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) ReadFromUDP(b []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, addr *<a href="#UDPAddr">UDPAddr</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadFromUDP acts like ReadFrom but returns a UDPAddr.

				
				
				
			
				
				<h3 id="UDPConn.ReadFromUDPAddrPort">func (*UDPConn) <a href="/src/net/udpsock.go?s=4824:4911#L161">ReadFromUDPAddrPort</a>
					<a class="permalink" href="#UDPConn.ReadFromUDPAddrPort">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) ReadFromUDPAddrPort(b []<a href="/pkg/builtin/#byte">byte</a>) (n <a href="/pkg/builtin/#int">int</a>, addr <a href="/pkg/net/netip/">netip</a>.<a href="/pkg/net/netip/#AddrPort">AddrPort</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadFromUDPAddrPort acts like ReadFrom but returns a netip.AddrPort.
<p>If c is bound to an unspecified address, the returned
netip.AddrPort&apos;s address might be an IPv4-mapped IPv6 address.
Use netip.Addr.Unmap to get the address without the IPv6 prefix.

				
				
				
			
				
				<h3 id="UDPConn.ReadMsgUDP">func (*UDPConn) <a href="/src/net/udpsock.go?s=5559:5649#L179">ReadMsgUDP</a>
					<a class="permalink" href="#UDPConn.ReadMsgUDP">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) ReadMsgUDP(b, oob []<a href="/pkg/builtin/#byte">byte</a>) (n, oobn, flags <a href="/pkg/builtin/#int">int</a>, addr *<a href="#UDPAddr">UDPAddr</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadMsgUDP reads a message from c, copying the payload into b and
the associated out-of-band data into oob. It returns the number of
bytes copied into b, the number of bytes copied into oob, the flags
that were set on the message and the source address of the message.
<p>The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be
used to manipulate IP-level socket options in oob.

				
				
				
			
				
				<h3 id="UDPConn.ReadMsgUDPAddrPort">func (*UDPConn) <a href="/src/net/udpsock.go?s=5890:5994#L189">ReadMsgUDPAddrPort</a>
					<a class="permalink" href="#UDPConn.ReadMsgUDPAddrPort">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) ReadMsgUDPAddrPort(b, oob []<a href="/pkg/builtin/#byte">byte</a>) (n, oobn, flags <a href="/pkg/builtin/#int">int</a>, addr <a href="/pkg/net/netip/">netip</a>.<a href="/pkg/net/netip/#AddrPort">AddrPort</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadMsgUDPAddrPort is like ReadMsgUDP but returns an netip.AddrPort instead of a UDPAddr.

				
				
				
			
				
				<h3 id="UDPConn.RemoteAddr">func (*UDPConn) <a href="/src/net/net.go?s=8111:8143#L223">RemoteAddr</a>
					<a class="permalink" href="#UDPConn.RemoteAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) RemoteAddr() <a href="#Addr">Addr</a></pre>
				<p>RemoteAddr returns the remote network address.
The Addr returned is shared by all invocations of RemoteAddr, so
do not modify it.

				
				
				
			
				
				<h3 id="UDPConn.SetDeadline">func (*UDPConn) <a href="/src/net/net.go?s=8253:8298#L231">SetDeadline</a>
					<a class="permalink" href="#UDPConn.SetDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetDeadline implements the Conn SetDeadline method.

				
				
				
			
				
				<h3 id="UDPConn.SetReadBuffer">func (*UDPConn) <a href="/src/net/net.go?s=9217:9262#L265">SetReadBuffer</a>
					<a class="permalink" href="#UDPConn.SetReadBuffer">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) SetReadBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetReadBuffer sets the size of the operating system&apos;s
receive buffer associated with the connection.

				
				
				
			
				
				<h3 id="UDPConn.SetReadDeadline">func (*UDPConn) <a href="/src/net/net.go?s=8553:8602#L242">SetReadDeadline</a>
					<a class="permalink" href="#UDPConn.SetReadDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) SetReadDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetReadDeadline implements the Conn SetReadDeadline method.

				
				
				
			
				
				<h3 id="UDPConn.SetWriteBuffer">func (*UDPConn) <a href="/src/net/net.go?s=9570:9616#L277">SetWriteBuffer</a>
					<a class="permalink" href="#UDPConn.SetWriteBuffer">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) SetWriteBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetWriteBuffer sets the size of the operating system&apos;s
transmit buffer associated with the connection.

				
				
				
			
				
				<h3 id="UDPConn.SetWriteDeadline">func (*UDPConn) <a href="/src/net/net.go?s=8863:8913#L253">SetWriteDeadline</a>
					<a class="permalink" href="#UDPConn.SetWriteDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) SetWriteDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetWriteDeadline implements the Conn SetWriteDeadline method.

				
				
				
			
				
				<h3 id="UDPConn.SyscallConn">func (*UDPConn) <a href="/src/net/udpsock.go?s=3377:3433#L118">SyscallConn</a>
					<a class="permalink" href="#UDPConn.SyscallConn">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) SyscallConn() (<a href="/pkg/syscall/">syscall</a>.<a href="/pkg/syscall/#RawConn">RawConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>SyscallConn returns a raw network connection.
This implements the syscall.Conn interface.

				
				
				
			
				
				<h3 id="UDPConn.Write">func (*UDPConn) <a href="/src/net/net.go?s=7251:7294#L187">Write</a>
					<a class="permalink" href="#UDPConn.Write">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) Write(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Write implements the Conn Write method.

				
				
				
			
				
				<h3 id="UDPConn.WriteMsgUDP">func (*UDPConn) <a href="/src/net/udpsock.go?s=7832:7916#L248">WriteMsgUDP</a>
					<a class="permalink" href="#UDPConn.WriteMsgUDP">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) WriteMsgUDP(b, oob []<a href="/pkg/builtin/#byte">byte</a>, addr *<a href="#UDPAddr">UDPAddr</a>) (n, oobn <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteMsgUDP writes a message to addr via c if c isn&apos;t connected, or
to c&apos;s remote address if c is connected (in which case addr must be
nil). The payload is copied from b and the associated out-of-band
data is copied from oob. It returns the number of payload and
out-of-band bytes written.
<p>The packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be
used to manipulate IP-level socket options in oob.

				
				
				
			
				
				<h3 id="UDPConn.WriteMsgUDPAddrPort">func (*UDPConn) <a href="/src/net/udpsock.go?s=8226:8324#L260">WriteMsgUDPAddrPort</a>
					<a class="permalink" href="#UDPConn.WriteMsgUDPAddrPort">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) WriteMsgUDPAddrPort(b, oob []<a href="/pkg/builtin/#byte">byte</a>, addr <a href="/pkg/net/netip/">netip</a>.<a href="/pkg/net/netip/#AddrPort">AddrPort</a>) (n, oobn <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteMsgUDPAddrPort is like WriteMsgUDP but takes a netip.AddrPort instead of a UDPAddr.

				
				
				
			
				
				<h3 id="UDPConn.WriteTo">func (*UDPConn) <a href="/src/net/udpsock.go?s=6993:7052#L225">WriteTo</a>
					<a class="permalink" href="#UDPConn.WriteTo">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) WriteTo(b []<a href="/pkg/builtin/#byte">byte</a>, addr <a href="#Addr">Addr</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteTo implements the PacketConn WriteTo method.

				
				<div id="example_UDPConn_WriteTo" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Unlike Dial, ListenPacket creates a connection without any</span>
<span class="comment">// association with peers.</span>
conn, err := net.ListenPacket(&#34;udp&#34;, &#34;:0&#34;)
if err != nil {
    log.Fatal(err)
}
defer conn.Close()

dst, err := net.ResolveUDPAddr(&#34;udp&#34;, &#34;192.0.2.1:2000&#34;)
if err != nil {
    log.Fatal(err)
}

<span class="comment">// The connection can write data to the desired address.</span>
_, err = conn.WriteTo([]byte(&#34;data&#34;), dst)
if err != nil {
    log.Fatal(err)
}
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="UDPConn.WriteToUDP">func (*UDPConn) <a href="/src/net/udpsock.go?s=6288:6354#L201">WriteToUDP</a>
					<a class="permalink" href="#UDPConn.WriteToUDP">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) WriteToUDP(b []<a href="/pkg/builtin/#byte">byte</a>, addr *<a href="#UDPAddr">UDPAddr</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteToUDP acts like WriteTo but takes a UDPAddr.

				
				
				
			
				
				<h3 id="UDPConn.WriteToUDPAddrPort">func (*UDPConn) <a href="/src/net/udpsock.go?s=6633:6713#L213">WriteToUDPAddrPort</a>
					<a class="permalink" href="#UDPConn.WriteToUDPAddrPort">&#xb6;</a>
					
					<span title="Added in Go 1.18">1.18</span>
				</h3>
				<pre>func (c *<a href="#UDPConn">UDPConn</a>) WriteToUDPAddrPort(b []<a href="/pkg/builtin/#byte">byte</a>, addr <a href="/pkg/net/netip/">netip</a>.<a href="/pkg/net/netip/#AddrPort">AddrPort</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteToUDPAddrPort acts like WriteTo but takes a netip.AddrPort.

				
				
				
			
		
			
			
			<h2 id="UnixAddr">type <a href="/src/net/unixsock.go?s=558:608#L12">UnixAddr</a>
				<a class="permalink" href="#UnixAddr">&#xb6;</a>
				
				
			</h2>
			<p>UnixAddr represents the address of a Unix domain socket end point.

			<pre>type UnixAddr struct {
<span id="UnixAddr.Name"></span>    Name <a href="/pkg/builtin/#string">string</a>
<span id="UnixAddr.Net"></span>    Net  <a href="/pkg/builtin/#string">string</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="ResolveUnixAddr">func <a href="/src/net/unixsock.go?s=1195:1259#L47">ResolveUnixAddr</a>
					<a class="permalink" href="#ResolveUnixAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func ResolveUnixAddr(network, address <a href="/pkg/builtin/#string">string</a>) (*<a href="#UnixAddr">UnixAddr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ResolveUnixAddr returns an address of Unix domain socket end point.
<p>The network must be a Unix network name.
<p>See func <a href="#Dial">Dial</a> for a description of the network and address
parameters.

				
				
			

			
				
				<h3 id="UnixAddr.Network">func (*UnixAddr) <a href="/src/net/unixsock.go?s=696:731#L19">Network</a>
					<a class="permalink" href="#UnixAddr.Network">&#xb6;</a>
					
					
				</h3>
				<pre>func (a *<a href="#UnixAddr">UnixAddr</a>) Network() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Network returns the address&apos;s network name, &quot;unix&quot;, &quot;unixgram&quot; or
&quot;unixpacket&quot;.

				
				
				
			
				
				<h3 id="UnixAddr.String">func (*UnixAddr) <a href="/src/net/unixsock.go?s=751:785#L23">String</a>
					<a class="permalink" href="#UnixAddr.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (a *<a href="#UnixAddr">UnixAddr</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="UnixConn">type <a href="/src/net/unixsock.go?s=1532:1562#L58">UnixConn</a>
				<a class="permalink" href="#UnixConn">&#xb6;</a>
				
				
			</h2>
			<p>UnixConn is an implementation of the <a href="#Conn">Conn</a> interface for connections
to Unix domain sockets.

			<pre>type UnixConn struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="DialUnix">func <a href="/src/net/unixsock.go?s=5640:5712#L193">DialUnix</a>
					<a class="permalink" href="#DialUnix">&#xb6;</a>
					
					
				</h3>
				<pre>func DialUnix(network <a href="/pkg/builtin/#string">string</a>, laddr, raddr *<a href="#UnixAddr">UnixAddr</a>) (*<a href="#UnixConn">UnixConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>DialUnix acts like <a href="#Dial">Dial</a> for Unix networks.
<p>The network must be a Unix network name; see func Dial for details.
<p>If laddr is non-nil, it is used as the local address for the
connection.

				
				
			
				
				<h3 id="ListenUnixgram">func <a href="/src/net/unixsock.go?s=9747:9818#L324">ListenUnixgram</a>
					<a class="permalink" href="#ListenUnixgram">&#xb6;</a>
					
					
				</h3>
				<pre>func ListenUnixgram(network <a href="/pkg/builtin/#string">string</a>, laddr *<a href="#UnixAddr">UnixAddr</a>) (*<a href="#UnixConn">UnixConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ListenUnixgram acts like <a href="#ListenPacket">ListenPacket</a> for Unix networks.
<p>The network must be &quot;unixgram&quot;.

				
				
			

			
				
				<h3 id="UnixConn.Close">func (*UnixConn) <a href="/src/net/net.go?s=7529:7557#L199">Close</a>
					<a class="permalink" href="#UnixConn.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Close closes the connection.

				
				
				
			
				
				<h3 id="UnixConn.CloseRead">func (*UnixConn) <a href="/src/net/unixsock.go?s=1912:1948#L73">CloseRead</a>
					<a class="permalink" href="#UnixConn.CloseRead">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) CloseRead() <a href="/pkg/builtin/#error">error</a></pre>
				<p>CloseRead shuts down the reading side of the Unix domain connection.
Most callers should just use Close.

				
				
				
			
				
				<h3 id="UnixConn.CloseWrite">func (*UnixConn) <a href="/src/net/unixsock.go?s=2258:2295#L85">CloseWrite</a>
					<a class="permalink" href="#UnixConn.CloseWrite">&#xb6;</a>
					
					<span title="Added in Go 1.1">1.1</span>
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) CloseWrite() <a href="/pkg/builtin/#error">error</a></pre>
				<p>CloseWrite shuts down the writing side of the Unix domain connection.
Most callers should just use Close.

				
				
				
			
				
				<h3 id="UnixConn.File">func (*UnixConn) <a href="/src/net/net.go?s=10192:10237#L294">File</a>
					<a class="permalink" href="#UnixConn.File">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) File() (f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>File returns a copy of the underlying <a href="/os#File">os.File</a>.
It is the caller&apos;s responsibility to close f when finished.
Closing c does not affect f, and closing f does not affect c.
<p>The returned os.File&apos;s file descriptor is different from the connection&apos;s.
Attempting to change properties of the original using this duplicate
may or may not have the desired effect.

				
				
				
			
				
				<h3 id="UnixConn.LocalAddr">func (*UnixConn) <a href="/src/net/net.go?s=7886:7917#L213">LocalAddr</a>
					<a class="permalink" href="#UnixConn.LocalAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) LocalAddr() <a href="#Addr">Addr</a></pre>
				<p>LocalAddr returns the local network address.
The Addr returned is shared by all invocations of LocalAddr, so
do not modify it.

				
				
				
			
				
				<h3 id="UnixConn.Read">func (*UnixConn) <a href="/src/net/net.go?s=6948:6990#L175">Read</a>
					<a class="permalink" href="#UnixConn.Read">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) Read(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Read implements the Conn Read method.

				
				
				
			
				
				<h3 id="UnixConn.ReadFrom">func (*UnixConn) <a href="/src/net/unixsock.go?s=2907:2963#L108">ReadFrom</a>
					<a class="permalink" href="#UnixConn.ReadFrom">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) ReadFrom(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="#Addr">Addr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadFrom implements the <a href="#PacketConn">PacketConn</a> ReadFrom method.

				
				
				
			
				
				<h3 id="UnixConn.ReadFromUnix">func (*UnixConn) <a href="/src/net/unixsock.go?s=2566:2631#L96">ReadFromUnix</a>
					<a class="permalink" href="#UnixConn.ReadFromUnix">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) ReadFromUnix(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, *<a href="#UnixAddr">UnixAddr</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadFromUnix acts like <a href="#UnixConn.ReadFrom">UnixConn.ReadFrom</a> but returns a <a href="#UnixAddr">UnixAddr</a>.

				
				
				
			
				
				<h3 id="UnixConn.ReadMsgUnix">func (*UnixConn) <a href="/src/net/unixsock.go?s=3630:3723#L129">ReadMsgUnix</a>
					<a class="permalink" href="#UnixConn.ReadMsgUnix">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) ReadMsgUnix(b, oob []<a href="/pkg/builtin/#byte">byte</a>) (n, oobn, flags <a href="/pkg/builtin/#int">int</a>, addr *<a href="#UnixAddr">UnixAddr</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ReadMsgUnix reads a message from c, copying the payload into b and
the associated out-of-band data into oob. It returns the number of
bytes copied into b, the number of bytes copied into oob, the flags
that were set on the message and the source address of the message.
<p>Note that if len(b) == 0 and len(oob) &gt; 0, this function will still
read (and discard) 1 byte from the connection.

				
				
				
			
				
				<h3 id="UnixConn.RemoteAddr">func (*UnixConn) <a href="/src/net/net.go?s=8111:8143#L223">RemoteAddr</a>
					<a class="permalink" href="#UnixConn.RemoteAddr">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) RemoteAddr() <a href="#Addr">Addr</a></pre>
				<p>RemoteAddr returns the remote network address.
The Addr returned is shared by all invocations of RemoteAddr, so
do not modify it.

				
				
				
			
				
				<h3 id="UnixConn.SetDeadline">func (*UnixConn) <a href="/src/net/net.go?s=8253:8298#L231">SetDeadline</a>
					<a class="permalink" href="#UnixConn.SetDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetDeadline implements the Conn SetDeadline method.

				
				
				
			
				
				<h3 id="UnixConn.SetReadBuffer">func (*UnixConn) <a href="/src/net/net.go?s=9217:9262#L265">SetReadBuffer</a>
					<a class="permalink" href="#UnixConn.SetReadBuffer">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) SetReadBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetReadBuffer sets the size of the operating system&apos;s
receive buffer associated with the connection.

				
				
				
			
				
				<h3 id="UnixConn.SetReadDeadline">func (*UnixConn) <a href="/src/net/net.go?s=8553:8602#L242">SetReadDeadline</a>
					<a class="permalink" href="#UnixConn.SetReadDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) SetReadDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetReadDeadline implements the Conn SetReadDeadline method.

				
				
				
			
				
				<h3 id="UnixConn.SetWriteBuffer">func (*UnixConn) <a href="/src/net/net.go?s=9570:9616#L277">SetWriteBuffer</a>
					<a class="permalink" href="#UnixConn.SetWriteBuffer">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) SetWriteBuffer(bytes <a href="/pkg/builtin/#int">int</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetWriteBuffer sets the size of the operating system&apos;s
transmit buffer associated with the connection.

				
				
				
			
				
				<h3 id="UnixConn.SetWriteDeadline">func (*UnixConn) <a href="/src/net/net.go?s=8863:8913#L253">SetWriteDeadline</a>
					<a class="permalink" href="#UnixConn.SetWriteDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) SetWriteDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetWriteDeadline implements the Conn SetWriteDeadline method.

				
				
				
			
				
				<h3 id="UnixConn.SyscallConn">func (*UnixConn) <a href="/src/net/unixsock.go?s=1662:1719#L64">SyscallConn</a>
					<a class="permalink" href="#UnixConn.SyscallConn">&#xb6;</a>
					
					<span title="Added in Go 1.9">1.9</span>
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) SyscallConn() (<a href="/pkg/syscall/">syscall</a>.<a href="/pkg/syscall/#RawConn">RawConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>SyscallConn returns a raw network connection.
This implements the <a href="/syscall#Conn">syscall.Conn</a> interface.

				
				
				
			
				
				<h3 id="UnixConn.Write">func (*UnixConn) <a href="/src/net/net.go?s=7251:7294#L187">Write</a>
					<a class="permalink" href="#UnixConn.Write">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) Write(b []<a href="/pkg/builtin/#byte">byte</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Write implements the Conn Write method.

				
				
				
			
				
				<h3 id="UnixConn.WriteMsgUnix">func (*UnixConn) <a href="/src/net/unixsock.go?s=5061:5148#L174">WriteMsgUnix</a>
					<a class="permalink" href="#UnixConn.WriteMsgUnix">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) WriteMsgUnix(b, oob []<a href="/pkg/builtin/#byte">byte</a>, addr *<a href="#UnixAddr">UnixAddr</a>) (n, oobn <a href="/pkg/builtin/#int">int</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteMsgUnix writes a message to addr via c, copying the payload
from b and the associated out-of-band data from oob. It returns the
number of payload and out-of-band bytes written.
<p>Note that if len(b) == 0 and len(oob) &gt; 0, this function will still
write 1 byte to the connection.

				
				
				
			
				
				<h3 id="UnixConn.WriteTo">func (*UnixConn) <a href="/src/net/unixsock.go?s=4354:4414#L153">WriteTo</a>
					<a class="permalink" href="#UnixConn.WriteTo">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) WriteTo(b []<a href="/pkg/builtin/#byte">byte</a>, addr <a href="#Addr">Addr</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteTo implements the <a href="#PacketConn">PacketConn</a> WriteTo method.

				
				
				
			
				
				<h3 id="UnixConn.WriteToUnix">func (*UnixConn) <a href="/src/net/unixsock.go?s=4019:4088#L141">WriteToUnix</a>
					<a class="permalink" href="#UnixConn.WriteToUnix">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#UnixConn">UnixConn</a>) WriteToUnix(b []<a href="/pkg/builtin/#byte">byte</a>, addr *<a href="#UnixAddr">UnixAddr</a>) (<a href="/pkg/builtin/#int">int</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>WriteToUnix acts like <a href="#UnixConn.WriteTo">UnixConn.WriteTo</a> but takes a <a href="#UnixAddr">UnixAddr</a>.

				
				
				
			
		
			
			
			<h2 id="UnixListener">type <a href="/src/net/unixsock.go?s=6334:6439#L210">UnixListener</a>
				<a class="permalink" href="#UnixListener">&#xb6;</a>
				
				
			</h2>
			<p>UnixListener is a Unix domain socket listener. Clients should
typically use variables of type <a href="#Listener">Listener</a> instead of assuming Unix
domain sockets.

			<pre>type UnixListener struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="ListenUnix">func <a href="/src/net/unixsock.go?s=9008:9079#L304">ListenUnix</a>
					<a class="permalink" href="#ListenUnix">&#xb6;</a>
					
					
				</h3>
				<pre>func ListenUnix(network <a href="/pkg/builtin/#string">string</a>, laddr *<a href="#UnixAddr">UnixAddr</a>) (*<a href="#UnixListener">UnixListener</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>ListenUnix acts like <a href="#Listen">Listen</a> for Unix networks.
<p>The network must be &quot;unix&quot; or &quot;unixpacket&quot;.

				
				
			

			
				
				<h3 id="UnixListener.Accept">func (*UnixListener) <a href="/src/net/unixsock.go?s=7308:7353#L246">Accept</a>
					<a class="permalink" href="#UnixListener.Accept">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#UnixListener">UnixListener</a>) Accept() (<a href="#Conn">Conn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>Accept implements the Accept method in the <a href="#Listener">Listener</a> interface.
Returned connections will be of type <a href="#UnixConn">*UnixConn</a>.

				
				
				
			
				
				<h3 id="UnixListener.AcceptUnix">func (*UnixListener) <a href="/src/net/unixsock.go?s=6931:6985#L233">AcceptUnix</a>
					<a class="permalink" href="#UnixListener.AcceptUnix">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#UnixListener">UnixListener</a>) AcceptUnix() (*<a href="#UnixConn">UnixConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>AcceptUnix accepts the next incoming call and returns the new
connection.

				
				
				
			
				
				<h3 id="UnixListener.Addr">func (*UnixListener) <a href="/src/net/unixsock.go?s=8000:8034#L272">Addr</a>
					<a class="permalink" href="#UnixListener.Addr">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#UnixListener">UnixListener</a>) Addr() <a href="#Addr">Addr</a></pre>
				<p>Addr returns the listener&apos;s network address.
The Addr returned is shared by all invocations of Addr, so
do not modify it.

				
				
				
			
				
				<h3 id="UnixListener.Close">func (*UnixListener) <a href="/src/net/unixsock.go?s=7649:7685#L259">Close</a>
					<a class="permalink" href="#UnixListener.Close">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#UnixListener">UnixListener</a>) Close() <a href="/pkg/builtin/#error">error</a></pre>
				<p>Close stops listening on the Unix address. Already accepted
connections are not closed.

				
				
				
			
				
				<h3 id="UnixListener.File">func (*UnixListener) <a href="/src/net/unixsock.go?s=8669:8722#L290">File</a>
					<a class="permalink" href="#UnixListener.File">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#UnixListener">UnixListener</a>) File() (f *<a href="/pkg/os/">os</a>.<a href="/pkg/os/#File">File</a>, err <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>File returns a copy of the underlying <a href="/os#File">os.File</a>.
It is the caller&apos;s responsibility to close f when finished.
Closing l does not affect f, and closing f does not affect l.
<p>The returned os.File&apos;s file descriptor is different from the
connection&apos;s. Attempting to change properties of the original
using this duplicate may or may not have the desired effect.

				
				
				
			
				
				<h3 id="UnixListener.SetDeadline">func (*UnixListener) <a href="/src/net/unixsock.go?s=8165:8218#L276">SetDeadline</a>
					<a class="permalink" href="#UnixListener.SetDeadline">&#xb6;</a>
					
					
				</h3>
				<pre>func (l *<a href="#UnixListener">UnixListener</a>) SetDeadline(t <a href="/pkg/time/">time</a>.<a href="/pkg/time/#Time">Time</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>SetDeadline sets the deadline associated with the listener.
A zero time value disables the deadline.

				
				
				
			
				
				<h3 id="UnixListener.SetUnlinkOnClose">func (*UnixListener) <a href="/src/net/unixsock_posix.go?s=5636:5688#L205">SetUnlinkOnClose</a>
					<a class="permalink" href="#UnixListener.SetUnlinkOnClose">&#xb6;</a>
					
					<span title="Added in Go 1.8">1.8</span>
				</h3>
				<pre>func (l *<a href="#UnixListener">UnixListener</a>) SetUnlinkOnClose(unlink <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>SetUnlinkOnClose sets whether the underlying socket file should be removed
from the file system when the listener is closed.
<p>The default behavior is to unlink the socket file only when package net created it.
That is, when the listener and the underlying socket file were created by a call to
Listen or ListenUnix, then by default closing the listener will remove the socket file.
but if the listener was created by a call to FileListener to use an already existing
socket file, then by default closing the listener will not remove the socket file.

				
				
				
			
				
				<h3 id="UnixListener.SyscallConn">func (*UnixListener) <a href="/src/net/unixsock.go?s=6704:6765#L224">SyscallConn</a>
					<a class="permalink" href="#UnixListener.SyscallConn">&#xb6;</a>
					
					<span title="Added in Go 1.10">1.10</span>
				</h3>
				<pre>func (l *<a href="#UnixListener">UnixListener</a>) SyscallConn() (<a href="/pkg/syscall/">syscall</a>.<a href="/pkg/syscall/#RawConn">RawConn</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				<p>SyscallConn returns a raw network connection.
This implements the <a href="/syscall#Conn">syscall.Conn</a> interface.
<p>The returned RawConn only supports calling Control. Read and
Write return an error.

				
				
				
			
		
			
			
			<h2 id="UnknownNetworkError">type <a href="/src/net/net.go?s=18701:18732#L581">UnknownNetworkError</a>
				<a class="permalink" href="#UnknownNetworkError">&#xb6;</a>
				
				
			</h2>
			
			<pre>type UnknownNetworkError <a href="/pkg/builtin/#string">string</a></pre>

			

			

			
			
			

			

			
				
				<h3 id="UnknownNetworkError.Error">func (UnknownNetworkError) <a href="/src/net/net.go?s=18734:18777#L583">Error</a>
					<a class="permalink" href="#UnknownNetworkError.Error">&#xb6;</a>
					
					
				</h3>
				<pre>func (e <a href="#UnknownNetworkError">UnknownNetworkError</a>) Error() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="UnknownNetworkError.Temporary">func (UnknownNetworkError) <a href="/src/net/net.go?s=18885:18930#L585">Temporary</a>
					<a class="permalink" href="#UnknownNetworkError.Temporary">&#xb6;</a>
					
					
				</h3>
				<pre>func (e <a href="#UnknownNetworkError">UnknownNetworkError</a>) Temporary() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
				
				<h3 id="UnknownNetworkError.Timeout">func (UnknownNetworkError) <a href="/src/net/net.go?s=18822:18865#L584">Timeout</a>
					<a class="permalink" href="#UnknownNetworkError.Timeout">&#xb6;</a>
					
					
				</h3>
				<pre>func (e <a href="#UnknownNetworkError">UnknownNetworkError</a>) Timeout() <a href="/pkg/builtin/#bool">bool</a></pre>
				
				
				
				
			
		
	

	
		
			<h2 id="pkg-note-BUG">Bugs</h2>
			<ul style="list-style: none; padding: 0;">
			
			<li><a href="/src/net/file.go?s=186:299#L1" style="float: left;">&#x261e;</a> <p>On JS and Windows, the FileConn, FileListener and
FilePacketConn functions are not implemented.
</li>
			
			<li><a href="/src/net/interface.go?s=240:328#L5" style="float: left;">&#x261e;</a> <p>On JS, methods and functions related to
Interface are not implemented.
</li>
			
			<li><a href="/src/net/interface.go?s=330:466#L8" style="float: left;">&#x261e;</a> <p>On AIX, DragonFly BSD, NetBSD, OpenBSD, Plan 9 and
Solaris, the MulticastAddrs method of Interface is not implemented.
</li>
			
			<li><a href="/src/net/iprawsock.go?s=207:773#L2" style="float: left;">&#x261e;</a> <p>On every POSIX platform, reads from the &quot;ip4&quot; network
using the ReadFrom or ReadFromIP method might not return a complete
IPv4 packet, including its header, even if there is space
available. This can occur even in cases where Read or ReadMsgIP
could return a complete packet. For this reason, it is recommended
that you do not use these methods if it is important to receive a
full packet.
<p>The Go 1 compatibility guidelines make it impossible for us to
change the behavior of these methods; use Read or ReadMsgIP
instead.
</li>
			
			<li><a href="/src/net/iprawsock.go?s=775:871#L14" style="float: left;">&#x261e;</a> <p>On JS and Plan 9, methods and functions related
to IPConn are not implemented.
</li>
			
			<li><a href="/src/net/iprawsock.go?s=873:948#L17" style="float: left;">&#x261e;</a> <p>On Windows, the File method of IPConn is not
implemented.
</li>
			
			<li><a href="/src/net/ipsock.go?s=263:607#L5" style="float: left;">&#x261e;</a> <p>On DragonFly BSD and OpenBSD, listening on the
&quot;tcp&quot; and &quot;udp&quot; networks does not listen for both IPv4 and IPv6
connections. This is due to the fact that IPv4 traffic will not be
routed to an IPv6 socket - two separate sockets are required if
both address families are to be supported.
See inet6(4) for details.
</li>
			
			<li><a href="/src/net/rawconn.go?s=224:523#L3" style="float: left;">&#x261e;</a> <p>On Windows, the Write method of syscall.RawConn
does not integrate with the runtime&apos;s network poller. It cannot
wait for the connection to become writeable, and does not respect
deadlines. If the user-provided callback returns false, the Write
method will fail immediately.
</li>
			
			<li><a href="/src/net/rawconn.go?s=525:636#L9" style="float: left;">&#x261e;</a> <p>On JS and Plan 9, the Control, Read and Write
methods of syscall.RawConn are not implemented.
</li>
			
			<li><a href="/src/net/tcpsock.go?s=257:356#L7" style="float: left;">&#x261e;</a> <p>On JS and Windows, the File method of TCPConn and
TCPListener is not implemented.
</li>
			
			<li><a href="/src/net/udpsock.go?s=237:336#L4" style="float: left;">&#x261e;</a> <p>On Plan 9, the ReadMsgUDP and
WriteMsgUDP methods of UDPConn are not implemented.
</li>
			
			<li><a href="/src/net/udpsock.go?s=338:414#L7" style="float: left;">&#x261e;</a> <p>On Windows, the File method of UDPConn is not
implemented.
</li>
			
			<li><a href="/src/net/udpsock.go?s=416:502#L10" style="float: left;">&#x261e;</a> <p>On JS, methods and functions related to UDPConn are not
implemented.
</li>
			
			<li><a href="/src/net/unixsock.go?s=229:352#L5" style="float: left;">&#x261e;</a> <p>On JS, WASIP1 and Plan 9, methods and functions related
to UnixConn and UnixListener are not implemented.
</li>
			
			<li><a href="/src/net/unixsock.go?s=354:486#L8" style="float: left;">&#x261e;</a> <p>On Windows, methods and functions related to UnixConn
and UnixListener don&apos;t work for &quot;unixgram&quot; and &quot;unixpacket&quot;.
</li>
			
			</ul>
		
	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="..">..</a></td>
			</tr>
			

			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="http/">http</a>
					</td>
				
					<td class="pkg-synopsis">
						Package http provides HTTP client and server implementations.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="http/cgi/">cgi</a>
					</td>
				
					<td class="pkg-synopsis">
						Package cgi implements CGI (Common Gateway Interface) as specified in RFC 3875.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="http/cookiejar/">cookiejar</a>
					</td>
				
					<td class="pkg-synopsis">
						Package cookiejar implements an in-memory RFC 6265-compliant http.CookieJar.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="http/fcgi/">fcgi</a>
					</td>
				
					<td class="pkg-synopsis">
						Package fcgi implements the FastCGI protocol.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="http/httptest/">httptest</a>
					</td>
				
					<td class="pkg-synopsis">
						Package httptest provides utilities for HTTP testing.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="http/httptrace/">httptrace</a>
					</td>
				
					<td class="pkg-synopsis">
						Package httptrace provides mechanisms to trace the events within HTTP client requests.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="http/httputil/">httputil</a>
					</td>
				
					<td class="pkg-synopsis">
						Package httputil provides HTTP utility functions, complementing the more common ones in the net/http package.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="http/pprof/">pprof</a>
					</td>
				
					<td class="pkg-synopsis">
						Package pprof serves via its HTTP server runtime profiling data in the format expected by the pprof visualization tool.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="mail/">mail</a>
					</td>
				
					<td class="pkg-synopsis">
						Package mail implements parsing of mail messages.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="netip/">netip</a>
					</td>
				
					<td class="pkg-synopsis">
						Package netip defines an IP address type that&#39;s a small value type.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="rpc/">rpc</a>
					</td>
				
					<td class="pkg-synopsis">
						Package rpc provides access to the exported methods of an object across a network or other I/O connection.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 20px;">
						<a href="rpc/jsonrpc/">jsonrpc</a>
					</td>
				
					<td class="pkg-synopsis">
						Package jsonrpc implements a JSON-RPC 1.0 ClientCodec and ServerCodec for the rpc package.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="smtp/">smtp</a>
					</td>
				
					<td class="pkg-synopsis">
						Package smtp implements the Simple Mail Transfer Protocol as defined in RFC 5321.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="textproto/">textproto</a>
					</td>
				
					<td class="pkg-synopsis">
						Package textproto implements generic support for text-based request/response protocols in the style of HTTP, NNTP, and SMTP.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="url/">url</a>
					</td>
				
					<td class="pkg-synopsis">
						Package url parses URLs and implements query escaping.
					</td>
				</tr>
			
		</table>
	</div>



<div id="footer">
Build version go1.23.0.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
