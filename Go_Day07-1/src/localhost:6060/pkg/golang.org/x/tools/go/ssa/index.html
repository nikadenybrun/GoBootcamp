<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="theme-color" content="#375EAB">

  <title>ssa - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="/lib/godoc/style.css">

<script>window.initFuncs = [];</script>
<script src="/lib/godoc/jquery.js" defer></script>



<script>var goVersion = "go1.23.0";</script>
<script src="/lib/godoc/godocs.js" defer></script>
</head>
<body>

<div id='lowframe' style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="/pkg/">GoDoc</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">&#9661;</span></a>
<form method="GET" action="/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"/><path d="M0 0h24v24H0z" fill="none"/></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package ssa
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import "golang.org/x/tools/go/ssa"</code></dd>
			</dl>
			<dl>
			<dd><a href="#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
				<dd><a href="#pkg-subdirectories">Subdirectories</a></dd>
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>Package ssa defines a representation of the elements of Go programs
(packages, types, functions, variables and constants) using a
static single-assignment (SSA) form intermediate representation
(IR) for the bodies of functions.
<p>For an introduction to SSA form, see
<a href="http://en.wikipedia.org/wiki/Static_single_assignment_form">http://en.wikipedia.org/wiki/Static_single_assignment_form</a>.
This page provides a broader reading list:
<a href="http://www.dcs.gla.ac.uk/~jsinger/ssa.html">http://www.dcs.gla.ac.uk/~jsinger/ssa.html</a>.
<p>The level of abstraction of the SSA form is intentionally close to
the source language to facilitate construction of source analysis
tools.  It is not intended for machine code generation.
<p>All looping, branching and switching constructs are replaced with
unstructured control flow.  Higher-level control flow constructs
such as multi-way branch can be reconstructed as needed; see
<a href="/golang.org/x/tools/go/ssa/ssautil#Switches">golang.org/x/tools/go/ssa/ssautil.Switches</a> for an example.
<p>The simplest way to create the SSA representation of a package is
to load typed syntax trees using <a href="/golang.org/x/tools/go/packages">golang.org/x/tools/go/packages</a>, then
invoke the <a href="/golang.org/x/tools/go/ssa/ssautil#Packages">golang.org/x/tools/go/ssa/ssautil.Packages</a> helper function.
(See the package-level Examples named LoadPackages and LoadWholeProgram.)
The resulting <a href="#Program">ssa.Program</a> contains all the packages and their
members, but SSA code is not created for function bodies until a
subsequent call to <a href="#Package.Build">Package.Build</a> or <a href="#Program.Build">Program.Build</a>.
<p>The builder initially builds a naive SSA form in which all local
variables are addresses of stack locations with explicit loads and
stores.  Registerisation of eligible locals and φ-node insertion
using dominance and dataflow are then performed as a second pass
called &quot;lifting&quot; to improve the accuracy and performance of
subsequent analyses; this pass can be skipped by setting the
NaiveForm builder flag.
<p>The primary interfaces of this package are:
<ul>
<li><a href="#Member">Member</a>: a named member of a Go package.
<li><a href="#Value">Value</a>: an expression that yields a value.
<li><a href="#Instruction">Instruction</a>: a statement that consumes values and performs computation.
<li><a href="#Node">Node</a>: a <a href="#Value">Value</a> or <a href="#Instruction">Instruction</a> (emphasizing its membership in the SSA value graph)
</ul>
<p>A computation that yields a result implements both the <a href="#Value">Value</a> and
<a href="#Instruction">Instruction</a> interfaces.  The following table shows for each
concrete type which of these interfaces it implements.
<pre>                   Value?          Instruction?      Member?
*Alloc                ✔               ✔
*BinOp                ✔               ✔
*Builtin              ✔
*Call                 ✔               ✔
*ChangeInterface      ✔               ✔
*ChangeType           ✔               ✔
*Const                ✔
*Convert              ✔               ✔
*DebugRef                             ✔
*Defer                                ✔
*Extract              ✔               ✔
*Field                ✔               ✔
*FieldAddr            ✔               ✔
*FreeVar              ✔
*Function             ✔                               ✔ (func)
*Global               ✔                               ✔ (var)
*Go                                   ✔
*If                                   ✔
*Index                ✔               ✔
*IndexAddr            ✔               ✔
*Jump                                 ✔
*Lookup               ✔               ✔
*MakeChan             ✔               ✔
*MakeClosure          ✔               ✔
*MakeInterface        ✔               ✔
*MakeMap              ✔               ✔
*MakeSlice            ✔               ✔
*MapUpdate                            ✔
*MultiConvert         ✔               ✔
*NamedConst                                           ✔ (const)
*Next                 ✔               ✔
*Panic                                ✔
*Parameter            ✔
*Phi                  ✔               ✔
*Range                ✔               ✔
*Return                               ✔
*RunDefers                            ✔
*Select               ✔               ✔
*Send                                 ✔
*Slice                ✔               ✔
*SliceToArrayPointer  ✔               ✔
*Store                                ✔
*Type                                                 ✔ (type)
*TypeAssert           ✔               ✔
*UnOp                 ✔               ✔
</pre>
<p>Other key types in this package include: <a href="#Program">Program</a>, <a href="#Package">Package</a>, <a href="#Function">Function</a>
and <a href="#BasicBlock">BasicBlock</a>.
<p>The program representation constructed by this package is fully
resolved internally, i.e. it does not rely on the names of Values,
Packages, Functions, Types or BasicBlocks for the correct
interpretation of the program.  Only the identities of objects and
the topology of the SSA and type graphs are semantically
significant.  (There is one exception: <a href="/go/types#Id">types.Id</a> values, which identify field
and method names, contain strings.)  Avoidance of name-based
operations simplifies the implementation of subsequent passes and
can make them very efficient.  Many objects are nonetheless named
to aid in debugging, but it is not essential that the names be
either accurate or unambiguous.  The public API exposes a number of
name-based maps for client convenience.
<p>The <a href="/golang.org/x/tools/go/ssa/ssautil">golang.org/x/tools/go/ssa/ssautil</a> package provides various
helper functions, for example to simplify loading a Go program into
SSA form.
<p>TODO(adonovan): write a how-to document for all the various cases
of trying to determine corresponding elements across the four
domains of source locations, ast.Nodes, types.Objects,
ssa.Values/Instructions.

				<div id="example__buildPackage" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (BuildPackage)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (BuildPackage)</span></p>
		<p>This program demonstrates how to run the SSA builder on a single
package of one or more already-parsed files. Its dependencies are
loaded from compiler export data. This is what you&#39;d typically use
for a compiler; it does not depend on the obsolete
[golang.org/x/tools/go/loader].

It shows the printed representation of packages, functions, and
instructions.  Within the function listing, the name of each
BasicBlock such as &#34;.0.entry&#34; is printed left-aligned, followed by
the block&#39;s Instructions.

For each instruction that defines an SSA virtual register
(i.e. implements Value), the type of that value is shown in the
right column.

Build and run the ssadump.go program if you want a standalone tool
with similar functionality. It is located at
[golang.org/x/tools/cmd/ssadump].

Use ssautil.BuildPackage only if you have parsed--but not
type-checked--syntax trees. Typically, clients already have typed
syntax, perhaps obtained from golang.org/x/tools/go/packages.
In that case, see the other examples for simpler approaches.
</p>
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Replace interface{} with any for this test.</span>
ssa.SetNormalizeAnyForTesting(true)
defer ssa.SetNormalizeAnyForTesting(false)
<span class="comment">// Parse the source files.</span>
fset := token.NewFileSet()
f, err := parser.ParseFile(fset, &#34;hello.go&#34;, hello, parser.ParseComments)
if err != nil {
    fmt.Print(err) <span class="comment">// parse error</span>
    return
}
files := []*ast.File{f}

<span class="comment">// Create the type-checker&#39;s package.</span>
pkg := types.NewPackage(&#34;hello&#34;, &#34;&#34;)

<span class="comment">// Type-check the package, load dependencies.</span>
<span class="comment">// Create and build the SSA program.</span>
hello, _, err := ssautil.BuildPackage(
    &amp;types.Config{Importer: importer.Default()}, fset, pkg, files, ssa.SanityCheckFunctions)
if err != nil {
    fmt.Print(err) <span class="comment">// type error in some package</span>
    return
}

<span class="comment">// Print out the package.</span>
hello.WriteTo(os.Stdout)

<span class="comment">// Print out the package-level functions.</span>
hello.Func(&#34;init&#34;).WriteTo(os.Stdout)
hello.Func(&#34;main&#34;).WriteTo(os.Stdout)

<span class="comment"></pre>
			
			<p>Output:</p>
			<pre class="output">
package hello:
  func  init       func()
  var   init$guard bool
  func  main       func()
  const message    message = &#34;Hello, World!&#34;:untyped string

# Name: hello.init
# Package: hello
# Synthetic: package initializer
func init():
0:                                                                entry P:0 S:2
	t0 = *init$guard                                                   bool
	if t0 goto 2 else 1
1:                                                           init.start P:1 S:1
	*init$guard = true:bool
	t1 = fmt.init()                                                      ()
	jump 2
2:                                                            init.done P:2 S:0
	return

# Name: hello.main
# Package: hello
# Location: hello.go:8:6
func main():
0:                                                                entry P:0 S:0
	t0 = new [1]any (varargs)                                       *[1]any
	t1 = &amp;t0[0:int]                                                    *any
	t2 = make any &lt;- string (&#34;Hello, World!&#34;:string)                    any
	*t1 = t2
	t3 = slice t0[:]                                                  []any
	t4 = fmt.Println(t3...)                              (n int, err error)
	return
</pre>
			
		
	</div>
</div>
<div id="example__loadPackages" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (LoadPackages)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (LoadPackages)</span></p>
		<p>This example builds SSA code for a set of packages using the
[golang.org/x/tools/go/packages] API. This is what you would typically use for a
analysis capable of operating on a single package.
</p>
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Load, parse, and type-check the initial packages.</span>
cfg := &amp;packages.Config{Mode: packages.LoadSyntax}
initial, err := packages.Load(cfg, &#34;fmt&#34;, &#34;net/http&#34;)
if err != nil {
    log.Fatal(err)
}

<span class="comment">// Stop if any package had errors.</span>
<span class="comment">// This step is optional; without it, the next step</span>
<span class="comment">// will create SSA for only a subset of packages.</span>
if packages.PrintErrors(initial) &gt; 0 {
    log.Fatalf(&#34;packages contain errors&#34;)
}

<span class="comment">// Create SSA packages for all well-typed packages.</span>
prog, pkgs := ssautil.Packages(initial, ssa.PrintPackages)
_ = prog

<span class="comment">// Build SSA code for the well-typed initial packages.</span>
for _, p := range pkgs {
    if p != nil {
        p.Build()
    }
}
</pre>
			
		
	</div>
</div>
<div id="example__loadWholeProgram" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example (LoadWholeProgram)</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example (LoadWholeProgram)</span></p>
		<p>This example builds SSA code for a set of packages plus all their dependencies,
using the [golang.org/x/tools/go/packages] API.
This is what you&#39;d typically use for a whole-program analysis.
</p>
		
		
			<p>Code:</p>
			<pre class="code">
<span class="comment">// Load, parse, and type-check the whole program.</span>
cfg := packages.Config{Mode: packages.LoadAllSyntax}
initial, err := packages.Load(&amp;cfg, &#34;fmt&#34;, &#34;net/http&#34;)
if err != nil {
    log.Fatal(err)
}

<span class="comment">// Create SSA packages for well-typed packages and their dependencies.</span>
prog, pkgs := ssautil.AllPackages(initial, ssa.PrintPackages|ssa.InstantiateGenerics)
_ = pkgs

<span class="comment">// Build SSA code for the whole program.</span>
prog.Build()
</pre>
			
		
	</div>
</div>

			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="#pkg-constants">Constants</a></dd>
			
			
			
				
				<dd><a href="#HasEnclosingFunction">func HasEnclosingFunction(pkg *Package, path []ast.Node) bool</a></dd>
			
				
				<dd><a href="#WriteFunction">func WriteFunction(buf *bytes.Buffer, f *Function)</a></dd>
			
				
				<dd><a href="#WritePackage">func WritePackage(buf *bytes.Buffer, p *Package)</a></dd>
			
			
				
				<dd><a href="#Alloc">type Alloc</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Alloc.Name">func (v *Alloc) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alloc.Operands">func (v *Alloc) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alloc.Pos">func (v *Alloc) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alloc.Referrers">func (v *Alloc) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alloc.String">func (v *Alloc) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Alloc.Type">func (v *Alloc) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#BasicBlock">type BasicBlock</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BasicBlock.Dominates">func (b *BasicBlock) Dominates(c *BasicBlock) bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BasicBlock.Dominees">func (b *BasicBlock) Dominees() []*BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BasicBlock.Idom">func (b *BasicBlock) Idom() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BasicBlock.Parent">func (b *BasicBlock) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BasicBlock.String">func (b *BasicBlock) String() string</a></dd>
				
			
				
				<dd><a href="#BinOp">type BinOp</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BinOp.Name">func (v *BinOp) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BinOp.Operands">func (v *BinOp) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BinOp.Pos">func (v *BinOp) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BinOp.Referrers">func (v *BinOp) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BinOp.String">func (v *BinOp) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BinOp.Type">func (v *BinOp) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#BuilderMode">type BuilderMode</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#BuilderMode.Get">func (m BuilderMode) Get() interface{}</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BuilderMode.Set">func (m *BuilderMode) Set(s string) error</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#BuilderMode.String">func (m BuilderMode) String() string</a></dd>
				
			
				
				<dd><a href="#Builtin">type Builtin</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.Name">func (v *Builtin) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.Object">func (v *Builtin) Object() types.Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.Operands">func (v *Builtin) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.Parent">func (v *Builtin) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.Pos">func (v *Builtin) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.Referrers">func (*Builtin) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.String">func (v *Builtin) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Builtin.Type">func (v *Builtin) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#Call">type Call</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Call.Common">func (s *Call) Common() *CallCommon</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Call.Name">func (v *Call) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Call.Operands">func (s *Call) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Call.Pos">func (v *Call) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Call.Referrers">func (v *Call) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Call.String">func (v *Call) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Call.Type">func (v *Call) Type() types.Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Call.Value">func (s *Call) Value() *Call</a></dd>
				
			
				
				<dd><a href="#CallCommon">type CallCommon</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#CallCommon.Description">func (c *CallCommon) Description() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CallCommon.IsInvoke">func (c *CallCommon) IsInvoke() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CallCommon.Operands">func (c *CallCommon) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CallCommon.Pos">func (c *CallCommon) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CallCommon.Signature">func (c *CallCommon) Signature() *types.Signature</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CallCommon.StaticCallee">func (c *CallCommon) StaticCallee() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#CallCommon.String">func (c *CallCommon) String() string</a></dd>
				
			
				
				<dd><a href="#CallInstruction">type CallInstruction</a></dd>
				
				
			
				
				<dd><a href="#ChangeInterface">type ChangeInterface</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ChangeInterface.Name">func (v *ChangeInterface) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ChangeInterface.Operands">func (v *ChangeInterface) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ChangeInterface.Pos">func (v *ChangeInterface) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ChangeInterface.Referrers">func (v *ChangeInterface) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ChangeInterface.String">func (v *ChangeInterface) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ChangeInterface.Type">func (v *ChangeInterface) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#ChangeType">type ChangeType</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#ChangeType.Name">func (v *ChangeType) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ChangeType.Operands">func (v *ChangeType) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ChangeType.Pos">func (v *ChangeType) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ChangeType.Referrers">func (v *ChangeType) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ChangeType.String">func (v *ChangeType) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#ChangeType.Type">func (v *ChangeType) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#Const">type Const</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewConst">func NewConst(val constant.Value, typ types.Type) *Const</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Complex128">func (c *Const) Complex128() complex128</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Float64">func (c *Const) Float64() float64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Int64">func (c *Const) Int64() int64</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.IsNil">func (c *Const) IsNil() bool</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Name">func (c *Const) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Operands">func (v *Const) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Parent">func (c *Const) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Pos">func (c *Const) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Referrers">func (c *Const) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.RelString">func (c *Const) RelString(from *types.Package) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.String">func (c *Const) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Type">func (c *Const) Type() types.Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Const.Uint64">func (c *Const) Uint64() uint64</a></dd>
				
			
				
				<dd><a href="#Convert">type Convert</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Convert.Name">func (v *Convert) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Convert.Operands">func (v *Convert) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Convert.Pos">func (v *Convert) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Convert.Referrers">func (v *Convert) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Convert.String">func (v *Convert) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Convert.Type">func (v *Convert) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#DebugRef">type DebugRef</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#DebugRef.Block">func (v *DebugRef) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DebugRef.Object">func (d *DebugRef) Object() types.Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DebugRef.Operands">func (s *DebugRef) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DebugRef.Parent">func (v *DebugRef) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DebugRef.Pos">func (s *DebugRef) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DebugRef.Referrers">func (v *DebugRef) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#DebugRef.String">func (s *DebugRef) String() string</a></dd>
				
			
				
				<dd><a href="#Defer">type Defer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Defer.Block">func (v *Defer) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Defer.Common">func (s *Defer) Common() *CallCommon</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Defer.Operands">func (s *Defer) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Defer.Parent">func (v *Defer) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Defer.Pos">func (s *Defer) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Defer.Referrers">func (v *Defer) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Defer.String">func (s *Defer) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Defer.Value">func (s *Defer) Value() *Call</a></dd>
				
			
				
				<dd><a href="#Extract">type Extract</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Extract.Name">func (v *Extract) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Extract.Operands">func (v *Extract) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Extract.Pos">func (v *Extract) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Extract.Referrers">func (v *Extract) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Extract.String">func (v *Extract) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Extract.Type">func (v *Extract) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#Field">type Field</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Field.Name">func (v *Field) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Field.Operands">func (v *Field) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Field.Pos">func (v *Field) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Field.Referrers">func (v *Field) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Field.String">func (v *Field) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Field.Type">func (v *Field) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#FieldAddr">type FieldAddr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FieldAddr.Name">func (v *FieldAddr) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FieldAddr.Operands">func (v *FieldAddr) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FieldAddr.Pos">func (v *FieldAddr) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FieldAddr.Referrers">func (v *FieldAddr) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FieldAddr.String">func (v *FieldAddr) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FieldAddr.Type">func (v *FieldAddr) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#FreeVar">type FreeVar</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#FreeVar.Name">func (v *FreeVar) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FreeVar.Operands">func (v *FreeVar) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FreeVar.Parent">func (v *FreeVar) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FreeVar.Pos">func (v *FreeVar) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FreeVar.Referrers">func (v *FreeVar) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FreeVar.String">func (v *FreeVar) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#FreeVar.Type">func (v *FreeVar) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#Function">type Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#EnclosingFunction">func EnclosingFunction(pkg *Package, path []ast.Node) *Function</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.DomPostorder">func (f *Function) DomPostorder() []*BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.DomPreorder">func (f *Function) DomPreorder() []*BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.Name">func (v *Function) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.Object">func (v *Function) Object() types.Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.Operands">func (v *Function) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.Origin">func (fn *Function) Origin() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.Package">func (v *Function) Package() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.Parent">func (v *Function) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.Pos">func (v *Function) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.Referrers">func (v *Function) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.RelString">func (f *Function) RelString(from *types.Package) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.String">func (v *Function) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.Syntax">func (f *Function) Syntax() ast.Node</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.Token">func (v *Function) Token() token.Token</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.Type">func (v *Function) Type() types.Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.TypeArgs">func (fn *Function) TypeArgs() []types.Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.TypeParams">func (fn *Function) TypeParams() *types.TypeParamList</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.ValueForExpr">func (f *Function) ValueForExpr(e ast.Expr) (value Value, isAddr bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Function.WriteTo">func (f *Function) WriteTo(w io.Writer) (int64, error)</a></dd>
				
			
				
				<dd><a href="#Global">type Global</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Global.Name">func (v *Global) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Global.Object">func (v *Global) Object() types.Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Global.Operands">func (v *Global) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Global.Package">func (v *Global) Package() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Global.Parent">func (v *Global) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Global.Pos">func (v *Global) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Global.Referrers">func (v *Global) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Global.RelString">func (v *Global) RelString(from *types.Package) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Global.String">func (v *Global) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Global.Token">func (v *Global) Token() token.Token</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Global.Type">func (v *Global) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#Go">type Go</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Go.Block">func (v *Go) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Go.Common">func (s *Go) Common() *CallCommon</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Go.Operands">func (s *Go) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Go.Parent">func (v *Go) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Go.Pos">func (s *Go) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Go.Referrers">func (v *Go) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Go.String">func (s *Go) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Go.Value">func (s *Go) Value() *Call</a></dd>
				
			
				
				<dd><a href="#If">type If</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#If.Block">func (v *If) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#If.Operands">func (s *If) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#If.Parent">func (v *If) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#If.Pos">func (s *If) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#If.Referrers">func (v *If) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#If.String">func (s *If) String() string</a></dd>
				
			
				
				<dd><a href="#Index">type Index</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Index.Name">func (v *Index) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Index.Operands">func (v *Index) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Index.Pos">func (v *Index) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Index.Referrers">func (v *Index) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Index.String">func (v *Index) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Index.Type">func (v *Index) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#IndexAddr">type IndexAddr</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexAddr.Name">func (v *IndexAddr) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexAddr.Operands">func (v *IndexAddr) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexAddr.Pos">func (v *IndexAddr) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexAddr.Referrers">func (v *IndexAddr) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexAddr.String">func (v *IndexAddr) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#IndexAddr.Type">func (v *IndexAddr) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#Instruction">type Instruction</a></dd>
				
				
			
				
				<dd><a href="#Jump">type Jump</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Jump.Block">func (v *Jump) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Jump.Operands">func (*Jump) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Jump.Parent">func (v *Jump) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Jump.Pos">func (s *Jump) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Jump.Referrers">func (v *Jump) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Jump.String">func (s *Jump) String() string</a></dd>
				
			
				
				<dd><a href="#Lookup">type Lookup</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Lookup.Name">func (v *Lookup) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Lookup.Operands">func (v *Lookup) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Lookup.Pos">func (v *Lookup) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Lookup.Referrers">func (v *Lookup) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Lookup.String">func (v *Lookup) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Lookup.Type">func (v *Lookup) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#MakeChan">type MakeChan</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeChan.Name">func (v *MakeChan) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeChan.Operands">func (v *MakeChan) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeChan.Pos">func (v *MakeChan) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeChan.Referrers">func (v *MakeChan) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeChan.String">func (v *MakeChan) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeChan.Type">func (v *MakeChan) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#MakeClosure">type MakeClosure</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeClosure.Name">func (v *MakeClosure) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeClosure.Operands">func (v *MakeClosure) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeClosure.Pos">func (v *MakeClosure) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeClosure.Referrers">func (v *MakeClosure) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeClosure.String">func (v *MakeClosure) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeClosure.Type">func (v *MakeClosure) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#MakeInterface">type MakeInterface</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeInterface.Name">func (v *MakeInterface) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeInterface.Operands">func (v *MakeInterface) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeInterface.Pos">func (v *MakeInterface) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeInterface.Referrers">func (v *MakeInterface) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeInterface.String">func (v *MakeInterface) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeInterface.Type">func (v *MakeInterface) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#MakeMap">type MakeMap</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeMap.Name">func (v *MakeMap) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeMap.Operands">func (v *MakeMap) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeMap.Pos">func (v *MakeMap) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeMap.Referrers">func (v *MakeMap) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeMap.String">func (v *MakeMap) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeMap.Type">func (v *MakeMap) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#MakeSlice">type MakeSlice</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeSlice.Name">func (v *MakeSlice) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeSlice.Operands">func (v *MakeSlice) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeSlice.Pos">func (v *MakeSlice) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeSlice.Referrers">func (v *MakeSlice) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeSlice.String">func (v *MakeSlice) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MakeSlice.Type">func (v *MakeSlice) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#MapUpdate">type MapUpdate</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MapUpdate.Block">func (v *MapUpdate) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MapUpdate.Operands">func (v *MapUpdate) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MapUpdate.Parent">func (v *MapUpdate) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MapUpdate.Pos">func (s *MapUpdate) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MapUpdate.Referrers">func (v *MapUpdate) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MapUpdate.String">func (s *MapUpdate) String() string</a></dd>
				
			
				
				<dd><a href="#Member">type Member</a></dd>
				
				
			
				
				<dd><a href="#MultiConvert">type MultiConvert</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#MultiConvert.Name">func (v *MultiConvert) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MultiConvert.Operands">func (v *MultiConvert) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MultiConvert.Pos">func (v *MultiConvert) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MultiConvert.Referrers">func (v *MultiConvert) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MultiConvert.String">func (v *MultiConvert) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#MultiConvert.Type">func (v *MultiConvert) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#NamedConst">type NamedConst</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#NamedConst.Name">func (c *NamedConst) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NamedConst.Object">func (c *NamedConst) Object() types.Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NamedConst.Package">func (c *NamedConst) Package() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NamedConst.Pos">func (c *NamedConst) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NamedConst.RelString">func (c *NamedConst) RelString(from *types.Package) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NamedConst.String">func (c *NamedConst) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NamedConst.Token">func (c *NamedConst) Token() token.Token</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NamedConst.Type">func (c *NamedConst) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#Next">type Next</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Next.Name">func (v *Next) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Next.Operands">func (v *Next) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Next.Pos">func (v *Next) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Next.Referrers">func (v *Next) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Next.String">func (v *Next) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Next.Type">func (v *Next) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#Node">type Node</a></dd>
				
				
			
				
				<dd><a href="#Package">type Package</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.Build">func (p *Package) Build()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.Const">func (p *Package) Const(name string) (c *NamedConst)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.Func">func (p *Package) Func(name string) (f *Function)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.SetDebugMode">func (pkg *Package) SetDebugMode(debug bool)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.String">func (p *Package) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.Type">func (p *Package) Type(name string) (t *Type)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.Var">func (p *Package) Var(name string) (g *Global)</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Package.WriteTo">func (p *Package) WriteTo(w io.Writer) (int64, error)</a></dd>
				
			
				
				<dd><a href="#Panic">type Panic</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Panic.Block">func (v *Panic) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Panic.Operands">func (s *Panic) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Panic.Parent">func (v *Panic) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Panic.Pos">func (s *Panic) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Panic.Referrers">func (v *Panic) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Panic.String">func (s *Panic) String() string</a></dd>
				
			
				
				<dd><a href="#Parameter">type Parameter</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Parameter.Name">func (v *Parameter) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Parameter.Object">func (v *Parameter) Object() types.Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Parameter.Operands">func (v *Parameter) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Parameter.Parent">func (v *Parameter) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Parameter.Pos">func (v *Parameter) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Parameter.Referrers">func (v *Parameter) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Parameter.String">func (v *Parameter) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Parameter.Type">func (v *Parameter) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#Phi">type Phi</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Phi.Name">func (v *Phi) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Phi.Operands">func (v *Phi) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Phi.Pos">func (v *Phi) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Phi.Referrers">func (v *Phi) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Phi.String">func (v *Phi) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Phi.Type">func (v *Phi) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#Program">type Program</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#NewProgram">func NewProgram(fset *token.FileSet, mode BuilderMode) *Program</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Program.AllPackages">func (prog *Program) AllPackages() []*Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Program.Build">func (prog *Program) Build()</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Program.ConstValue">func (prog *Program) ConstValue(obj *types.Const) *Const</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Program.CreatePackage">func (prog *Program) CreatePackage(pkg *types.Package, files []*ast.File, info *types.Info, importable bool) *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Program.FuncValue">func (prog *Program) FuncValue(obj *types.Func) *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Program.ImportedPackage">func (prog *Program) ImportedPackage(path string) *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Program.LookupMethod">func (prog *Program) LookupMethod(T types.Type, pkg *types.Package, name string) *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Program.MethodValue">func (prog *Program) MethodValue(sel *types.Selection) *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Program.NewFunction">func (prog *Program) NewFunction(name string, sig *types.Signature, provenance string) *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Program.Package">func (prog *Program) Package(pkg *types.Package) *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Program.RuntimeTypes">func (prog *Program) RuntimeTypes() []types.Type</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Program.VarValue">func (prog *Program) VarValue(obj *types.Var, pkg *Package, ref []ast.Node) (value Value, isAddr bool)</a></dd>
				
			
				
				<dd><a href="#Range">type Range</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Range.Name">func (v *Range) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Range.Operands">func (v *Range) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Range.Pos">func (v *Range) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Range.Referrers">func (v *Range) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Range.String">func (v *Range) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Range.Type">func (v *Range) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#Return">type Return</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Return.Block">func (v *Return) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Return.Operands">func (s *Return) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Return.Parent">func (v *Return) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Return.Pos">func (s *Return) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Return.Referrers">func (v *Return) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Return.String">func (s *Return) String() string</a></dd>
				
			
				
				<dd><a href="#RunDefers">type RunDefers</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#RunDefers.Block">func (v *RunDefers) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RunDefers.Operands">func (*RunDefers) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RunDefers.Parent">func (v *RunDefers) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RunDefers.Pos">func (s *RunDefers) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RunDefers.Referrers">func (v *RunDefers) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#RunDefers.String">func (*RunDefers) String() string</a></dd>
				
			
				
				<dd><a href="#Select">type Select</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Select.Name">func (v *Select) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Select.Operands">func (v *Select) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Select.Pos">func (v *Select) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Select.Referrers">func (v *Select) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Select.String">func (s *Select) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Select.Type">func (v *Select) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#SelectState">type SelectState</a></dd>
				
				
			
				
				<dd><a href="#Send">type Send</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Send.Block">func (v *Send) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Send.Operands">func (s *Send) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Send.Parent">func (v *Send) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Send.Pos">func (s *Send) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Send.Referrers">func (v *Send) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Send.String">func (s *Send) String() string</a></dd>
				
			
				
				<dd><a href="#Slice">type Slice</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Slice.Name">func (v *Slice) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Slice.Operands">func (v *Slice) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Slice.Pos">func (v *Slice) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Slice.Referrers">func (v *Slice) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Slice.String">func (v *Slice) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Slice.Type">func (v *Slice) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#SliceToArrayPointer">type SliceToArrayPointer</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#SliceToArrayPointer.Name">func (v *SliceToArrayPointer) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SliceToArrayPointer.Operands">func (v *SliceToArrayPointer) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SliceToArrayPointer.Pos">func (v *SliceToArrayPointer) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SliceToArrayPointer.Referrers">func (v *SliceToArrayPointer) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SliceToArrayPointer.String">func (v *SliceToArrayPointer) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#SliceToArrayPointer.Type">func (v *SliceToArrayPointer) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#Store">type Store</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Store.Block">func (v *Store) Block() *BasicBlock</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Store.Operands">func (s *Store) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Store.Parent">func (v *Store) Parent() *Function</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Store.Pos">func (s *Store) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Store.Referrers">func (v *Store) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Store.String">func (s *Store) String() string</a></dd>
				
			
				
				<dd><a href="#Type">type Type</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#Type.Name">func (t *Type) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Type.Object">func (t *Type) Object() types.Object</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Type.Package">func (t *Type) Package() *Package</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Type.Pos">func (t *Type) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Type.RelString">func (t *Type) RelString(from *types.Package) string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Type.String">func (t *Type) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Type.Token">func (t *Type) Token() token.Token</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#Type.Type">func (t *Type) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#TypeAssert">type TypeAssert</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAssert.Name">func (v *TypeAssert) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAssert.Operands">func (v *TypeAssert) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAssert.Pos">func (v *TypeAssert) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAssert.Referrers">func (v *TypeAssert) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAssert.String">func (v *TypeAssert) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#TypeAssert.Type">func (v *TypeAssert) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#UnOp">type UnOp</a></dd>
				
				
					
					<dd>&nbsp; &nbsp; <a href="#UnOp.Name">func (v *UnOp) Name() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnOp.Operands">func (v *UnOp) Operands(rands []*Value) []*Value</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnOp.Pos">func (v *UnOp) Pos() token.Pos</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnOp.Referrers">func (v *UnOp) Referrers() *[]Instruction</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnOp.String">func (v *UnOp) String() string</a></dd>
				
					
					<dd>&nbsp; &nbsp; <a href="#UnOp.Type">func (v *UnOp) Type() types.Type</a></dd>
				
			
				
				<dd><a href="#Value">type Value</a></dd>
				
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="#example__buildPackage">Package (BuildPackage)</a></dd>
			
			<dd><a class="exampleLink" href="#example__loadPackages">Package (LoadPackages)</a></dd>
			
			<dd><a class="exampleLink" href="#example__loadWholeProgram">Package (LoadWholeProgram)</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="/src/golang.org/x/tools/go/ssa/block.go">block.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/blockopt.go">blockopt.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/builder.go">builder.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/const.go">const.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/coretype.go">coretype.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/create.go">create.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/doc.go">doc.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/dom.go">dom.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/emit.go">emit.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/func.go">func.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/instantiate.go">instantiate.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/lift.go">lift.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/lvalue.go">lvalue.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/methods.go">methods.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/mode.go">mode.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/print.go">print.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/sanity.go">sanity.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/source.go">source.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/ssa.go">ssa.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/subst.go">subst.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/task.go">task.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/util.go">util.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/util_go120.go">util_go120.go</a>
			
				<a href="/src/golang.org/x/tools/go/ssa/wrappers.go">wrappers.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				
				<pre>const <span id="BuilderModeDoc">BuilderModeDoc</span> = `Options controlling the SSA builder.
The value is a sequence of zero or more of these letters:
C	perform sanity [C]hecking of the SSA form.
D	include [D]ebug info for every function.
P	print [P]ackage inventory.
F	print [F]unction SSA code.
S	log [S]ource locations as SSA builder progresses.
L	build distinct packages seria[L]ly instead of in parallel.
N	build [N]aive SSA form: don&#39;t replace local loads/stores with registers.
I	build bare [I]nit functions: no init guards or calls to dependent inits.
G   instantiate [G]eneric function bodies via monomorphization
`</pre>
			
		
		
		
			
			
			<h2 id="HasEnclosingFunction">func <a href="/src/golang.org/x/tools/go/ssa/source.go?s=2041:2102#L57">HasEnclosingFunction</a>
				<a class="permalink" href="#HasEnclosingFunction">&#xb6;</a>
				
				
			</h2>
			<pre>func HasEnclosingFunction(pkg *<a href="#Package">Package</a>, path []<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Node">Node</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
			<p>HasEnclosingFunction returns true if the AST node denoted by path
is contained within the declaration of some function or
package-level variable.
<p>Unlike EnclosingFunction, the behaviour of this function does not
depend on whether SSA code for pkg has been built, so it can be
used to quickly reject check inputs that will cause
EnclosingFunction to fail, prior to SSA building.

			
			

		
			
			
			<h2 id="WriteFunction">func <a href="/src/golang.org/x/tools/go/ssa/func.go?s=17098:17148#L592">WriteFunction</a>
				<a class="permalink" href="#WriteFunction">&#xb6;</a>
				
				
			</h2>
			<pre>func WriteFunction(buf *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>, f *<a href="#Function">Function</a>)</pre>
			<p>WriteFunction writes to buf a human-readable &quot;disassembly&quot; of f.

			
			

		
			
			
			<h2 id="WritePackage">func <a href="/src/golang.org/x/tools/go/ssa/print.go?s=10207:10255#L415">WritePackage</a>
				<a class="permalink" href="#WritePackage">&#xb6;</a>
				
				
			</h2>
			<pre>func WritePackage(buf *<a href="/pkg/bytes/">bytes</a>.<a href="/pkg/bytes/#Buffer">Buffer</a>, p *<a href="#Package">Package</a>)</pre>
			<p>WritePackage writes to buf a human-readable summary of p.

			
			

		
		
			
			
			<h2 id="Alloc">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=22567:22673#L536">Alloc</a>
				<a class="permalink" href="#Alloc">&#xb6;</a>
				
				
			</h2>
			<p>The Alloc instruction reserves space for a variable of the given type,
zero-initializes it, and yields its address.
<p>Alloc values are always addresses, and have pointer types, so the
type of the allocated variable is actually
Type().Underlying().(*types.Pointer).Elem().
<p>If Heap is false, Alloc zero-initializes the same local variable in
the call frame and returns its address; in this case the Alloc must
be present in Function.Locals. We call this a &quot;local&quot; alloc.
<p>If Heap is true, Alloc allocates a new zero-initialized variable
each time the instruction is executed. We call this a &quot;new&quot; alloc.
<p>When Alloc is applied to a channel, map or slice type, it returns
the address of an uninitialized (nil) reference of that kind; store
the result of MakeSlice, MakeMap or MakeChan in that location to
instantiate these types.
<p>Pos() returns the ast.CompositeLit.Lbrace for a composite literal,
or the ast.CallExpr.Rparen for a call to new() or for a call that
allocates a varargs slice.
<p>Example printed form:
<pre>t0 = local int
t1 = new int
</pre>

			<pre>type Alloc struct {
<span id="Alloc.Comment"></span>    Comment <a href="/pkg/builtin/#string">string</a>
<span id="Alloc.Heap"></span>    Heap    <a href="/pkg/builtin/#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Alloc.Name">func (*Alloc) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#Alloc.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Alloc">Alloc</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Alloc.Operands">func (*Alloc) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60826:60875#L1686">Operands</a>
					<a class="permalink" href="#Alloc.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Alloc">Alloc</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Alloc.Pos">func (*Alloc) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57230:57261#L1608">Pos</a>
					<a class="permalink" href="#Alloc.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Alloc">Alloc</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Alloc.Referrers">func (*Alloc) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57163:57205#L1607">Referrers</a>
					<a class="permalink" href="#Alloc.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Alloc">Alloc</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Alloc.String">func (*Alloc) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=2312:2343#L82">String</a>
					<a class="permalink" href="#Alloc.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Alloc">Alloc</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Alloc.Type">func (*Alloc) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57103:57136#L1606">Type</a>
					<a class="permalink" href="#Alloc.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Alloc">Alloc</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="BasicBlock">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=17798:18371#L394">BasicBlock</a>
				<a class="permalink" href="#BasicBlock">&#xb6;</a>
				
				
			</h2>
			<p>BasicBlock represents an SSA basic block.
<p>The final element of Instrs is always an explicit transfer of
control (If, Jump, Return, or Panic).
<p>A block may contain no Instructions only if it is unreachable,
i.e., Preds is nil.  Empty blocks are typically pruned.
<p>BasicBlocks and their Preds/Succs relation form a (possibly cyclic)
graph independent of the SSA Value graph: the control-flow graph or
CFG.  It is illegal for multiple edges to exist between the same
pair of blocks.
<p>Each BasicBlock is also a node in the dominator tree of the CFG.
The tree may be navigated using Idom()/Dominees() and queried using
Dominates().
<p>The order of Preds and Succs is significant (to Phi and If
instructions, respectively).

			<pre>type BasicBlock struct {
<span id="BasicBlock.Index"></span>    Index   <a href="/pkg/builtin/#int">int</a>    <span class="comment">// index of this block within Parent().Blocks</span>
<span id="BasicBlock.Comment"></span>    Comment <a href="/pkg/builtin/#string">string</a> <span class="comment">// optional label; no semantic significance</span>

<span id="BasicBlock.Instrs"></span>    Instrs       []<a href="#Instruction">Instruction</a> <span class="comment">// instructions in order</span>
<span id="BasicBlock.Preds"></span>    Preds, Succs []*<a href="#BasicBlock">BasicBlock</a> <span class="comment">// predecessors and successors</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="BasicBlock.Dominates">func (*BasicBlock) <a href="/src/golang.org/x/tools/go/ssa/dom.go?s=1252:1302#L29">Dominates</a>
					<a class="permalink" href="#BasicBlock.Dominates">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BasicBlock">BasicBlock</a>) Dominates(c *<a href="#BasicBlock">BasicBlock</a>) <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>Dominates reports whether b dominates c.

				
				
				
			
				
				<h3 id="BasicBlock.Dominees">func (*BasicBlock) <a href="/src/golang.org/x/tools/go/ssa/dom.go?s=1135:1180#L26">Dominees</a>
					<a class="permalink" href="#BasicBlock.Dominees">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BasicBlock">BasicBlock</a>) Dominees() []*<a href="#BasicBlock">BasicBlock</a></pre>
				<p>Dominees returns the list of blocks that b immediately dominates:
its children in the dominator tree.

				
				
				
			
				
				<h3 id="BasicBlock.Idom">func (*BasicBlock) <a href="/src/golang.org/x/tools/go/ssa/dom.go?s=964:1003#L22">Idom</a>
					<a class="permalink" href="#BasicBlock.Idom">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BasicBlock">BasicBlock</a>) Idom() *<a href="#BasicBlock">BasicBlock</a></pre>
				<p>Idom returns the block that immediately dominates b:
its parent in the dominator tree, if any.
Neither the entry node (b.Index==0) nor recover node
(b==b.Parent().Recover()) have a parent.

				
				
				
			
				
				<h3 id="BasicBlock.Parent">func (*BasicBlock) <a href="/src/golang.org/x/tools/go/ssa/block.go?s=458:497#L8">Parent</a>
					<a class="permalink" href="#BasicBlock.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BasicBlock">BasicBlock</a>) Parent() *<a href="#Function">Function</a></pre>
				<p>Parent returns the function that contains block b.

				
				
				
			
				
				<h3 id="BasicBlock.String">func (*BasicBlock) <a href="/src/golang.org/x/tools/go/ssa/block.go?s=627:663#L12">String</a>
					<a class="permalink" href="#BasicBlock.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (b *<a href="#BasicBlock">BasicBlock</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				<p>String returns a human-readable label of this block.
It is not guaranteed unique within the function.

				
				
				
			
		
			
			
			<h2 id="BinOp">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=23951:24164#L588">BinOp</a>
				<a class="permalink" href="#BinOp">&#xb6;</a>
				
				
			</h2>
			<p>The BinOp instruction yields the result of binary operation X Op Y.
<p>Pos() returns the ast.BinaryExpr.OpPos, if explicit in the source.
<p>Example printed form:
<pre>t1 = t0 + 1:int
</pre>

			<pre>type BinOp struct {

    <span class="comment">// One of:</span>
    <span class="comment">// ADD SUB MUL QUO REM          + - * / %</span>
    <span class="comment">// AND OR XOR SHL SHR AND_NOT   &amp; | ^ &lt;&lt; &gt;&gt; &amp;^</span>
    <span class="comment">// EQL NEQ LSS LEQ GTR GEQ      == != &lt; &lt;= &lt; &gt;=</span>
<span id="BinOp.Op"></span>    Op   <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Token">Token</a>
<span id="BinOp.X"></span>    X, Y <a href="#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="BinOp.Name">func (*BinOp) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#BinOp.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#BinOp">BinOp</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="BinOp.Operands">func (*BinOp) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60895:60944#L1690">Operands</a>
					<a class="permalink" href="#BinOp.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#BinOp">BinOp</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="BinOp.Pos">func (*BinOp) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#BinOp.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#BinOp">BinOp</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="BinOp.Referrers">func (*BinOp) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#BinOp.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#BinOp">BinOp</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="BinOp.String">func (*BinOp) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=3748:3779#L152">String</a>
					<a class="permalink" href="#BinOp.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#BinOp">BinOp</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="BinOp.Type">func (*BinOp) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#BinOp.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#BinOp">BinOp</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="BuilderMode">type <a href="/src/golang.org/x/tools/go/ssa/mode.go?s=505:526#L10">BuilderMode</a>
				<a class="permalink" href="#BuilderMode">&#xb6;</a>
				
				
			</h2>
			<p>BuilderMode is a bitmask of options for diagnostics and checking.
<p>*BuilderMode satisfies the flag.Value interface.  Example:
<pre>var mode = ssa.BuilderMode(0)
func init() { flag.Var(&amp;mode, &quot;build&quot;, ssa.BuilderModeDoc) }
</pre>

			<pre>type BuilderMode <a href="/pkg/builtin/#uint">uint</a></pre>

			
				
				<pre>const (
    <span id="PrintPackages">PrintPackages</span>        <a href="#BuilderMode">BuilderMode</a> = 1 &lt;&lt; <a href="/pkg/builtin/#iota">iota</a> <span class="comment">// Print package inventory to stdout</span>
    <span id="PrintFunctions">PrintFunctions</span>                               <span class="comment">// Print function SSA code to stdout</span>
    <span id="LogSource">LogSource</span>                                    <span class="comment">// Log source locations as SSA builder progresses</span>
    <span id="SanityCheckFunctions">SanityCheckFunctions</span>                         <span class="comment">// Perform sanity checking of function bodies</span>
    <span id="NaiveForm">NaiveForm</span>                                    <span class="comment">// Build naïve SSA form: don&#39;t replace local loads/stores with registers</span>
    <span id="BuildSerially">BuildSerially</span>                                <span class="comment">// Build packages serially, not in parallel.</span>
    <span id="GlobalDebug">GlobalDebug</span>                                  <span class="comment">// Enable debug info for all packages</span>
    <span id="BareInits">BareInits</span>                                    <span class="comment">// Build init functions without guards or calls to dependent inits</span>
    <span id="InstantiateGenerics">InstantiateGenerics</span>                          <span class="comment">// Instantiate generics functions (monomorphize) while building</span>
)</pre>
			

			

			
			
			

			

			
				
				<h3 id="BuilderMode.Get">func (BuilderMode) <a href="/src/golang.org/x/tools/go/ssa/mode.go?s=3175:3213#L101">Get</a>
					<a class="permalink" href="#BuilderMode.Get">&#xb6;</a>
					
					
				</h3>
				<pre>func (m <a href="#BuilderMode">BuilderMode</a>) Get() interface{}</pre>
				<p>Get returns m.

				
				
				
			
				
				<h3 id="BuilderMode.Set">func (*BuilderMode) <a href="/src/golang.org/x/tools/go/ssa/mode.go?s=2604:2645#L70">Set</a>
					<a class="permalink" href="#BuilderMode.Set">&#xb6;</a>
					
					
				</h3>
				<pre>func (m *<a href="#BuilderMode">BuilderMode</a>) Set(s <a href="/pkg/builtin/#string">string</a>) <a href="/pkg/builtin/#error">error</a></pre>
				<p>Set parses the flag characters in s and updates *m.

				
				
				
			
				
				<h3 id="BuilderMode.String">func (BuilderMode) <a href="/src/golang.org/x/tools/go/ssa/mode.go?s=2005:2041#L37">String</a>
					<a class="permalink" href="#BuilderMode.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (m <a href="#BuilderMode">BuilderMode</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Builtin">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=21318:21377#L502">Builtin</a>
				<a class="permalink" href="#Builtin">&#xb6;</a>
				
				
			</h2>
			<p>A Builtin represents a specific use of a built-in function, e.g. len.
<p>Builtins are immutable values.  Builtins do not have addresses.
Builtins can only appear in CallCommon.Value.
<p>Name() indicates the function: one of the built-in functions from the
Go spec (excluding &quot;make&quot; and &quot;new&quot;) or one of these ssa-defined
intrinsics:
<pre>// wrapnilchk returns ptr if non-nil, panics otherwise.
// (For use in indirection wrappers.)
func ssa:wrapnilchk(ptr *T, recvType, methodName string) *T
</pre>
<p>Object() returns a *types.Builtin for built-ins defined by the spec,
nil for others.
<p>Type() returns a *types.Signature representing the effective
signature of the built-in for this call.

			<pre>type Builtin struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Builtin.Name">func (*Builtin) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=53496:53527#L1523">Name</a>
					<a class="permalink" href="#Builtin.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Builtin">Builtin</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Object">func (*Builtin) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=53681:53720#L1526">Object</a>
					<a class="permalink" href="#Builtin.Object">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Builtin">Builtin</a>) Object() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Object">Object</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Operands">func (*Builtin) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=64562:64613#L1856">Operands</a>
					<a class="permalink" href="#Builtin.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Builtin">Builtin</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				<p>Non-Instruction Values:

				
				
				
			
				
				<h3 id="Builtin.Parent">func (*Builtin) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=53765:53801#L1527">Parent</a>
					<a class="permalink" href="#Builtin.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Builtin">Builtin</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Pos">func (*Builtin) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=53615:53648#L1525">Pos</a>
					<a class="permalink" href="#Builtin.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Builtin">Builtin</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Referrers">func (*Builtin) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=53557:53599#L1524">Referrers</a>
					<a class="permalink" href="#Builtin.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (*<a href="#Builtin">Builtin</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.String">func (*Builtin) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=2204:2237#L76">String</a>
					<a class="permalink" href="#Builtin.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Builtin">Builtin</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Builtin.Type">func (*Builtin) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=53436:53471#L1522">Type</a>
					<a class="permalink" href="#Builtin.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Builtin">Builtin</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Call">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=23708:23755#L576">Call</a>
				<a class="permalink" href="#Call">&#xb6;</a>
				
				
			</h2>
			<p>The Call instruction represents a function or method call.
<p>The Call instruction yields the function result if there is exactly
one.  Otherwise it returns a tuple, the components of which are
accessed via Extract.
<p>See CallCommon for generic function call documentation.
<p>Pos() returns the ast.CallExpr.Lparen, if explicit in the source.
<p>Example printed form:
<pre>t2 = println(t0, t1)
t4 = t3()
t7 = invoke t5.Println(...t6)
</pre>

			<pre>type Call struct {
<span id="Call.Call"></span>    Call <a href="#CallCommon">CallCommon</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Call.Common">func (*Call) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=53133:53168#L1514">Common</a>
					<a class="permalink" href="#Call.Common">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Call">Call</a>) Common() *<a href="#CallCommon">CallCommon</a></pre>
				
				
				
				
			
				
				<h3 id="Call.Name">func (*Call) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#Call.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Call">Call</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Call.Operands">func (*Call) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=61238:61286#L1706">Operands</a>
					<a class="permalink" href="#Call.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Call">Call</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Call.Pos">func (*Call) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60145:60175#L1671">Pos</a>
					<a class="permalink" href="#Call.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Call">Call</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Call.Referrers">func (*Call) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#Call.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Call">Call</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Call.String">func (*Call) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=3678:3708#L148">String</a>
					<a class="permalink" href="#Call.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Call">Call</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Call.Type">func (*Call) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#Call.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Call">Call</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
				
				<h3 id="Call.Value">func (*Call) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=53302:53330#L1518">Value</a>
					<a class="permalink" href="#Call.Value">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Call">Call</a>) Value() *<a href="#Call">Call</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="CallCommon">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=50950:51261#L1445">CallCommon</a>
				<a class="permalink" href="#CallCommon">&#xb6;</a>
				
				
			</h2>
			<p>CallCommon is contained by Go, Defer and Call to hold the
common parts of a function or method call.
<p>Each CallCommon exists in one of two modes, function call and
interface method invocation, or &quot;call&quot; and &quot;invoke&quot; for short.
<p>1. &quot;call&quot; mode: when Method is nil (!IsInvoke), a CallCommon
represents an ordinary function call of the value in Value,
which may be a *Builtin, a *Function or any other value of kind
&apos;func&apos;.
<p>Value may be one of:
<pre>(a) a *Function, indicating a statically dispatched call
    to a package-level function, an anonymous function, or
    a method of a named type.
(b) a *MakeClosure, indicating an immediately applied
    function literal with free variables.
(c) a *Builtin, indicating a statically dispatched call
    to a built-in function.
(d) any other value, indicating a dynamically dispatched
    function call.
</pre>
<p>StaticCallee returns the identity of the callee in cases
(a) and (b), nil otherwise.
<p>Args contains the arguments to the call.  If Value is a method,
Args[0] contains the receiver parameter.
<p>Example printed form:
<pre>t2 = println(t0, t1)
go t3()
defer t5(...t6)
</pre>
<p>2. &quot;invoke&quot; mode: when Method is non-nil (IsInvoke), a CallCommon
represents a dynamically dispatched call to an interface method.
In this mode, Value is the interface value and Method is the
interface&apos;s abstract method. The interface value may be a type
parameter. Note: an interface method may be shared by multiple
interfaces due to embedding; Value.Type() provides the specific
interface used for this call.
<p>Value is implicitly supplied to the concrete method implementation
as the receiver parameter; in other words, Args[0] holds not the
receiver but the first true argument.
<p>Example printed form:
<pre>t1 = invoke t0.String()
go invoke t3.Run(t2)
defer invoke t4.Handle(...t5)
</pre>
<p>For all calls to variadic functions (Signature().Variadic()),
the last element of Args is a slice.

			<pre>type CallCommon struct {
<span id="CallCommon.Value"></span>    Value  <a href="#Value">Value</a>       <span class="comment">// receiver (invoke mode) or func value (call mode)</span>
<span id="CallCommon.Method"></span>    Method *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Func">Func</a> <span class="comment">// interface method (invoke mode)</span>
<span id="CallCommon.Args"></span>    Args   []<a href="#Value">Value</a>     <span class="comment">// actual parameters (in static method call, includes receiver)</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="CallCommon.Description">func (*CallCommon) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=52320:52361#L1487">Description</a>
					<a class="permalink" href="#CallCommon.Description">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#CallCommon">CallCommon</a>) Description() <a href="/pkg/builtin/#string">string</a></pre>
				<p>Description returns a description of the mode of this call suitable
for a user interface, e.g., &quot;static method call&quot;.

				
				
				
			
				
				<h3 id="CallCommon.IsInvoke">func (*CallCommon) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=51333:51369#L1453">IsInvoke</a>
					<a class="permalink" href="#CallCommon.IsInvoke">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#CallCommon">CallCommon</a>) IsInvoke() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsInvoke returns true if this call has &quot;invoke&quot; (not &quot;call&quot;) mode.

				
				
				
			
				
				<h3 id="CallCommon.Operands">func (*CallCommon) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60984:61038#L1694">Operands</a>
					<a class="permalink" href="#CallCommon.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#CallCommon">CallCommon</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="CallCommon.Pos">func (*CallCommon) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=51399:51435#L1457">Pos</a>
					<a class="permalink" href="#CallCommon.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#CallCommon">CallCommon</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="CallCommon.Signature">func (*CallCommon) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=51736:51785#L1466">Signature</a>
					<a class="permalink" href="#CallCommon.Signature">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#CallCommon">CallCommon</a>) Signature() *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Signature">Signature</a></pre>
				<p>Signature returns the signature of the called function.
<p>For an &quot;invoke&quot;-mode call, the signature of the interface method is
returned.
<p>In either &quot;call&quot; or &quot;invoke&quot; mode, if the callee is a method, its
receiver is represented by sig.Recv, not sig.Params().At(0).

				
				
				
			
				
				<h3 id="CallCommon.StaticCallee">func (*CallCommon) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=52023:52068#L1475">StaticCallee</a>
					<a class="permalink" href="#CallCommon.StaticCallee">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#CallCommon">CallCommon</a>) StaticCallee() *<a href="#Function">Function</a></pre>
				<p>StaticCallee returns the callee if this is a trivially static
&quot;call&quot;-mode call to a function.

				
				
				
			
				
				<h3 id="CallCommon.String">func (*CallCommon) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=3606:3642#L144">String</a>
					<a class="permalink" href="#CallCommon.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#CallCommon">CallCommon</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="CallInstruction">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=52931:53131#L1508">CallInstruction</a>
				<a class="permalink" href="#CallInstruction">&#xb6;</a>
				
				
			</h2>
			<p>The CallInstruction interface, implemented by *Go, *Defer and *Call,
exposes the common parts of function-calling instructions,
yet provides a way back to the Value defined by *Call alone.

			<pre>type CallInstruction interface {
    <a href="#Instruction">Instruction</a>
    Common() *<a href="#CallCommon">CallCommon</a> <span class="comment">// returns the common parts of the call</span>
    Value() *<a href="#Call">Call</a>        <span class="comment">// returns the result value of the call (*Call) or nil (*Go, *Defer)</span>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="ChangeInterface">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=28547:28597#L728">ChangeInterface</a>
				<a class="permalink" href="#ChangeInterface">&#xb6;</a>
				
				
			</h2>
			<p>ChangeInterface constructs a value of one interface type from a
value of another interface type known to be assignable to it.
This operation cannot fail.
<p>Pos() returns the ast.CallExpr.Lparen if the instruction arose from
an explicit T(e) conversion; the ast.TypeAssertExpr.Lparen if the
instruction arose from an explicit e.(T) operation; or token.NoPos
otherwise.
<p>Example printed form:
<pre>t1 = change interface interface{} &lt;- I (t0)
</pre>

			<pre>type ChangeInterface struct {
<span id="ChangeInterface.X"></span>    X <a href="#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ChangeInterface.Name">func (*ChangeInterface) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#ChangeInterface.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#ChangeInterface">ChangeInterface</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeInterface.Operands">func (*ChangeInterface) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=61432:61491#L1714">Operands</a>
					<a class="permalink" href="#ChangeInterface.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#ChangeInterface">ChangeInterface</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeInterface.Pos">func (*ChangeInterface) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#ChangeInterface.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#ChangeInterface">ChangeInterface</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeInterface.Referrers">func (*ChangeInterface) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#ChangeInterface.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#ChangeInterface">ChangeInterface</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeInterface.String">func (*ChangeInterface) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=4368:4409#L171">String</a>
					<a class="permalink" href="#ChangeInterface.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#ChangeInterface">ChangeInterface</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeInterface.Type">func (*ChangeInterface) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#ChangeInterface.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#ChangeInterface">ChangeInterface</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="ChangeType">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=26118:26163#L653">ChangeType</a>
				<a class="permalink" href="#ChangeType">&#xb6;</a>
				
				
			</h2>
			<p>The ChangeType instruction applies to X a value-preserving type
change to Type().
<p>Type changes are permitted:
<ul>
<li>between a named type and its underlying type.
<li>between two named types of the same underlying type.
<li>between (possibly named) pointers to identical base types.
<li>from a bidirectional channel to a read- or write-channel,
optionally adding/removing a name.
<li>between a type (t) and an instance of the type (tσ), i.e.
Type() == σ(X.Type()) (or X.Type()== σ(Type())) where
σ is the type substitution of Parent().TypeParams by
Parent().TypeArgs.
</ul>
<p>This operation cannot fail dynamically.
<p>Type changes may to be to or from a type parameter (or both). All
types in the type set of X.Type() have a value-preserving type
change to all types in the type set of Type().
<p>Pos() returns the ast.CallExpr.Lparen, if the instruction arose
from an explicit conversion in the source.
<p>Example printed form:
<pre>t1 = changetype *int &lt;- IntPtr (t0)
</pre>

			<pre>type ChangeType struct {
<span id="ChangeType.X"></span>    X <a href="#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="ChangeType.Name">func (*ChangeType) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#ChangeType.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#ChangeType">ChangeType</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeType.Operands">func (*ChangeType) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=61525:61579#L1718">Operands</a>
					<a class="permalink" href="#ChangeType.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#ChangeType">ChangeType</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeType.Pos">func (*ChangeType) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#ChangeType.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#ChangeType">ChangeType</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeType.Referrers">func (*ChangeType) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#ChangeType.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#ChangeType">ChangeType</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeType.String">func (*ChangeType) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=4193:4229#L169">String</a>
					<a class="permalink" href="#ChangeType.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#ChangeType">ChangeType</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="ChangeType.Type">func (*ChangeType) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#ChangeType.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#ChangeType">ChangeType</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Const">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=20203:20264#L465">Const</a>
				<a class="permalink" href="#Const">&#xb6;</a>
				
				
			</h2>
			<p>A Const represents a value known at build time.
<p>Consts include true constants of boolean, numeric, and string types, as
defined by the Go spec; these are represented by a non-nil Value field.
<p>Consts also include the &quot;zero&quot; value of any type, of which the nil values
of various pointer-like types are a special case; these are represented
by a nil Value field.
<p>Pos() returns token.NoPos.
<p>Example printed forms:
<pre>	42:int
	&quot;hello&quot;:untyped string
	3+4i:MyComplex
	nil:*int
	nil:[]string
	[3]int{}:[3]int
	struct{x string}{}:struct{x string}
    0:interface{int|int64}
    nil:interface{bool|int} // no go/constant representation
</pre>

			<pre>type Const struct {
<span id="Const.Value"></span>    Value <a href="/pkg/go/constant/">constant</a>.<a href="/pkg/go/constant/#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewConst">func <a href="/src/golang.org/x/tools/go/ssa/const.go?s=519:575#L13">NewConst</a>
					<a class="permalink" href="#NewConst">&#xb6;</a>
					
					
				</h3>
				<pre>func NewConst(val <a href="/pkg/go/constant/">constant</a>.<a href="/pkg/go/constant/#Value">Value</a>, typ <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a>) *<a href="#Const">Const</a></pre>
				<p>NewConst returns a new constant of the specified value and type.
val must be valid according to the specification of Const.Value.

				
				
			

			
				
				<h3 id="Const.Complex128">func (*Const) <a href="/src/golang.org/x/tools/go/ssa/const.go?s=6192:6231#L217">Complex128</a>
					<a class="permalink" href="#Const.Complex128">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Const">Const</a>) Complex128() <a href="/pkg/builtin/#complex128">complex128</a></pre>
				<p>Complex128 returns the complex value of this constant truncated to
fit a complex128.

				
				
				
			
				
				<h3 id="Const.Float64">func (*Const) <a href="/src/golang.org/x/tools/go/ssa/const.go?s=5945:5978#L209">Float64</a>
					<a class="permalink" href="#Const.Float64">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Const">Const</a>) Float64() <a href="/pkg/builtin/#float64">float64</a></pre>
				<p>Float64 returns the numeric value of this constant truncated to fit
a float64.

				
				
				
			
				
				<h3 id="Const.Int64">func (*Const) <a href="/src/golang.org/x/tools/go/ssa/const.go?s=5135:5164#L177">Int64</a>
					<a class="permalink" href="#Const.Int64">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Const">Const</a>) Int64() <a href="/pkg/builtin/#int64">int64</a></pre>
				<p>Int64 returns the numeric value of this constant truncated to fit
a signed 64-bit integer.

				
				
				
			
				
				<h3 id="Const.IsNil">func (*Const) <a href="/src/golang.org/x/tools/go/ssa/const.go?s=4367:4395#L151">IsNil</a>
					<a class="permalink" href="#Const.IsNil">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Const">Const</a>) IsNil() <a href="/pkg/builtin/#bool">bool</a></pre>
				<p>IsNil returns true if this constant is a nil value of
a nillable reference type (pointer, slice, channel, map, or function),
a basic interface type, or
a type parameter all of whose possible instantiations are themselves nillable.

				
				
				
			
				
				<h3 id="Const.Name">func (*Const) <a href="/src/golang.org/x/tools/go/ssa/const.go?s=3789:3818#L125">Name</a>
					<a class="permalink" href="#Const.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Const">Const</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Operands">func (*Const) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=64704:64753#L1858">Operands</a>
					<a class="permalink" href="#Const.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Const">Const</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Parent">func (*Const) <a href="/src/golang.org/x/tools/go/ssa/const.go?s=4016:4050#L141">Parent</a>
					<a class="permalink" href="#Const.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Const">Const</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Pos">func (*Const) <a href="/src/golang.org/x/tools/go/ssa/const.go?s=4067:4098#L143">Pos</a>
					<a class="permalink" href="#Const.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Const">Const</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Referrers">func (*Const) <a href="/src/golang.org/x/tools/go/ssa/const.go?s=3956:3998#L137">Referrers</a>
					<a class="permalink" href="#Const.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Const">Const</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Const.RelString">func (*Const) <a href="/src/golang.org/x/tools/go/ssa/const.go?s=2123:2176#L69">RelString</a>
					<a class="permalink" href="#Const.RelString">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Const">Const</a>) RelString(from *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Package">Package</a>) <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Const.String">func (*Const) <a href="/src/golang.org/x/tools/go/ssa/const.go?s=3849:3880#L129">String</a>
					<a class="permalink" href="#Const.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Const">Const</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Type">func (*Const) <a href="/src/golang.org/x/tools/go/ssa/const.go?s=3903:3936#L133">Type</a>
					<a class="permalink" href="#Const.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Const">Const</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
				
				<h3 id="Const.Uint64">func (*Const) <a href="/src/golang.org/x/tools/go/ssa/const.go?s=5546:5577#L193">Uint64</a>
					<a class="permalink" href="#Const.Uint64">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#Const">Const</a>) Uint64() <a href="/pkg/builtin/#uint64">uint64</a></pre>
				<p>Uint64 returns the numeric value of this constant truncated to fit
an unsigned 64-bit integer.

				
				
				
			
		
			
			
			<h2 id="Convert">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=27234:27276#L687">Convert</a>
				<a class="permalink" href="#Convert">&#xb6;</a>
				
				
			</h2>
			<p>The Convert instruction yields the conversion of value X to type
Type().  One or both of those types is basic (but possibly named).
<p>A conversion may change the value and representation of its operand.
Conversions are permitted:
<ul>
<li>between real numeric types.
<li>between complex numeric types.
<li>between string and []byte or []rune.
<li>between pointers and unsafe.Pointer.
<li>between unsafe.Pointer and uintptr.
<li>from (Unicode) integer to (UTF-8) string.
</ul>
<p>A conversion may imply a type name change also.
<p>Conversions may to be to or from a type parameter. All types in
the type set of X.Type() can be converted to all types in the type
set of Type().
<p>This operation cannot fail dynamically.
<p>Conversions of untyped string/number/bool constants to a specific
representation are eliminated during SSA construction.
<p>Pos() returns the ast.CallExpr.Lparen, if the instruction arose
from an explicit conversion in the source.
<p>Example printed form:
<pre>t1 = convert []byte &lt;- string (t0)
</pre>

			<pre>type Convert struct {
<span id="Convert.X"></span>    X <a href="#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Convert.Name">func (*Convert) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#Convert.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Convert">Convert</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Convert.Operands">func (*Convert) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=61613:61664#L1722">Operands</a>
					<a class="permalink" href="#Convert.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Convert">Convert</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Convert.Pos">func (*Convert) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#Convert.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Convert">Convert</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Convert.Referrers">func (*Convert) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#Convert.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Convert">Convert</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Convert.String">func (*Convert) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=4282:4315#L170">String</a>
					<a class="permalink" href="#Convert.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Convert">Convert</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Convert.Type">func (*Convert) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#Convert.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Convert">Convert</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="DebugRef">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=47354:47718#L1353">DebugRef</a>
				<a class="permalink" href="#DebugRef">&#xb6;</a>
				
				
			</h2>
			<p>A DebugRef instruction maps a source-level expression Expr to the
SSA value X that represents the value (!IsAddr) or address (IsAddr)
of that expression.
<p>DebugRef is a pseudo-instruction: it has no dynamic effect.
<p>Pos() returns Expr.Pos(), the start position of the source-level
expression.  This is not the same as the &quot;designated&quot; token as
documented at Value.Pos(). e.g. CallExpr.Pos() does not return the
position of the (&quot;designated&quot;) Lparen token.
<p>If Expr is an *ast.Ident denoting a var or func, Object() returns
the object; though this information can be obtained from the type
checker, including it here greatly facilitates debugging.
For non-Ident expressions, Object() returns nil.
<p>DebugRefs are generated only for functions built with debugging
enabled; see Package.SetDebugMode() and the GlobalDebug builder
mode flag.
<p>DebugRefs are not emitted for ast.Idents referring to constants or
predeclared identifiers, since they are trivial and numerous.
Nor are they emitted for ast.ParenExprs.
<p>(By representing these as instructions, rather than out-of-band,
consistency is maintained during transformation passes by the
ordinary SSA renaming machinery.)
<p>Example printed form:
<pre>; *ast.CallExpr @ 102:9 is t5
; var x float64 @ 109:72 is x
; address of *ast.CompositeLit @ 216:10 is t0
</pre>

			<pre>type DebugRef struct {
<span id="DebugRef.Expr"></span>    Expr <a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Expr">Expr</a> <span class="comment">// the referring expression (never *ast.ParenExpr)</span>

<span id="DebugRef.IsAddr"></span>    IsAddr <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// Expr is addressable and X is the address it denotes</span>
<span id="DebugRef.X"></span>    X      <a href="#Value">Value</a> <span class="comment">// the value or address of Expr</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="DebugRef.Block">func (*DebugRef) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57835:57878#L1619">Block</a>
					<a class="permalink" href="#DebugRef.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#DebugRef">DebugRef</a>) Block() *<a href="#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="DebugRef.Object">func (*DebugRef) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=59339:59379#L1641">Object</a>
					<a class="permalink" href="#DebugRef.Object">&#xb6;</a>
					
					
				</h3>
				<pre>func (d *<a href="#DebugRef">DebugRef</a>) Object() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Object">Object</a></pre>
				
				
				
				
			
				
				<h3 id="DebugRef.Operands">func (*DebugRef) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=61885:61937#L1734">Operands</a>
					<a class="permalink" href="#DebugRef.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#DebugRef">DebugRef</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="DebugRef.Parent">func (*DebugRef) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57757:57799#L1618">Parent</a>
					<a class="permalink" href="#DebugRef.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#DebugRef">DebugRef</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="DebugRef.Pos">func (*DebugRef) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60751:60785#L1682">Pos</a>
					<a class="permalink" href="#DebugRef.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#DebugRef">DebugRef</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="DebugRef.Referrers">func (*DebugRef) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57978:58028#L1621">Referrers</a>
					<a class="permalink" href="#DebugRef.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#DebugRef">DebugRef</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="DebugRef.String">func (*DebugRef) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=9461:9495#L386">String</a>
					<a class="permalink" href="#DebugRef.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#DebugRef">DebugRef</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Defer">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=44738:44937#L1265">Defer</a>
				<a class="permalink" href="#Defer">&#xb6;</a>
				
				
			</h2>
			<p>The Defer instruction pushes the specified call onto a stack of
functions to be called by a RunDefers instruction or by a panic.
<p>If DeferStack != nil, it indicates the defer list that the defer is
added to. Defer list values come from the Builtin function
ssa:deferstack. Calls to ssa:deferstack() produces the defer stack
of the current function frame. DeferStack allows for deferring into an
alternative function stack than the current function.
<p>See CallCommon for generic function call documentation.
<p>Pos() returns the ast.DeferStmt.Defer.
<p>Example printed form:
<pre>defer println(t0, t1)
defer t3()
defer invoke t5.Println(...t6)
</pre>

			<pre>type Defer struct {
<span id="Defer.Call"></span>    Call       <a href="#CallCommon">CallCommon</a>
<span id="Defer.DeferStack"></span>    DeferStack <a href="#Value">Value</a> <span class="comment">// stack of deferred functions (from ssa:deferstack() intrinsic) onto which this function is pushed</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Defer.Block">func (*Defer) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57835:57878#L1619">Block</a>
					<a class="permalink" href="#Defer.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Defer">Defer</a>) Block() *<a href="#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="Defer.Common">func (*Defer) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=53189:53225#L1515">Common</a>
					<a class="permalink" href="#Defer.Common">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Defer">Defer</a>) Common() *<a href="#CallCommon">CallCommon</a></pre>
				
				
				
				
			
				
				<h3 id="Defer.Operands">func (*Defer) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=61323:61372#L1710">Operands</a>
					<a class="permalink" href="#Defer.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Defer">Defer</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Defer.Parent">func (*Defer) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57757:57799#L1618">Parent</a>
					<a class="permalink" href="#Defer.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Defer">Defer</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Defer.Pos">func (*Defer) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60203:60234#L1672">Pos</a>
					<a class="permalink" href="#Defer.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Defer">Defer</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Defer.Referrers">func (*Defer) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57978:58028#L1621">Referrers</a>
					<a class="permalink" href="#Defer.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Defer">Defer</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Defer.String">func (*Defer) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=8588:8619#L347">String</a>
					<a class="permalink" href="#Defer.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Defer">Defer</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Defer.Value">func (*Defer) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=53345:53374#L1519">Value</a>
					<a class="permalink" href="#Defer.Value">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Defer">Defer</a>) Value() *<a href="#Call">Call</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Extract">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=41107:41164#L1126">Extract</a>
				<a class="permalink" href="#Extract">&#xb6;</a>
				
				
			</h2>
			<p>The Extract instruction yields component Index of Tuple.
<p>This is used to access the results of instructions with multiple
return values, such as Call, TypeAssert, Next, UnOp(ARROW) and
IndexExpr(Map).
<p>Example printed form:
<pre>t1 = extract t0 #1
</pre>

			<pre>type Extract struct {
<span id="Extract.Tuple"></span>    Tuple <a href="#Value">Value</a>
<span id="Extract.Index"></span>    Index <a href="/pkg/builtin/#int">int</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Extract.Name">func (*Extract) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#Extract.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Extract">Extract</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Extract.Operands">func (*Extract) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=61971:62022#L1738">Operands</a>
					<a class="permalink" href="#Extract.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Extract">Extract</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Extract.Pos">func (*Extract) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#Extract.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Extract">Extract</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Extract.Referrers">func (*Extract) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#Extract.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Extract">Extract</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Extract.String">func (*Extract) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=7423:7456#L294">String</a>
					<a class="permalink" href="#Extract.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Extract">Extract</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Extract.Type">func (*Extract) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#Extract.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Extract">Extract</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Field">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=34013:34136#L912">Field</a>
				<a class="permalink" href="#Field">&#xb6;</a>
				
				
			</h2>
			<p>Example printed form:
<pre>t1 = t0.name [#1]
</pre>

			<pre>type Field struct {
<span id="Field.X"></span>    X     <a href="#Value">Value</a> <span class="comment">// struct</span>
<span id="Field.Field"></span>    Field <a href="/pkg/builtin/#int">int</a>   <span class="comment">// index into CoreType(X.Type()).(*types.Struct).Fields</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Field.Name">func (*Field) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#Field.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Field">Field</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Field.Operands">func (*Field) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=62060:62109#L1742">Operands</a>
					<a class="permalink" href="#Field.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Field">Field</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Field.Pos">func (*Field) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#Field.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Field">Field</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Field.Referrers">func (*Field) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#Field.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Field">Field</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Field.String">func (*Field) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=6523:6554#L260">String</a>
					<a class="permalink" href="#Field.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Field">Field</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Field.Type">func (*Field) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#Field.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Field">Field</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="FieldAddr">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=33348:33510#L893">FieldAddr</a>
				<a class="permalink" href="#FieldAddr">&#xb6;</a>
				
				
			</h2>
			<p>The FieldAddr instruction yields the address of Field of *struct X.
<p>The field is identified by its index within the field list of the
struct type of X.
<p>Dynamically, this instruction panics if X evaluates to a nil
pointer.
<p>Type() returns a (possibly named) *types.Pointer.
<p>Pos() returns the position of the ast.SelectorExpr.Sel for the
field, if explicit in the source. For implicit selections, returns
the position of the inducing explicit selection. If produced for a
struct literal S{f: e}, it returns the position of the colon; for
S{e} it returns the start of expression e.
<p>Example printed form:
<pre>t1 = &amp;t0.name [#1]
</pre>

			<pre>type FieldAddr struct {
<span id="FieldAddr.X"></span>    X     <a href="#Value">Value</a> <span class="comment">// *struct</span>
<span id="FieldAddr.Field"></span>    Field <a href="/pkg/builtin/#int">int</a>   <span class="comment">// index into CoreType(CoreType(X.Type()).(*types.Pointer).Elem()).(*types.Struct).Fields</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="FieldAddr.Name">func (*FieldAddr) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#FieldAddr.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#FieldAddr">FieldAddr</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="FieldAddr.Operands">func (*FieldAddr) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=62143:62196#L1746">Operands</a>
					<a class="permalink" href="#FieldAddr.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#FieldAddr">FieldAddr</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="FieldAddr.Pos">func (*FieldAddr) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#FieldAddr.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#FieldAddr">FieldAddr</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="FieldAddr.Referrers">func (*FieldAddr) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#FieldAddr.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#FieldAddr">FieldAddr</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="FieldAddr.String">func (*FieldAddr) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=6267:6302#L251">String</a>
					<a class="permalink" href="#FieldAddr.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#FieldAddr">FieldAddr</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="FieldAddr.Type">func (*FieldAddr) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#FieldAddr.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#FieldAddr">FieldAddr</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="FreeVar">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=19071:19305#L423">FreeVar</a>
				<a class="permalink" href="#FreeVar">&#xb6;</a>
				
				
			</h2>
			<p>A FreeVar represents a free variable of the function to which it
belongs.
<p>FreeVars are used to implement anonymous functions, whose free
variables are lexically captured in a closure formed by
MakeClosure.  The value of such a free var is an Alloc or another
FreeVar and is considered a potentially escaping heap address, with
pointer type.
<p>FreeVars are also used to implement bound method closures.  Such a
free var represents the receiver value and may be of any type that
has concrete methods.
<p>Pos() returns the position of the value that was captured, which
belongs to an enclosing function.

			<pre>type FreeVar struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="FreeVar.Name">func (*FreeVar) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=53886:53917#L1530">Name</a>
					<a class="permalink" href="#FreeVar.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#FreeVar">FreeVar</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="FreeVar.Operands">func (*FreeVar) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=64633:64684#L1857">Operands</a>
					<a class="permalink" href="#FreeVar.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#FreeVar">FreeVar</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="FreeVar.Parent">func (*FreeVar) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=54080:54116#L1533">Parent</a>
					<a class="permalink" href="#FreeVar.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#FreeVar">FreeVar</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="FreeVar.Pos">func (*FreeVar) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=54018:54051#L1532">Pos</a>
					<a class="permalink" href="#FreeVar.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#FreeVar">FreeVar</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="FreeVar.Referrers">func (*FreeVar) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=53949:53993#L1531">Referrers</a>
					<a class="permalink" href="#FreeVar.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#FreeVar">FreeVar</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="FreeVar.String">func (*FreeVar) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=2062:2095#L71">String</a>
					<a class="permalink" href="#FreeVar.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#FreeVar">FreeVar</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="FreeVar.Type">func (*FreeVar) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=53824:53859#L1529">Type</a>
					<a class="permalink" href="#FreeVar.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#FreeVar">FreeVar</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Function">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=13639:17027#L324">Function</a>
				<a class="permalink" href="#Function">&#xb6;</a>
				
				
			</h2>
			<p>Function represents the parameters, results, and code of a function
or method.
<p>If Blocks is nil, this indicates an external function for which no
Go source code is available.  In this case, FreeVars, Locals, and
Params are nil too.  Clients performing whole-program analysis must
handle external functions specially.
<p>Blocks contains the function&apos;s control-flow graph (CFG).
Blocks[0] is the function entry point; block order is not otherwise
semantically significant, though it may affect the readability of
the disassembly.
To iterate over the blocks in dominance order, use DomPreorder().
<p>Recover is an optional second entry point to which control resumes
after a recovered panic.  The Recover block may contain only a return
statement, preceded by a load of the function&apos;s named return
parameters, if any.
<p>A nested function (Parent()!=nil) that refers to one or more
lexically enclosing local variables (&quot;free variables&quot;) has FreeVars.
Such functions cannot be called directly but require a
value created by MakeClosure which, via its Bindings, supplies
values for these parameters.
<p>If the function is a method (Signature.Recv() != nil) then the first
element of Params is the receiver parameter.
<p>A Go package may declare many functions called &quot;init&quot;.
For each one, Object().Name() returns &quot;init&quot; but Name() returns
&quot;init#1&quot;, etc, in declaration order.
<p>Pos() returns the declaring ast.FuncLit.Type.Func or the position
of the ast.FuncDecl.Name, if the function was explicit in the
source. Synthetic wrappers, for which Synthetic != &quot;&quot;, may share
the same position as the function they wrap.
Syntax.Pos() always returns the position of the declaring &quot;func&quot; token.
<p>When the operand of a range statement is an iterator function,
the loop body is transformed into a synthetic anonymous function
that is passed as the yield argument in a call to the iterator.
In that case, Function.Pos is the position of the &quot;range&quot; token,
and Function.Syntax is the ast.RangeStmt.
<p>Synthetic functions, for which Synthetic != &quot;&quot;, are functions
that do not appear in the source AST. These include:
<ul>
<li>method wrappers,
<li>thunks,
<li>bound functions,
<li>empty functions built from loaded type information,
<li>yield functions created from range-over-func loops,
<li>package init functions, and
<li>instantiations of generic functions.
</ul>
<p>Synthetic wrapper functions may share the same position
as the function they wrap.
<p>Type() returns the function&apos;s Signature.
<p>A generic function is a function or method that has uninstantiated type
parameters (TypeParams() != nil). Consider a hypothetical generic
method, (*Map[K,V]).Get. It may be instantiated with all
non-parameterized types as (*Map[string,int]).Get or with
parameterized types as (*Map[string,U]).Get, where U is a type parameter.
In both instantiations, Origin() refers to the instantiated generic
method, (*Map[K,V]).Get, TypeParams() refers to the parameters [K,V] of
the generic method. TypeArgs() refers to [string,U] or [string,int],
respectively, and is nil in the generic method.

			<pre>type Function struct {
<span id="Function.Signature"></span>    Signature *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Signature">Signature</a>

    <span class="comment">// source information</span>
<span id="Function.Synthetic"></span>    Synthetic <a href="/pkg/builtin/#string">string</a> <span class="comment">// provenance of synthetic function; &#34;&#34; for true source functions</span>

<span id="Function.Pkg"></span>    Pkg  *<a href="#Package">Package</a> <span class="comment">// enclosing package; nil for shared funcs (wrappers and error.Error)</span>
<span id="Function.Prog"></span>    Prog *<a href="#Program">Program</a> <span class="comment">// enclosing program</span>

<span id="Function.Params"></span>    Params    []*<a href="#Parameter">Parameter</a>  <span class="comment">// function parameters; for methods, includes receiver</span>
<span id="Function.FreeVars"></span>    FreeVars  []*<a href="#FreeVar">FreeVar</a>    <span class="comment">// free variables whose values must be supplied by closure</span>
<span id="Function.Locals"></span>    Locals    []*<a href="#Alloc">Alloc</a>      <span class="comment">// frame-allocated variables of this function</span>
<span id="Function.Blocks"></span>    Blocks    []*<a href="#BasicBlock">BasicBlock</a> <span class="comment">// basic blocks of the function; nil =&gt; external</span>
<span id="Function.Recover"></span>    Recover   *<a href="#BasicBlock">BasicBlock</a>   <span class="comment">// optional; control transfers here after recovered panic</span>
<span id="Function.AnonFuncs"></span>    AnonFuncs []*<a href="#Function">Function</a>   <span class="comment">// anonymous functions (from FuncLit,RangeStmt) directly beneath this one</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="EnclosingFunction">func <a href="/src/golang.org/x/tools/go/ssa/source.go?s=914:977#L20">EnclosingFunction</a>
					<a class="permalink" href="#EnclosingFunction">&#xb6;</a>
					
					
				</h3>
				<pre>func EnclosingFunction(pkg *<a href="#Package">Package</a>, path []<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Node">Node</a>) *<a href="#Function">Function</a></pre>
				<p>EnclosingFunction returns the function that contains the syntax
node denoted by path.
<p>Syntax associated with package-level variable specifications is
enclosed by the package&apos;s init() function.
<p>Returns nil if not found; reasons might include:
<ul>
<li>the node is not enclosed by any function.
<li>the node is within an anonymous function (FuncLit) and
its SSA function has not been created yet
(pkg.Build() has not yet been called).
</ul>

				
				
			

			
				
				<h3 id="Function.DomPostorder">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/dom.go?s=1851:1898#L46">DomPostorder</a>
					<a class="permalink" href="#Function.DomPostorder">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="#Function">Function</a>) DomPostorder() []*<a href="#BasicBlock">BasicBlock</a></pre>
				<p>DomPostorder returns a new slice containing the blocks of f
in a postorder traversal of the dominator tree.
(This is not the same as a postdominance order.)

				
				
				
			
				
				<h3 id="Function.DomPreorder">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/dom.go?s=1479:1525#L35">DomPreorder</a>
					<a class="permalink" href="#Function.DomPreorder">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="#Function">Function</a>) DomPreorder() []*<a href="#BasicBlock">BasicBlock</a></pre>
				<p>DomPreorder returns a new slice containing the blocks of f
in a preorder traversal of the dominator tree.

				
				
				
			
				
				<h3 id="Function.Name">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=54895:54927#L1546">Name</a>
					<a class="permalink" href="#Function.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Function">Function</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Object">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=55131:55171#L1550">Object</a>
					<a class="permalink" href="#Function.Object">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Function">Function</a>) Object() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Object">Object</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Operands">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=64775:64827#L1859">Operands</a>
					<a class="permalink" href="#Function.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Function">Function</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Origin">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=56030:56068#L1578">Origin</a>
					<a class="permalink" href="#Function.Origin">&#xb6;</a>
					
					
				</h3>
				<pre>func (fn *<a href="#Function">Function</a>) Origin() *<a href="#Function">Function</a></pre>
				<p>Origin returns the generic function from which fn was instantiated,
or nil if fn is not an instantiation.

				
				
				
			
				
				<h3 id="Function.Package">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=55311:55348#L1557">Package</a>
					<a class="permalink" href="#Function.Package">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Function">Function</a>) Package() *<a href="#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Parent">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=55366:55403#L1558">Parent</a>
					<a class="permalink" href="#Function.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Function">Function</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Pos">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=55014:55048#L1548">Pos</a>
					<a class="permalink" href="#Function.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Function">Function</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Referrers">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=55424:55469#L1559">Referrers</a>
					<a class="permalink" href="#Function.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Function">Function</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Function.RelString">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/func.go?s=14433:14489#L499">RelString</a>
					<a class="permalink" href="#Function.RelString">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="#Function">Function</a>) RelString(from *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Package">Package</a>) <a href="/pkg/builtin/#string">string</a></pre>
				<p>RelString returns the full name of this function, qualified by
package name, receiver type, etc.
<p>The specific formatting rules are not guaranteed and may change.
<p>Examples:
<pre>&quot;math.IsNaN&quot;                  // a package-level function
&quot;(*bytes.Buffer).Bytes&quot;       // a declared method or a wrapper
&quot;(*bytes.Buffer).Bytes$thunk&quot; // thunk (func wrapping method; receiver is param 0)
&quot;(*bytes.Buffer).Bytes$bound&quot; // bound (func wrapping method; receiver supplied by closure)
&quot;main.main$1&quot;                 // an anonymous function in main
&quot;main.init#1&quot;                 // a declared init function
&quot;main.init&quot;                   // the synthesized package initializer
</pre>
<p>When these functions are referred to from within the same package
(i.e. from == f.Pkg.Object), they are rendered without the package path.
For example: &quot;IsNaN&quot;, &quot;(*Buffer).Bytes&quot;, etc.
<p>All non-synthetic functions have distinct package-qualified names.
(But two methods may have the same name &quot;(T).f&quot; if one is a synthetic
wrapper promoting a non-exported method &quot;f&quot; from another package; in
that case, the strings are equal but the identifiers &quot;f&quot; are distinct.)

				
				
				
			
				
				<h3 id="Function.String">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=55245:55279#L1556">String</a>
					<a class="permalink" href="#Function.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Function">Function</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Syntax">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/func.go?s=21170:21206#L726">Syntax</a>
					<a class="permalink" href="#Function.Syntax">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="#Function">Function</a>) Syntax() <a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Node">Node</a></pre>
				<p>Syntax returns the function&apos;s syntax (*ast.Func{Decl,Lit})
if it was produced from syntax or an *ast.RangeStmt if
it is a range-over-func yield function.

				
				
				
			
				
				<h3 id="Function.Token">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=55070:55108#L1549">Token</a>
					<a class="permalink" href="#Function.Token">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Function">Function</a>) Token() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Token">Token</a></pre>
				
				
				
				
			
				
				<h3 id="Function.Type">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=54952:54988#L1547">Type</a>
					<a class="permalink" href="#Function.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Function">Function</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
				
				<h3 id="Function.TypeArgs">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=55850:55893#L1574">TypeArgs</a>
					<a class="permalink" href="#Function.TypeArgs">&#xb6;</a>
					
					
				</h3>
				<pre>func (fn *<a href="#Function">Function</a>) TypeArgs() []<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				<p>TypeArgs are the types that TypeParams() were instantiated by to create fn
from fn.Origin().

				
				
				
			
				
				<h3 id="Function.TypeParams">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=55670:55723#L1568">TypeParams</a>
					<a class="permalink" href="#Function.TypeParams">&#xb6;</a>
					
					
				</h3>
				<pre>func (fn *<a href="#Function">Function</a>) TypeParams() *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#TypeParamList">TypeParamList</a></pre>
				<p>TypeParams are the function&apos;s type parameters if generic or the
type parameters that were instantiated if fn is an instantiation.

				
				
				
			
				
				<h3 id="Function.ValueForExpr">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/source.go?s=4959:5029#L144">ValueForExpr</a>
					<a class="permalink" href="#Function.ValueForExpr">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="#Function">Function</a>) ValueForExpr(e <a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Expr">Expr</a>) (value <a href="#Value">Value</a>, isAddr <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>ValueForExpr returns the SSA Value that corresponds to non-constant
expression e.
<p>It returns nil if no value was found, e.g.
<ul>
<li>the expression is not lexically contained within f;
<li>f was not built with debug information; or
<li>e is a constant expression.  (For efficiency, no debug
information is stored for constants. Use
go/types.Info.Types[e].Value instead.)
<li>e is a reference to nil or a built-in function.
<li>the value was optimised away.
</ul>
<p>If e is an addressable expression used in an lvalue context,
value is the address denoted by e, and isAddr is true.
<p>The types of e (or &amp;e, if isAddr) and the result are equal
(modulo &quot;untyped&quot; bools resulting from comparisons).
<p>(Tip: to find the ssa.Value given a source position, use
astutil.PathEnclosingInterval to locate the ast.Node, then
EnclosingFunction to locate the Function, then ValueForExpr to find
the ssa.Value.)

				
				
				
			
				
				<h3 id="Function.WriteTo">func (*Function) <a href="/src/golang.org/x/tools/go/ssa/func.go?s=16870:16924#L584">WriteTo</a>
					<a class="permalink" href="#Function.WriteTo">&#xb6;</a>
					
					
				</h3>
				<pre>func (f *<a href="#Function">Function</a>) WriteTo(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>) (<a href="/pkg/builtin/#int64">int64</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="Global">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=20425:20594#L475">Global</a>
				<a class="permalink" href="#Global">&#xb6;</a>
				
				
			</h2>
			<p>A Global is a named Value holding the address of a package-level
variable.
<p>Pos() returns the position of the ast.ValueSpec.Names[*]
identifier.

			<pre>type Global struct {
<span id="Global.Pkg"></span>    Pkg *<a href="#Package">Package</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Global.Name">func (*Global) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=54218:54248#L1536">Name</a>
					<a class="permalink" href="#Global.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Global">Global</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Object">func (*Global) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=54579:54617#L1541">Object</a>
					<a class="permalink" href="#Global.Object">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Global">Global</a>) Object() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Object">Object</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Operands">func (*Global) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=64846:64896#L1860">Operands</a>
					<a class="permalink" href="#Global.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Global">Global</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Package">func (*Global) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=54737:54772#L1543">Package</a>
					<a class="permalink" href="#Global.Package">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Global">Global</a>) Package() *<a href="#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Parent">func (*Global) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=54291:54326#L1537">Parent</a>
					<a class="permalink" href="#Global.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Global">Global</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Pos">func (*Global) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=54361:54393#L1538">Pos</a>
					<a class="permalink" href="#Global.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Global">Global</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Referrers">func (*Global) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=54433:54476#L1539">Referrers</a>
					<a class="permalink" href="#Global.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Global">Global</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Global.RelString">func (*Global) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=54809:54863#L1544">RelString</a>
					<a class="permalink" href="#Global.RelString">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Global">Global</a>) RelString(from *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Package">Package</a>) <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Global.String">func (*Global) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=54654:54686#L1542">String</a>
					<a class="permalink" href="#Global.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Global">Global</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Token">func (*Global) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=54503:54539#L1540">Token</a>
					<a class="permalink" href="#Global.Token">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Global">Global</a>) Token() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Token">Token</a></pre>
				
				
				
				
			
				
				<h3 id="Global.Type">func (*Global) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=54146:54180#L1535">Type</a>
					<a class="permalink" href="#Global.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Global">Global</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Go">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=43987:44053#L1241">Go</a>
				<a class="permalink" href="#Go">&#xb6;</a>
				
				
			</h2>
			<p>The Go instruction creates a new goroutine and calls the specified
function within it.
<p>See CallCommon for generic function call documentation.
<p>Pos() returns the ast.GoStmt.Go.
<p>Example printed form:
<pre>go println(t0, t1)
go t3()
go invoke t5.Println(...t6)
</pre>

			<pre>type Go struct {
<span id="Go.Call"></span>    Call <a href="#CallCommon">CallCommon</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Go.Block">func (*Go) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57835:57878#L1619">Block</a>
					<a class="permalink" href="#Go.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Go">Go</a>) Block() *<a href="#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="Go.Common">func (*Go) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=53245:53278#L1516">Common</a>
					<a class="permalink" href="#Go.Common">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Go">Go</a>) Common() *<a href="#CallCommon">CallCommon</a></pre>
				
				
				
				
			
				
				<h3 id="Go.Operands">func (*Go) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=61155:61201#L1702">Operands</a>
					<a class="permalink" href="#Go.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Go">Go</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Go.Parent">func (*Go) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57757:57799#L1618">Parent</a>
					<a class="permalink" href="#Go.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Go">Go</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Go.Pos">func (*Go) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60256:60284#L1673">Pos</a>
					<a class="permalink" href="#Go.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Go">Go</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Go.Referrers">func (*Go) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57978:58028#L1621">Referrers</a>
					<a class="permalink" href="#Go.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Go">Go</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Go.String">func (*Go) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=8035:8063#L317">String</a>
					<a class="permalink" href="#Go.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Go">Go</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Go.Value">func (*Go) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=53390:53416#L1520">Value</a>
					<a class="permalink" href="#Go.Value">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Go">Go</a>) Value() *<a href="#Call">Call</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="If">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=41861:41906#L1160">If</a>
				<a class="permalink" href="#If">&#xb6;</a>
				
				
			</h2>
			<p>The If instruction transfers control to one of the two successors
of its owning block, depending on the boolean Cond: the first if
true, the second if false.
<p>An If instruction must be the last instruction of its containing
BasicBlock.
<p>Pos() returns NoPos.
<p>Example printed form:
<pre>if t0 goto done else body
</pre>

			<pre>type If struct {
<span id="If.Cond"></span>    Cond <a href="#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="If.Block">func (*If) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57835:57878#L1619">Block</a>
					<a class="permalink" href="#If.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#If">If</a>) Block() *<a href="#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="If.Operands">func (*If) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=62230:62276#L1750">Operands</a>
					<a class="permalink" href="#If.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#If">If</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="If.Parent">func (*If) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57757:57799#L1618">Parent</a>
					<a class="permalink" href="#If.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#If">If</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="If.Pos">func (*If) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60574:60602#L1679">Pos</a>
					<a class="permalink" href="#If.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#If">If</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="If.Referrers">func (*If) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57978:58028#L1621">Referrers</a>
					<a class="permalink" href="#If.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#If">If</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="If.String">func (*If) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=7738:7766#L307">String</a>
					<a class="permalink" href="#If.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#If">If</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Index">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=35144:35297#L951">Index</a>
				<a class="permalink" href="#Index">&#xb6;</a>
				
				
			</h2>
			<p>The Index instruction yields element Index of collection X, an array,
string or type parameter containing an array, a string, a pointer to an,
array or a slice.
<p>Pos() returns the ast.IndexExpr.Lbrack for the index operation, if
explicit in the source.
<p>Example printed form:
<pre>t2 = t0[t1]
</pre>

			<pre>type Index struct {
<span id="Index.X"></span>    X     <a href="#Value">Value</a> <span class="comment">// array, string or type parameter with types array, *array, slice, or string.</span>
<span id="Index.Index"></span>    Index <a href="#Value">Value</a> <span class="comment">// integer index</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Index.Name">func (*Index) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#Index.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Index">Index</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Index.Operands">func (*Index) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=62313:62362#L1754">Operands</a>
					<a class="permalink" href="#Index.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Index">Index</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Index.Pos">func (*Index) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#Index.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Index">Index</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Index.Referrers">func (*Index) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#Index.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Index">Index</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Index.String">func (*Index) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=6862:6893#L273">String</a>
					<a class="permalink" href="#Index.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Index">Index</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Index.Type">func (*Index) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#Index.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Index">Index</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="IndexAddr">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=34677:34826#L935">IndexAddr</a>
				<a class="permalink" href="#IndexAddr">&#xb6;</a>
				
				
			</h2>
			<p>The IndexAddr instruction yields the address of the element at
index Index of collection X.  Index is an integer expression.
<p>The elements of maps and strings are not addressable; use Lookup (map),
Index (string), or MapUpdate instead.
<p>Dynamically, this instruction panics if X evaluates to a nil *array
pointer.
<p>Type() returns a (possibly named) *types.Pointer.
<p>Pos() returns the ast.IndexExpr.Lbrack for the index operation, if
explicit in the source.
<p>Example printed form:
<pre>t2 = &amp;t0[t1]
</pre>

			<pre>type IndexAddr struct {
<span id="IndexAddr.X"></span>    X     <a href="#Value">Value</a> <span class="comment">// *array, slice or type parameter with types array, *array, or slice.</span>
<span id="IndexAddr.Index"></span>    Index <a href="#Value">Value</a> <span class="comment">// numeric index</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="IndexAddr.Name">func (*IndexAddr) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#IndexAddr.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#IndexAddr">IndexAddr</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="IndexAddr.Operands">func (*IndexAddr) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=62406:62459#L1758">Operands</a>
					<a class="permalink" href="#IndexAddr.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#IndexAddr">IndexAddr</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="IndexAddr.Pos">func (*IndexAddr) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#IndexAddr.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#IndexAddr">IndexAddr</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="IndexAddr.Referrers">func (*IndexAddr) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#IndexAddr.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#IndexAddr">IndexAddr</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="IndexAddr.String">func (*IndexAddr) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=6752:6787#L269">String</a>
					<a class="permalink" href="#IndexAddr.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#IndexAddr">IndexAddr</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="IndexAddr.Type">func (*IndexAddr) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#IndexAddr.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#IndexAddr">IndexAddr</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Instruction">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=7266:9671#L169">Instruction</a>
				<a class="permalink" href="#Instruction">&#xb6;</a>
				
				
			</h2>
			<p>An Instruction is an SSA instruction that computes a new Value or
has some effect.
<p>An Instruction that defines a value (e.g. BinOp) also implements
the Value interface; an Instruction that only has an effect (e.g. Store)
does not.

			<pre>type Instruction interface {
    <span class="comment">// String returns the disassembled form of this value.</span>
    <span class="comment">//</span>
    <span class="comment">// Examples of Instructions that are Values:</span>
    <span class="comment">//       &#34;x + y&#34;     (BinOp)</span>
    <span class="comment">//       &#34;len([])&#34;   (Call)</span>
    <span class="comment">// Note that the name of the Value is not printed.</span>
    <span class="comment">//</span>
    <span class="comment">// Examples of Instructions that are not Values:</span>
    <span class="comment">//       &#34;return x&#34;  (Return)</span>
    <span class="comment">//       &#34;*y = x&#34;    (Store)</span>
    <span class="comment">//</span>
    <span class="comment">// (The separation Value.Name() from Value.String() is useful</span>
    <span class="comment">// for some analyses which distinguish the operation from the</span>
    <span class="comment">// value it defines, e.g., &#39;y = local int&#39; is both an allocation</span>
    <span class="comment">// of memory &#39;local int&#39; and a definition of a pointer y.)</span>
    String() <a href="/pkg/builtin/#string">string</a>

    <span class="comment">// Parent returns the function to which this instruction</span>
    <span class="comment">// belongs.</span>
    Parent() *<a href="#Function">Function</a>

    <span class="comment">// Block returns the basic block to which this instruction</span>
    <span class="comment">// belongs.</span>
    Block() *<a href="#BasicBlock">BasicBlock</a>

    <span class="comment">// Operands returns the operands of this instruction: the</span>
    <span class="comment">// set of Values it references.</span>
    <span class="comment">//</span>
    <span class="comment">// Specifically, it appends their addresses to rands, a</span>
    <span class="comment">// user-provided slice, and returns the resulting slice,</span>
    <span class="comment">// permitting avoidance of memory allocation.</span>
    <span class="comment">//</span>
    <span class="comment">// The operands are appended in undefined order, but the order</span>
    <span class="comment">// is consistent for a given Instruction; the addresses are</span>
    <span class="comment">// always non-nil but may point to a nil Value.  Clients may</span>
    <span class="comment">// store through the pointers, e.g. to effect a value</span>
    <span class="comment">// renaming.</span>
    <span class="comment">//</span>
    <span class="comment">// Value.Referrers is a subset of the inverse of this</span>
    <span class="comment">// relation.  (Referrers are not tracked for all types of</span>
    <span class="comment">// Values.)</span>
    Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a>

    <span class="comment">// Pos returns the location of the AST token most closely</span>
    <span class="comment">// associated with the operation that gave rise to this</span>
    <span class="comment">// instruction, or token.NoPos if it was not explicit in the</span>
    <span class="comment">// source.</span>
    <span class="comment">//</span>
    <span class="comment">// For each ast.Node type, a particular token is designated as</span>
    <span class="comment">// the closest location for the expression, e.g. the Go token</span>
    <span class="comment">// for an *ast.GoStmt.  This permits a compact but approximate</span>
    <span class="comment">// mapping from Instructions to source positions for use in</span>
    <span class="comment">// diagnostic messages, for example.</span>
    <span class="comment">//</span>
    <span class="comment">// (Do not use this position to determine which Instruction</span>
    <span class="comment">// corresponds to an ast.Expr; see the notes for Value.Pos.</span>
    <span class="comment">// This position may be used to determine which non-Value</span>
    <span class="comment">// Instruction corresponds to some ast.Stmts, but not all: If</span>
    <span class="comment">// and Jump instructions have no Pos(), for example.)</span>
    Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>
    <span class="comment">// contains filtered or unexported methods</span>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Jump">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=41484:41519#L1144">Jump</a>
				<a class="permalink" href="#Jump">&#xb6;</a>
				
				
			</h2>
			<p>The Jump instruction transfers control to the sole successor of its
owning block.
<p>A Jump must be the last instruction of its containing BasicBlock.
<p>Pos() returns NoPos.
<p>Example printed form:
<pre>jump done
</pre>

			<pre>type Jump struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Jump.Block">func (*Jump) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57835:57878#L1619">Block</a>
					<a class="permalink" href="#Jump.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Jump">Jump</a>) Block() *<a href="#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="Jump.Operands">func (*Jump) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=62503:62549#L1762">Operands</a>
					<a class="permalink" href="#Jump.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (*<a href="#Jump">Jump</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Jump.Parent">func (*Jump) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57757:57799#L1618">Parent</a>
					<a class="permalink" href="#Jump.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Jump">Jump</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Jump.Pos">func (*Jump) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60633:60663#L1680">Pos</a>
					<a class="permalink" href="#Jump.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Jump">Jump</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Jump.Referrers">func (*Jump) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57978:58028#L1621">Referrers</a>
					<a class="permalink" href="#Jump.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Jump">Jump</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Jump.String">func (*Jump) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=7530:7560#L298">String</a>
					<a class="permalink" href="#Jump.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Jump">Jump</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Lookup">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=35739:35868#L970">Lookup</a>
				<a class="permalink" href="#Lookup">&#xb6;</a>
				
				
			</h2>
			<p>The Lookup instruction yields element Index of collection map X.
Index is the appropriate key type.
<p>If CommaOk, the result is a 2-tuple of the value above and a
boolean indicating the result of a map membership test for the key.
The components of the tuple are accessed using Extract.
<p>Pos() returns the ast.IndexExpr.Lbrack, if explicit in the source.
<p>Example printed form:
<pre>t2 = t0[t1]
t5 = t3[t4],ok
</pre>

			<pre>type Lookup struct {
<span id="Lookup.X"></span>    X       <a href="#Value">Value</a> <span class="comment">// map</span>
<span id="Lookup.Index"></span>    Index   <a href="#Value">Value</a> <span class="comment">// key-typed index</span>
<span id="Lookup.CommaOk"></span>    CommaOk <a href="/pkg/builtin/#bool">bool</a>  <span class="comment">// return a value,ok pair</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Lookup.Name">func (*Lookup) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#Lookup.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Lookup">Lookup</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Lookup.Operands">func (*Lookup) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=62569:62619#L1766">Operands</a>
					<a class="permalink" href="#Lookup.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Lookup">Lookup</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Lookup.Pos">func (*Lookup) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#Lookup.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Lookup">Lookup</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Lookup.Referrers">func (*Lookup) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#Lookup.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Lookup">Lookup</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Lookup.String">func (*Lookup) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=6967:6999#L277">String</a>
					<a class="permalink" href="#Lookup.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Lookup">Lookup</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Lookup.Type">func (*Lookup) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#Lookup.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Lookup">Lookup</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="MakeChan">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=31268:31359#L824">MakeChan</a>
				<a class="permalink" href="#MakeChan">&#xb6;</a>
				
				
			</h2>
			<p>The MakeChan instruction creates a new channel object and yields a
value of kind chan.
<p>Type() returns a (possibly named) *types.Chan.
<p>Pos() returns the ast.CallExpr.Lparen for the make(chan) that
created it.
<p>Example printed form:
<pre>t0 = make chan int 0
t0 = make IntChan 0
</pre>

			<pre>type MakeChan struct {
<span id="MakeChan.Size"></span>    Size <a href="#Value">Value</a> <span class="comment">// int; size of buffer; zero =&gt; synchronous.</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="MakeChan.Name">func (*MakeChan) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#MakeChan.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeChan">MakeChan</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeChan.Operands">func (*MakeChan) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=62663:62715#L1770">Operands</a>
					<a class="permalink" href="#MakeChan.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeChan">MakeChan</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="MakeChan.Pos">func (*MakeChan) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#MakeChan.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeChan">MakeChan</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="MakeChan.Referrers">func (*MakeChan) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#MakeChan.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeChan">MakeChan</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="MakeChan.String">func (*MakeChan) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=6119:6153#L246">String</a>
					<a class="permalink" href="#MakeChan.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeChan">MakeChan</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeChan.Type">func (*MakeChan) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#MakeChan.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeChan">MakeChan</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="MakeClosure">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=30345:30488#L789">MakeClosure</a>
				<a class="permalink" href="#MakeClosure">&#xb6;</a>
				
				
			</h2>
			<p>The MakeClosure instruction yields a closure value whose code is
Fn and whose free variables&apos; values are supplied by Bindings.
<p>Type() returns a (possibly named) *types.Signature.
<p>Pos() returns the ast.FuncLit.Type.Func for a function literal
closure or the ast.SelectorExpr.Sel for a bound method closure.
<p>Example printed form:
<pre>t0 = make closure anon@1.2 [x y z]
t1 = make closure bound$(main.I).add [i]
</pre>

			<pre>type MakeClosure struct {
<span id="MakeClosure.Fn"></span>    Fn       <a href="#Value">Value</a>   <span class="comment">// always a *Function</span>
<span id="MakeClosure.Bindings"></span>    Bindings []<a href="#Value">Value</a> <span class="comment">// values for each free variable in Fn.FreeVars</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="MakeClosure.Name">func (*MakeClosure) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#MakeClosure.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeClosure">MakeClosure</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeClosure.Operands">func (*MakeClosure) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=62752:62807#L1774">Operands</a>
					<a class="permalink" href="#MakeClosure.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeClosure">MakeClosure</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="MakeClosure.Pos">func (*MakeClosure) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#MakeClosure.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeClosure">MakeClosure</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="MakeClosure.Referrers">func (*MakeClosure) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#MakeClosure.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeClosure">MakeClosure</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="MakeClosure.String">func (*MakeClosure) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=5039:5076#L193">String</a>
					<a class="permalink" href="#MakeClosure.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeClosure">MakeClosure</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeClosure.Type">func (*MakeClosure) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#MakeClosure.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeClosure">MakeClosure</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="MakeInterface">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=29855:29903#L772">MakeInterface</a>
				<a class="permalink" href="#MakeInterface">&#xb6;</a>
				
				
			</h2>
			<p>MakeInterface constructs an instance of an interface type from a
value of a concrete type.
<p>Use Program.MethodSets.MethodSet(X.Type()) to find the method-set
of X, and Program.MethodValue(m) to find the implementation of a method.
<p>To construct the zero value of an interface type T, use:
<pre>NewConst(constant.MakeNil(), T, pos)
</pre>
<p>Pos() returns the ast.CallExpr.Lparen, if the instruction arose
from an explicit conversion in the source.
<p>Example printed form:
<pre>t1 = make interface{} &lt;- int (42:int)
t2 = make Stringer &lt;- t0
</pre>

			<pre>type MakeInterface struct {
<span id="MakeInterface.X"></span>    X <a href="#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="MakeInterface.Name">func (*MakeInterface) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#MakeInterface.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeInterface">MakeInterface</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeInterface.Operands">func (*MakeInterface) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=62929:62986#L1782">Operands</a>
					<a class="permalink" href="#MakeInterface.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeInterface">MakeInterface</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="MakeInterface.Pos">func (*MakeInterface) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#MakeInterface.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeInterface">MakeInterface</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="MakeInterface.Referrers">func (*MakeInterface) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#MakeInterface.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeInterface">MakeInterface</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="MakeInterface.String">func (*MakeInterface) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=4564:4603#L173">String</a>
					<a class="permalink" href="#MakeInterface.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeInterface">MakeInterface</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeInterface.Type">func (*MakeInterface) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#MakeInterface.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeInterface">MakeInterface</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="MakeMap">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=30866:30959#L807">MakeMap</a>
				<a class="permalink" href="#MakeMap">&#xb6;</a>
				
				
			</h2>
			<p>The MakeMap instruction creates a new hash-table-based map object
and yields a value of kind map.
<p>Type() returns a (possibly named) *types.Map.
<p>Pos() returns the ast.CallExpr.Lparen, if created by make(map), or
the ast.CompositeLit.Lbrack if created by a literal.
<p>Example printed form:
<pre>t1 = make map[string]int t0
t1 = make StringIntMap t0
</pre>

			<pre>type MakeMap struct {
<span id="MakeMap.Reserve"></span>    Reserve <a href="#Value">Value</a> <span class="comment">// initial space reservation; nil =&gt; default</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="MakeMap.Name">func (*MakeMap) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#MakeMap.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeMap">MakeMap</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeMap.Operands">func (*MakeMap) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=63020:63071#L1786">Operands</a>
					<a class="permalink" href="#MakeMap.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeMap">MakeMap</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="MakeMap.Pos">func (*MakeMap) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#MakeMap.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeMap">MakeMap</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="MakeMap.Referrers">func (*MakeMap) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#MakeMap.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeMap">MakeMap</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="MakeMap.String">func (*MakeMap) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=5920:5953#L237">String</a>
					<a class="permalink" href="#MakeMap.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeMap">MakeMap</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeMap.Type">func (*MakeMap) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#MakeMap.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeMap">MakeMap</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="MakeSlice">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=31888:31945#L846">MakeSlice</a>
				<a class="permalink" href="#MakeSlice">&#xb6;</a>
				
				
			</h2>
			<p>The MakeSlice instruction yields a slice of length Len backed by a
newly allocated array of length Cap.
<p>Both Len and Cap must be non-nil Values of integer type.
<p>(Alloc(types.Array) followed by Slice will not suffice because
Alloc can only create arrays of constant length.)
<p>Type() returns a (possibly named) *types.Slice.
<p>Pos() returns the ast.CallExpr.Lparen for the make([]T) that
created it.
<p>Example printed form:
<pre>t1 = make []string 1:int t0
t1 = make StringSlice 1:int t0
</pre>

			<pre>type MakeSlice struct {
<span id="MakeSlice.Len"></span>    Len <a href="#Value">Value</a>
<span id="MakeSlice.Cap"></span>    Cap <a href="#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="MakeSlice.Name">func (*MakeSlice) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#MakeSlice.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeSlice">MakeSlice</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeSlice.Operands">func (*MakeSlice) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=63111:63164#L1790">Operands</a>
					<a class="permalink" href="#MakeSlice.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeSlice">MakeSlice</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="MakeSlice.Pos">func (*MakeSlice) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#MakeSlice.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeSlice">MakeSlice</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="MakeSlice.Referrers">func (*MakeSlice) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#MakeSlice.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeSlice">MakeSlice</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="MakeSlice.String">func (*MakeSlice) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=5357:5392#L209">String</a>
					<a class="permalink" href="#MakeSlice.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeSlice">MakeSlice</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MakeSlice.Type">func (*MakeSlice) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#MakeSlice.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MakeSlice">MakeSlice</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="MapUpdate">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=45866:45962#L1312">MapUpdate</a>
				<a class="permalink" href="#MapUpdate">&#xb6;</a>
				
				
			</h2>
			<p>The MapUpdate instruction updates the association of Map[Key] to
Value.
<p>Pos() returns the ast.KeyValueExpr.Colon or ast.IndexExpr.Lbrack,
if explicit in the source.
<p>Example printed form:
<pre>t0[t1] = t2
</pre>

			<pre>type MapUpdate struct {
<span id="MapUpdate.Map"></span>    Map   <a href="#Value">Value</a>
<span id="MapUpdate.Key"></span>    Key   <a href="#Value">Value</a>
<span id="MapUpdate.Value"></span>    Value <a href="#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="MapUpdate.Block">func (*MapUpdate) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57835:57878#L1619">Block</a>
					<a class="permalink" href="#MapUpdate.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MapUpdate">MapUpdate</a>) Block() *<a href="#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="MapUpdate.Operands">func (*MapUpdate) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=63208:63261#L1794">Operands</a>
					<a class="permalink" href="#MapUpdate.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MapUpdate">MapUpdate</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="MapUpdate.Parent">func (*MapUpdate) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57757:57799#L1618">Parent</a>
					<a class="permalink" href="#MapUpdate.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MapUpdate">MapUpdate</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="MapUpdate.Pos">func (*MapUpdate) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60309:60344#L1674">Pos</a>
					<a class="permalink" href="#MapUpdate.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#MapUpdate">MapUpdate</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="MapUpdate.Referrers">func (*MapUpdate) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57978:58028#L1621">Referrers</a>
					<a class="permalink" href="#MapUpdate.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MapUpdate">MapUpdate</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="MapUpdate.String">func (*MapUpdate) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=9326:9361#L382">String</a>
					<a class="permalink" href="#MapUpdate.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#MapUpdate">MapUpdate</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Member">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=3358:3973#L69">Member</a>
				<a class="permalink" href="#Member">&#xb6;</a>
				
				
			</h2>
			<p>A Member is a member of a Go package, implemented by *NamedConst,
*Global, *Function, or *Type; they are created by package-level
const, var, func and type declarations respectively.

			<pre>type Member interface {
    Name() <a href="/pkg/builtin/#string">string</a>                    <span class="comment">// declared name of the package member</span>
    String() <a href="/pkg/builtin/#string">string</a>                  <span class="comment">// package-qualified name of the package member</span>
    RelString(*<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Package">Package</a>) <a href="/pkg/builtin/#string">string</a> <span class="comment">// like String, but relative refs are unqualified</span>
    Object() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Object">Object</a>            <span class="comment">// typechecker&#39;s object for this member, if any</span>
    Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>                  <span class="comment">// position of member&#39;s declaration, if known</span>
    Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a>                <span class="comment">// type of the package member</span>
    Token() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Token">Token</a>              <span class="comment">// token.{VAR,FUNC,CONST,TYPE}</span>
    Package() *<a href="#Package">Package</a>               <span class="comment">// the containing package</span>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="MultiConvert">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=27987:28077#L709">MultiConvert</a>
				<a class="permalink" href="#MultiConvert">&#xb6;</a>
				
				
			</h2>
			<p>The MultiConvert instruction yields the conversion of value X to type
Type(). Either X.Type() or Type() must be a type parameter. Each
type in the type set of X.Type() can be converted to each type in the
type set of Type().
<p>See the documentation for Convert, ChangeType, and SliceToArrayPointer
for the conversions that are permitted. Additionally conversions of
slices to arrays are permitted.
<p>This operation can fail dynamically (see SliceToArrayPointer).
<p>Pos() returns the ast.CallExpr.Lparen, if the instruction arose
from an explicit conversion in the source.
<p>Example printed form:
<pre>t1 = multiconvert D &lt;- S (t0) [*[2]rune &lt;- []rune | string &lt;- []rune]
</pre>

			<pre>type MultiConvert struct {
<span id="MultiConvert.X"></span>    X <a href="#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="MultiConvert.Name">func (*MultiConvert) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#MultiConvert.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MultiConvert">MultiConvert</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MultiConvert.Operands">func (*MultiConvert) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=61698:61754#L1726">Operands</a>
					<a class="permalink" href="#MultiConvert.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MultiConvert">MultiConvert</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="MultiConvert.Pos">func (*MultiConvert) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#MultiConvert.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MultiConvert">MultiConvert</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="MultiConvert.Referrers">func (*MultiConvert) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#MultiConvert.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MultiConvert">MultiConvert</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="MultiConvert.String">func (*MultiConvert) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=4648:4686#L175">String</a>
					<a class="permalink" href="#MultiConvert.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MultiConvert">MultiConvert</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="MultiConvert.Type">func (*MultiConvert) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#MultiConvert.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#MultiConvert">MultiConvert</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="NamedConst">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=4436:4515#L94">NamedConst</a>
				<a class="permalink" href="#NamedConst">&#xb6;</a>
				
				
			</h2>
			<p>A NamedConst is a Member of a Package representing a package-level
named constant.
<p>Pos() returns the position of the declaring ast.ValueSpec.Names[*]
identifier.
<p>NB: a NamedConst is not a Value; it contains a constant Value, which
it augments with the name and position of its &apos;const&apos; declaration.

			<pre>type NamedConst struct {
<span id="NamedConst.Value"></span>    Value *<a href="#Const">Const</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="NamedConst.Name">func (*NamedConst) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=58668:58702#L1632">Name</a>
					<a class="permalink" href="#NamedConst.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#NamedConst">NamedConst</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="NamedConst.Object">func (*NamedConst) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=59094:59136#L1637">Object</a>
					<a class="permalink" href="#NamedConst.Object">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#NamedConst">NamedConst</a>) Object() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Object">Object</a></pre>
				
				
				
				
			
				
				<h3 id="NamedConst.Package">func (*NamedConst) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=59173:59212#L1638">Package</a>
					<a class="permalink" href="#NamedConst.Package">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#NamedConst">NamedConst</a>) Package() *<a href="#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="NamedConst.Pos">func (*NamedConst) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=58754:58790#L1633">Pos</a>
					<a class="permalink" href="#NamedConst.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#NamedConst">NamedConst</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="NamedConst.RelString">func (*NamedConst) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=59249:59307#L1639">RelString</a>
					<a class="permalink" href="#NamedConst.RelString">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#NamedConst">NamedConst</a>) RelString(from *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Package">Package</a>) <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="NamedConst.String">func (*NamedConst) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=58839:58875#L1634">String</a>
					<a class="permalink" href="#NamedConst.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#NamedConst">NamedConst</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="NamedConst.Token">func (*NamedConst) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=59012:59052#L1636">Token</a>
					<a class="permalink" href="#NamedConst.Token">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#NamedConst">NamedConst</a>) Token() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Token">Token</a></pre>
				
				
				
				
			
				
				<h3 id="NamedConst.Type">func (*NamedConst) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=58926:58964#L1635">Type</a>
					<a class="permalink" href="#NamedConst.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (c *<a href="#NamedConst">NamedConst</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Next">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=38902:39014#L1065">Next</a>
				<a class="permalink" href="#Next">&#xb6;</a>
				
				
			</h2>
			<p>The Next instruction reads and advances the (map or string)
iterator Iter and returns a 3-tuple value (ok, k, v).  If the
iterator is not exhausted, ok is true and k and v are the next
elements of the domain and range, respectively.  Otherwise ok is
false and k and v are undefined.
<p>Components of the tuple are accessed using Extract.
<p>The IsString field distinguishes iterators over strings from those
over maps, as the Type() alone is insufficient: consider
map[int]rune.
<p>Type() returns a *types.Tuple for the triple (ok, k, v).
The types of k and/or v may be types.Invalid.
<p>Example printed form:
<pre>t1 = next t0
</pre>

			<pre>type Next struct {
<span id="Next.Iter"></span>    Iter     <a href="#Value">Value</a>
<span id="Next.IsString"></span>    IsString <a href="/pkg/builtin/#bool">bool</a> <span class="comment">// true =&gt; string iterator; false =&gt; map iterator.</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Next.Name">func (*Next) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#Next.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Next">Next</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Next.Operands">func (*Next) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=63315:63363#L1798">Operands</a>
					<a class="permalink" href="#Next.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Next">Next</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Next.Pos">func (*Next) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#Next.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Next">Next</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Next.Referrers">func (*Next) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#Next.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Next">Next</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Next.String">func (*Next) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=7167:7197#L285">String</a>
					<a class="permalink" href="#Next.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Next">Next</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Next.Type">func (*Next) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#Next.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Next">Next</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Node">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=10167:10406#L245">Node</a>
				<a class="permalink" href="#Node">&#xb6;</a>
				
				
			</h2>
			<p>A Node is a node in the SSA value graph.  Every concrete type that
implements Node is also either a Value, an Instruction, or both.
<p>Node contains the methods common to Value and Instruction, plus the
Operands and Referrers methods generalized to return nil for
non-Instructions and non-Values, respectively.
<p>Node is provided to simplify SSA graph algorithms.  Clients should
use the more specific and informative Value or Instruction
interfaces where appropriate.

			<pre>type Node interface {
    <span class="comment">// Common methods:</span>
    String() <a href="/pkg/builtin/#string">string</a>
    Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>
    Parent() *<a href="#Function">Function</a>

    <span class="comment">// Partial methods:</span>
    Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a> <span class="comment">// nil for non-Instructions</span>
    Referrers() *[]<a href="#Instruction">Instruction</a>        <span class="comment">// nil for non-Values</span>
}</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Package">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=2008:3164#L47">Package</a>
				<a class="permalink" href="#Package">&#xb6;</a>
				
				
			</h2>
			<p>A Package is a single analyzed Go package containing Members for
all package-level functions, variables, constants and types it
declares.  These may be accessed directly via Members, or via the
type-specific accessor methods Func, Type, Var and Const.
<p>Members also contains entries for &quot;init&quot; (the synthetic package
initializer) and &quot;init#%d&quot;, the nth declared init function,
and unspecified other things too.

			<pre>type Package struct {
<span id="Package.Prog"></span>    Prog    *<a href="#Program">Program</a>          <span class="comment">// the owning program</span>
<span id="Package.Pkg"></span>    Pkg     *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Package">Package</a>    <span class="comment">// the corresponding go/types.Package</span>
<span id="Package.Members"></span>    Members map[<a href="/pkg/builtin/#string">string</a>]<a href="#Member">Member</a> <span class="comment">// all package members keyed by name (incl. init and init#%d)</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Package.Build">func (*Package) <a href="/src/golang.org/x/tools/go/ssa/builder.go?s=90608:90633#L3147">Build</a>
					<a class="permalink" href="#Package.Build">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Package">Package</a>) Build()</pre>
				<p>Build builds SSA code for all functions and vars in package p.
<p>CreatePackage must have been called for all of p&apos;s direct imports
(and hence its direct imports must have been error-free). It is not
necessary to call CreatePackage for indirect dependencies.
Functions will be created for all necessary methods in those
packages on demand.
<p>Build is idempotent and thread-safe.

				
				
				
			
				
				<h3 id="Package.Const">func (*Package) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=59864:59916#L1659">Const</a>
					<a class="permalink" href="#Package.Const">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Package">Package</a>) Const(name <a href="/pkg/builtin/#string">string</a>) (c *<a href="#NamedConst">NamedConst</a>)</pre>
				<p>Const returns the package-level constant of the specified name,
or nil if not found.

				
				
				
			
				
				<h3 id="Package.Func">func (*Package) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=59491:59540#L1645">Func</a>
					<a class="permalink" href="#Package.Func">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Package">Package</a>) Func(name <a href="/pkg/builtin/#string">string</a>) (f *<a href="#Function">Function</a>)</pre>
				<p>Func returns the package-level function of the specified name,
or nil if not found.

				
				
				
			
				
				<h3 id="Package.SetDebugMode">func (*Package) <a href="/src/golang.org/x/tools/go/ssa/func.go?s=11649:11693#L419">SetDebugMode</a>
					<a class="permalink" href="#Package.SetDebugMode">&#xb6;</a>
					
					
				</h3>
				<pre>func (pkg *<a href="#Package">Package</a>) SetDebugMode(debug <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>SetDebugMode sets the debug mode for package pkg.  If true, all its
functions will include full debug info.  This greatly increases the
size of the instruction stream, and causes Functions to depend upon
the ASTs, potentially keeping them live in memory for longer.

				
				
				
			
				
				<h3 id="Package.String">func (*Package) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=9845:9878#L401">String</a>
					<a class="permalink" href="#Package.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Package">Package</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Package.Type">func (*Package) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60054:60099#L1666">Type</a>
					<a class="permalink" href="#Package.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Package">Package</a>) Type(name <a href="/pkg/builtin/#string">string</a>) (t *<a href="#Type">Type</a>)</pre>
				<p>Type returns the package-level type of the specified name,
or nil if not found.

				
				
				
			
				
				<h3 id="Package.Var">func (*Package) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=59679:59725#L1652">Var</a>
					<a class="permalink" href="#Package.Var">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Package">Package</a>) Var(name <a href="/pkg/builtin/#string">string</a>) (g *<a href="#Global">Global</a>)</pre>
				<p>Var returns the package-level variable of the specified name,
or nil if not found.

				
				
				
			
				
				<h3 id="Package.WriteTo">func (*Package) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=9988:10041#L407">WriteTo</a>
					<a class="permalink" href="#Package.WriteTo">&#xb6;</a>
					
					
				</h3>
				<pre>func (p *<a href="#Package">Package</a>) WriteTo(w <a href="/pkg/io/">io</a>.<a href="/pkg/io/#Writer">Writer</a>) (<a href="/pkg/builtin/#int64">int64</a>, <a href="/pkg/builtin/#error">error</a>)</pre>
				
				
				
				
			
		
			
			
			<h2 id="Panic">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=43616:43696#L1223">Panic</a>
				<a class="permalink" href="#Panic">&#xb6;</a>
				
				
			</h2>
			<p>The Panic instruction initiates a panic with value X.
<p>A Panic instruction must be the last instruction of its containing
BasicBlock, which must have no successors.
<p>NB: &apos;go panic(x)&apos; and &apos;defer panic(x)&apos; do not use this instruction;
they are treated as calls to a built-in function.
<p>Pos() returns the ast.CallExpr.Lparen if this panic was explicit
in the source.
<p>Example printed form:
<pre>panic t0
</pre>

			<pre>type Panic struct {
<span id="Panic.X"></span>    X <a href="#Value">Value</a> <span class="comment">// an interface{}</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Panic.Block">func (*Panic) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57835:57878#L1619">Block</a>
					<a class="permalink" href="#Panic.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Panic">Panic</a>) Block() *<a href="#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="Panic.Operands">func (*Panic) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=63400:63449#L1802">Operands</a>
					<a class="permalink" href="#Panic.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Panic">Panic</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Panic.Parent">func (*Panic) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57757:57799#L1618">Parent</a>
					<a class="permalink" href="#Panic.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Panic">Panic</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Panic.Pos">func (*Panic) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60362:60393#L1675">Pos</a>
					<a class="permalink" href="#Panic.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Panic">Panic</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Panic.Referrers">func (*Panic) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57978:58028#L1621">Referrers</a>
					<a class="permalink" href="#Panic.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Panic">Panic</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Panic.String">func (*Panic) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=8106:8137#L321">String</a>
					<a class="permalink" href="#Panic.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Panic">Panic</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Parameter">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=19367:19511#L435">Parameter</a>
				<a class="permalink" href="#Parameter">&#xb6;</a>
				
				
			</h2>
			<p>A Parameter represents an input parameter of a function.

			<pre>type Parameter struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Parameter.Name">func (*Parameter) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=56759:56792#L1600">Name</a>
					<a class="permalink" href="#Parameter.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Parameter">Parameter</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Parameter.Object">func (*Parameter) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=56824:56865#L1601">Object</a>
					<a class="permalink" href="#Parameter.Object">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Parameter">Parameter</a>) Object() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Object">Object</a></pre>
				
				
				
				
			
				
				<h3 id="Parameter.Operands">func (*Parameter) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=64917:64970#L1861">Operands</a>
					<a class="permalink" href="#Parameter.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Parameter">Parameter</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Parameter.Parent">func (*Parameter) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57035:57073#L1604">Parent</a>
					<a class="permalink" href="#Parameter.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Parameter">Parameter</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Parameter.Pos">func (*Parameter) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=56962:56997#L1603">Pos</a>
					<a class="permalink" href="#Parameter.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Parameter">Parameter</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Parameter.Referrers">func (*Parameter) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=56891:56937#L1602">Referrers</a>
					<a class="permalink" href="#Parameter.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Parameter">Parameter</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Parameter.String">func (*Parameter) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=1916:1951#L66">String</a>
					<a class="permalink" href="#Parameter.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Parameter">Parameter</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Parameter.Type">func (*Parameter) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=56695:56732#L1599">Type</a>
					<a class="permalink" href="#Parameter.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Parameter">Parameter</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Phi">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=23110:23243#L555">Phi</a>
				<a class="permalink" href="#Phi">&#xb6;</a>
				
				
			</h2>
			<p>The Phi instruction represents an SSA φ-node, which combines values
that differ across incoming control-flow edges and yields a new
value.  Within a block, all φ-nodes must appear before all non-φ
nodes.
<p>Pos() returns the position of the &amp;&amp; or || for short-circuit
control-flow joins, or that of the *Alloc for φ-nodes inserted
during SSA renaming.
<p>Example printed form:
<pre>t2 = phi [0: t0, 1: t1]
</pre>

			<pre>type Phi struct {
<span id="Phi.Comment"></span>    Comment <a href="/pkg/builtin/#string">string</a>  <span class="comment">// a hint as to its purpose</span>
<span id="Phi.Edges"></span>    Edges   []<a href="#Value">Value</a> <span class="comment">// Edges[i] is value for Block().Preds[i]</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Phi.Name">func (*Phi) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#Phi.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Phi">Phi</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Phi.Operands">func (*Phi) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=63483:63530#L1806">Operands</a>
					<a class="permalink" href="#Phi.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Phi">Phi</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Phi.Pos">func (*Phi) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#Phi.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Phi">Phi</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Phi.Referrers">func (*Phi) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#Phi.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Phi">Phi</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Phi.String">func (*Phi) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=2518:2547#L91">String</a>
					<a class="permalink" href="#Phi.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Phi">Phi</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Phi.Type">func (*Phi) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#Phi.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Phi">Phi</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Program">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=532:1572#L13">Program</a>
				<a class="permalink" href="#Program">&#xb6;</a>
				
				
			</h2>
			<p>A Program is a partial or complete Go program converted to SSA form.

			<pre>type Program struct {
<span id="Program.Fset"></span>    Fset *<a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#FileSet">FileSet</a> <span class="comment">// position information for the files of this Program</span>

<span id="Program.MethodSets"></span>    MethodSets <a href="/pkg/golang.org/x/tools/go/types/typeutil/">typeutil</a>.<a href="/pkg/golang.org/x/tools/go/types/typeutil/#MethodSetCache">MethodSetCache</a> <span class="comment">// cache of type-checker&#39;s method-sets</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewProgram">func <a href="/src/golang.org/x/tools/go/ssa/create.go?s=932:995#L25">NewProgram</a>
					<a class="permalink" href="#NewProgram">&#xb6;</a>
					
					
				</h3>
				<pre>func NewProgram(fset *<a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#FileSet">FileSet</a>, mode <a href="#BuilderMode">BuilderMode</a>) *<a href="#Program">Program</a></pre>
				<p>NewProgram returns a new SSA Program.
<p>mode controls diagnostics and checking during SSA construction.
<p>To construct an SSA program:
<ul>
<li>Call NewProgram to create an empty Program.
<li>Call CreatePackage providing typed syntax for each package
you want to build, and call it with types but not
syntax for each of those package&apos;s direct dependencies.
<li>Call <a href="#Package.Build">Package.Build</a> on each syntax package you wish to build,
or <a href="#Program.Build">Program.Build</a> to build all of them.
</ul>
<p>See the Example tests for simple examples.

				
				
			

			
				
				<h3 id="Program.AllPackages">func (*Program) <a href="/src/golang.org/x/tools/go/ssa/create.go?s=7917:7962#L281">AllPackages</a>
					<a class="permalink" href="#Program.AllPackages">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="#Program">Program</a>) AllPackages() []*<a href="#Package">Package</a></pre>
				<p>AllPackages returns a new slice containing all packages created by
prog.CreatePackage in unspecified order.

				
				
				
			
				
				<h3 id="Program.Build">func (*Program) <a href="/src/golang.org/x/tools/go/ssa/builder.go?s=89771:89799#L3117">Build</a>
					<a class="permalink" href="#Program.Build">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="#Program">Program</a>) Build()</pre>
				<p>Build calls Package.Build for each package in prog.
Building occurs in parallel unless the BuildSerially mode flag was set.
<p>Build is intended for whole-program analysis; a typical compiler
need only build a single package.
<p>Build is idempotent and thread-safe.

				
				
				
			
				
				<h3 id="Program.ConstValue">func (*Program) <a href="/src/golang.org/x/tools/go/ssa/source.go?s=6548:6604#L193">ConstValue</a>
					<a class="permalink" href="#Program.ConstValue">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="#Program">Program</a>) ConstValue(obj *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Const">Const</a>) *<a href="#Const">Const</a></pre>
				<p>ConstValue returns the SSA constant denoted by the specified const symbol.

				
				
				
			
				
				<h3 id="Program.CreatePackage">func (*Program) <a href="/src/golang.org/x/tools/go/ssa/create.go?s=5500:5617#L189">CreatePackage</a>
					<a class="permalink" href="#Program.CreatePackage">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="#Program">Program</a>) CreatePackage(pkg *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Package">Package</a>, files []*<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#File">File</a>, info *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Info">Info</a>, importable <a href="/pkg/builtin/#bool">bool</a>) *<a href="#Package">Package</a></pre>
				<p>CreatePackage creates and returns an SSA Package from the
specified type-checked, error-free file ASTs, and populates its
Members mapping.
<p>importable determines whether this package should be returned by a
subsequent call to ImportedPackage(pkg.Path()).
<p>The real work of building SSA form for each function is not done
until a subsequent call to Package.Build.
<p>CreatePackage should not be called after building any package in
the program.

				
				
				
			
				
				<h3 id="Program.FuncValue">func (*Program) <a href="/src/golang.org/x/tools/go/ssa/source.go?s=6345:6402#L187">FuncValue</a>
					<a class="permalink" href="#Program.FuncValue">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="#Program">Program</a>) FuncValue(obj *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Func">Func</a>) *<a href="#Function">Function</a></pre>
				<p>FuncValue returns the SSA function or (non-interface) method
denoted by the specified func symbol. It returns nil id the symbol
denotes an interface method, or belongs to a package that was not
created by prog.CreatePackage.

				
				
				
			
				
				<h3 id="Program.ImportedPackage">func (*Program) <a href="/src/golang.org/x/tools/go/ssa/create.go?s=8983:9041#L306">ImportedPackage</a>
					<a class="permalink" href="#Program.ImportedPackage">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="#Program">Program</a>) ImportedPackage(path <a href="/pkg/builtin/#string">string</a>) *<a href="#Package">Package</a></pre>
				<p>ImportedPackage returns the importable Package whose PkgPath
is path, or nil if no such Package has been created.
<p>A parameter to CreatePackage determines whether a package should be
considered importable. For example, no import declaration can resolve
to the ad-hoc main package created by &apos;go build foo.go&apos;.
<p>TODO(adonovan): rethink this function and the &quot;importable&quot; concept;
most packages are importable. This function assumes that all
types.Package.Path values are unique within the ssa.Program, which is
false---yet this function remains very convenient.
Clients should use (*Program).Package instead where possible.
SSA doesn&apos;t really need a string-keyed map of packages.
<p>Furthermore, the graph of packages may contain multiple variants
(e.g. &quot;p&quot; vs &quot;p as compiled for q.test&quot;), and each has a different
view of its dependencies.

				
				
				
			
				
				<h3 id="Program.LookupMethod">func (*Program) <a href="/src/golang.org/x/tools/go/ssa/methods.go?s=3484:3574#L126">LookupMethod</a>
					<a class="permalink" href="#Program.LookupMethod">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="#Program">Program</a>) LookupMethod(T <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a>, pkg *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Package">Package</a>, name <a href="/pkg/builtin/#string">string</a>) *<a href="#Function">Function</a></pre>
				<p>LookupMethod returns the implementation of the method of type T
identified by (pkg, name).  It returns nil if the method exists but
is an interface method or generic method, and panics if T has no such method.

				
				
				
			
				
				<h3 id="Program.MethodValue">func (*Program) <a href="/src/golang.org/x/tools/go/ssa/methods.go?s=607:671#L16">MethodValue</a>
					<a class="permalink" href="#Program.MethodValue">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="#Program">Program</a>) MethodValue(sel *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Selection">Selection</a>) *<a href="#Function">Function</a></pre>
				<p>MethodValue returns the Function implementing method sel, building
wrapper methods on demand. It returns nil if sel denotes an
interface or generic method.
<p>Precondition: sel.Kind() == MethodVal.
<p>Thread-safe.
<p>Acquires prog.methodsMu.

				
				
				
			
				
				<h3 id="Program.NewFunction">func (*Program) <a href="/src/golang.org/x/tools/go/ssa/func.go?s=20824:20920#L719">NewFunction</a>
					<a class="permalink" href="#Program.NewFunction">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="#Program">Program</a>) NewFunction(name <a href="/pkg/builtin/#string">string</a>, sig *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Signature">Signature</a>, provenance <a href="/pkg/builtin/#string">string</a>) *<a href="#Function">Function</a></pre>
				<p>NewFunction returns a new synthetic Function instance belonging to
prog, with its name and signature fields set as specified.
<p>The caller is responsible for initializing the remaining fields of
the function object, e.g. Pkg, Params, Blocks.
<p>It is practically impossible for clients to construct well-formed
SSA functions/packages/programs directly, so we assume this is the
job of the Builder alone.  NewFunction exists to provide clients a
little flexibility.  For example, analysis tools may wish to
construct fake Functions for the root of the callgraph, a fake
&quot;reflect&quot; package, etc.
<p>TODO(adonovan): think harder about the API here.

				
				
				
			
				
				<h3 id="Program.Package">func (*Program) <a href="/src/golang.org/x/tools/go/ssa/source.go?s=5534:5591#L165">Package</a>
					<a class="permalink" href="#Program.Package">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="#Program">Program</a>) Package(pkg *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Package">Package</a>) *<a href="#Package">Package</a></pre>
				<p>Package returns the SSA Package corresponding to the specified
type-checker package. It returns nil if no such Package was
created by a prior call to prog.CreatePackage.

				
				
				
			
				
				<h3 id="Program.RuntimeTypes">func (*Program) <a href="/src/golang.org/x/tools/go/ssa/methods.go?s=4441:4489#L152">RuntimeTypes</a>
					<a class="permalink" href="#Program.RuntimeTypes">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="#Program">Program</a>) RuntimeTypes() []<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				<p>RuntimeTypes returns a new unordered slice containing all types in
the program for which a runtime type is required.
<p>A runtime type is required for any non-parameterized, non-interface
type that is converted to an interface, or for any type (including
interface types) derivable from one through reflection.
<p>The methods of such types may be reachable through reflection or
interface calls even if they are never called directly.
<p>Thread-safe.
<p>Acquires prog.runtimeTypesMu.

				
				
				
			
				
				<h3 id="Program.VarValue">func (*Program) <a href="/src/golang.org/x/tools/go/ssa/source.go?s=8597:8699#L243">VarValue</a>
					<a class="permalink" href="#Program.VarValue">&#xb6;</a>
					
					
				</h3>
				<pre>func (prog *<a href="#Program">Program</a>) VarValue(obj *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Var">Var</a>, pkg *<a href="#Package">Package</a>, ref []<a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Node">Node</a>) (value <a href="#Value">Value</a>, isAddr <a href="/pkg/builtin/#bool">bool</a>)</pre>
				<p>VarValue returns the SSA Value that corresponds to a specific
identifier denoting the specified var symbol.
<p>VarValue returns nil if a local variable was not found, perhaps
because its package was not built, the debug information was not
requested during SSA construction, or the value was optimized away.
<p>ref is the path to an ast.Ident (e.g. from PathEnclosingInterval),
and that ident must resolve to obj.
<p>pkg is the package enclosing the reference.  (A reference to a var
always occurs within a function, so we need to know where to find it.)
<p>If the identifier is a field selector and its base expression is
non-addressable, then VarValue returns the value of that field.
For example:
<pre>func f() struct {x int}
f().x  // VarValue(x) returns a *Field instruction of type int
</pre>
<p>All other identifiers denote addressable locations (variables).
For them, VarValue may return either the variable&apos;s address or its
value, even when the expression is evaluated only for its value; the
situation is reported by isAddr, the second component of the result.
<p>If !isAddr, the returned value is the one associated with the
specific identifier.  For example,
<pre>var x int    // VarValue(x) returns Const 0 here
x = 1        // VarValue(x) returns Const 1 here
</pre>
<p>It is not specified whether the value or the address is returned in
any particular case, as it may depend upon optimizations performed
during SSA code generation, such as registerization, constant
folding, avoidance of materialization of subexpressions, etc.

				
				
				
			
		
			
			
			<h2 id="Range">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=38178:38235#L1042">Range</a>
				<a class="permalink" href="#Range">&#xb6;</a>
				
				
			</h2>
			<p>The Range instruction yields an iterator over the domain and range
of X, which must be a string or map.
<p>Elements are accessed via Next.
<p>Type() returns an opaque and degenerate &quot;rangeIter&quot; type.
<p>Pos() returns the ast.RangeStmt.For.
<p>Example printed form:
<pre>t0 = range &quot;hello&quot;:string
</pre>

			<pre>type Range struct {
<span id="Range.X"></span>    X <a href="#Value">Value</a> <span class="comment">// string or map</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Range.Name">func (*Range) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#Range.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Range">Range</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Range.Operands">func (*Range) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=63616:63665#L1813">Operands</a>
					<a class="permalink" href="#Range.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Range">Range</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Range.Pos">func (*Range) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#Range.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Range">Range</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Range.Referrers">func (*Range) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#Range.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Range">Range</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Range.String">func (*Range) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=7095:7126#L281">String</a>
					<a class="permalink" href="#Range.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Range">Range</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Range.Type">func (*Range) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#Range.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Range">Range</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Return">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=42679:42752#L1187">Return</a>
				<a class="permalink" href="#Return">&#xb6;</a>
				
				
			</h2>
			<p>The Return instruction returns values and control back to the calling
function.
<p>len(Results) is always equal to the number of results in the
function&apos;s signature.
<p>If len(Results) &gt; 1, Return returns a tuple value with the specified
components which the caller must access using Extract instructions.
<p>There is no instruction to return a ready-made tuple like those
returned by a &quot;value,ok&quot;-mode TypeAssert, Lookup or UnOp(ARROW) or
a tail-call to a function with multiple result parameters.
<p>Return must be the last instruction of its containing BasicBlock.
Such a block has no successors.
<p>Pos() returns the ast.ReturnStmt.Return, if explicit in the source.
<p>Example printed form:
<pre>return
return nil:I, 2:int
</pre>

			<pre>type Return struct {
<span id="Return.Results"></span>    Results []<a href="#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Return.Block">func (*Return) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57835:57878#L1619">Block</a>
					<a class="permalink" href="#Return.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Return">Return</a>) Block() *<a href="#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="Return.Operands">func (*Return) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=63699:63749#L1817">Operands</a>
					<a class="permalink" href="#Return.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Return">Return</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Return.Parent">func (*Return) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57757:57799#L1618">Parent</a>
					<a class="permalink" href="#Return.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Return">Return</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Return.Pos">func (*Return) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60415:60447#L1676">Pos</a>
					<a class="permalink" href="#Return.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Return">Return</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Return.Referrers">func (*Return) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57978:58028#L1621">Referrers</a>
					<a class="permalink" href="#Return.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Return">Return</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Return.String">func (*Return) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=8178:8210#L325">String</a>
					<a class="permalink" href="#Return.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Return">Return</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="RunDefers">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=43139:43179#L1205">RunDefers</a>
				<a class="permalink" href="#RunDefers">&#xb6;</a>
				
				
			</h2>
			<p>The RunDefers instruction pops and invokes the entire stack of
procedure calls pushed by Defer instructions in this function.
<p>It is legal to encounter multiple &apos;rundefers&apos; instructions in a
single control-flow path through a function; this is useful in
the combined init() function, for example.
<p>Pos() returns NoPos.
<p>Example printed form:
<pre>rundefers
</pre>

			<pre>type RunDefers struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="RunDefers.Block">func (*RunDefers) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57835:57878#L1619">Block</a>
					<a class="permalink" href="#RunDefers.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#RunDefers">RunDefers</a>) Block() *<a href="#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="RunDefers.Operands">func (*RunDefers) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=63839:63890#L1824">Operands</a>
					<a class="permalink" href="#RunDefers.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (*<a href="#RunDefers">RunDefers</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="RunDefers.Parent">func (*RunDefers) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57757:57799#L1618">Parent</a>
					<a class="permalink" href="#RunDefers.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#RunDefers">RunDefers</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="RunDefers.Pos">func (*RunDefers) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60692:60727#L1681">Pos</a>
					<a class="permalink" href="#RunDefers.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#RunDefers">RunDefers</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="RunDefers.Referrers">func (*RunDefers) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57978:58028#L1621">Referrers</a>
					<a class="permalink" href="#RunDefers.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#RunDefers">RunDefers</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="RunDefers.String">func (*RunDefers) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=8419:8452#L339">String</a>
					<a class="permalink" href="#RunDefers.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (*<a href="#RunDefers">RunDefers</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Select">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=37789:37861#L1024">Select</a>
				<a class="permalink" href="#Select">&#xb6;</a>
				
				
			</h2>
			<p>The Select instruction tests whether (or blocks until) one
of the specified sent or received states is entered.
<p>Let n be the number of States for which Dir==RECV and T_i (0&lt;=i&lt;n)
be the element type of each such state&apos;s Chan.
Select returns an n+2-tuple
<pre>(index int, recvOk bool, r_0 T_0, ... r_n-1 T_n-1)
</pre>
<p>The tuple&apos;s components, described below, must be accessed via the
Extract instruction.
<p>If Blocking, select waits until exactly one state holds, i.e. a
channel becomes ready for the designated operation of sending or
receiving; select chooses one among the ready states
pseudorandomly, performs the send or receive operation, and sets
&apos;index&apos; to the index of the chosen channel.
<p>If !Blocking, select doesn&apos;t block if no states hold; instead it
returns immediately with index equal to -1.
<p>If the chosen channel was used for a receive, the r_i component is
set to the received value, where i is the index of that state among
all n receive states; otherwise r_i has the zero value of type T_i.
Note that the receive index i is not the same as the state
index index.
<p>The second component of the triple, recvOk, is a boolean whose value
is true iff the selected operation was a receive and the receive
successfully yielded a value.
<p>Pos() returns the ast.SelectStmt.Select.
<p>Example printed form:
<pre>t3 = select nonblocking [&lt;-t0, t1&lt;-t2]
t4 = select blocking []
</pre>

			<pre>type Select struct {
<span id="Select.States"></span>    States   []*<a href="#SelectState">SelectState</a>
<span id="Select.Blocking"></span>    Blocking <a href="/pkg/builtin/#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Select.Name">func (*Select) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#Select.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Select">Select</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Select.Operands">func (*Select) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=63910:63960#L1828">Operands</a>
					<a class="permalink" href="#Select.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Select">Select</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Select.Pos">func (*Select) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#Select.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Select">Select</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Select.Referrers">func (*Select) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#Select.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Select">Select</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Select.String">func (*Select) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=8770:8802#L356">String</a>
					<a class="permalink" href="#Select.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Select">Select</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Select.Type">func (*Select) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#Select.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Select">Select</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="SelectState">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=35978:36319#L979">SelectState</a>
				<a class="permalink" href="#SelectState">&#xb6;</a>
				
				
			</h2>
			<p>SelectState is a helper for Select.
It represents one goal state and its corresponding communication.

			<pre>type SelectState struct {
<span id="SelectState.Dir"></span>    Dir       <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#ChanDir">ChanDir</a> <span class="comment">// direction of case (SendOnly or RecvOnly)</span>
<span id="SelectState.Chan"></span>    Chan      <a href="#Value">Value</a>         <span class="comment">// channel to use (for send or receive)</span>
<span id="SelectState.Send"></span>    Send      <a href="#Value">Value</a>         <span class="comment">// value to send (for send)</span>
<span id="SelectState.Pos"></span>    Pos       <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>     <span class="comment">// position of token.ARROW</span>
<span id="SelectState.DebugNode"></span>    DebugNode <a href="/pkg/go/ast/">ast</a>.<a href="/pkg/go/ast/#Node">Node</a>      <span class="comment">// ast.SendStmt or ast.UnaryExpr(&lt;-) [debug mode]</span>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Send">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=45107:45176#L1279">Send</a>
				<a class="permalink" href="#Send">&#xb6;</a>
				
				
			</h2>
			<p>The Send instruction sends X on channel Chan.
<p>Pos() returns the ast.SendStmt.Arrow, if explicit in the source.
<p>Example printed form:
<pre>send t0 &lt;- t1
</pre>

			<pre>type Send struct {
<span id="Send.Chan"></span>    Chan, X <a href="#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Send.Block">func (*Send) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57835:57878#L1619">Block</a>
					<a class="permalink" href="#Send.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Send">Send</a>) Block() *<a href="#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="Send.Operands">func (*Send) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=64072:64120#L1835">Operands</a>
					<a class="permalink" href="#Send.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Send">Send</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Send.Parent">func (*Send) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57757:57799#L1618">Parent</a>
					<a class="permalink" href="#Send.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Send">Send</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Send.Pos">func (*Send) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60468:60498#L1677">Pos</a>
					<a class="permalink" href="#Send.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Send">Send</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Send.Referrers">func (*Send) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57978:58028#L1621">Referrers</a>
					<a class="permalink" href="#Send.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Send">Send</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Send.String">func (*Send) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=8478:8508#L343">String</a>
					<a class="permalink" href="#Send.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Send">Send</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Slice">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=32548:32670#L868">Slice</a>
				<a class="permalink" href="#Slice">&#xb6;</a>
				
				
			</h2>
			<p>The Slice instruction yields a slice of an existing string, slice
or *array X between optional integer bounds Low and High.
<p>Dynamically, this instruction panics if X evaluates to a nil *array
pointer.
<p>Type() returns string if the type of X was string, otherwise a
*types.Slice with the same element type as X.
<p>Pos() returns the ast.SliceExpr.Lbrack if created by a x[:] slice
operation, the ast.CompositeLit.Lbrace if created by a literal, or
NoPos if not explicit in the source (e.g. a variadic argument slice).
<p>Example printed form:
<pre>t1 = slice t0[1:]
</pre>

			<pre>type Slice struct {
<span id="Slice.X"></span>    X              <a href="#Value">Value</a> <span class="comment">// slice, string, or *array</span>
<span id="Slice.Low"></span>    Low, High, Max <a href="#Value">Value</a> <span class="comment">// each may be nil</span>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Slice.Name">func (*Slice) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#Slice.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Slice">Slice</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Slice.Operands">func (*Slice) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=64163:64212#L1839">Operands</a>
					<a class="permalink" href="#Slice.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Slice">Slice</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Slice.Pos">func (*Slice) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#Slice.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Slice">Slice</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Slice.Referrers">func (*Slice) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#Slice.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Slice">Slice</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Slice.String">func (*Slice) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=5533:5564#L217">String</a>
					<a class="permalink" href="#Slice.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Slice">Slice</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Slice.Type">func (*Slice) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#Slice.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Slice">Slice</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="SliceToArrayPointer">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=29232:29286#L750">SliceToArrayPointer</a>
				<a class="permalink" href="#SliceToArrayPointer">&#xb6;</a>
				
				
			</h2>
			<p>The SliceToArrayPointer instruction yields the conversion of slice X to
array pointer.
<p>Pos() returns the ast.CallExpr.Lparen, if the instruction arose
from an explicit conversion in the source.
<p>Conversion may to be to or from a type parameter. All types in
the type set of X.Type() must be a slice types that can be converted to
all types in the type set of Type() which must all be pointer to array
types.
<p>This operation can fail dynamically if the length of the slice is less
than the length of the array.
<p>Example printed form:
<pre>t1 = slice to array pointer *[4]byte &lt;- []byte (t0)
</pre>

			<pre>type SliceToArrayPointer struct {
<span id="SliceToArrayPointer.X"></span>    X <a href="#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="SliceToArrayPointer.Name">func (*SliceToArrayPointer) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#SliceToArrayPointer.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#SliceToArrayPointer">SliceToArrayPointer</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="SliceToArrayPointer.Operands">func (*SliceToArrayPointer) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=61788:61851#L1730">Operands</a>
					<a class="permalink" href="#SliceToArrayPointer.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#SliceToArrayPointer">SliceToArrayPointer</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="SliceToArrayPointer.Pos">func (*SliceToArrayPointer) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#SliceToArrayPointer.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#SliceToArrayPointer">SliceToArrayPointer</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="SliceToArrayPointer.Referrers">func (*SliceToArrayPointer) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#SliceToArrayPointer.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#SliceToArrayPointer">SliceToArrayPointer</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="SliceToArrayPointer.String">func (*SliceToArrayPointer) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=4463:4508#L172">String</a>
					<a class="permalink" href="#SliceToArrayPointer.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#SliceToArrayPointer">SliceToArrayPointer</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="SliceToArrayPointer.Type">func (*SliceToArrayPointer) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#SliceToArrayPointer.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#SliceToArrayPointer">SliceToArrayPointer</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Store">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=45562:45638#L1296">Store</a>
				<a class="permalink" href="#Store">&#xb6;</a>
				
				
			</h2>
			<p>The Store instruction stores Val at address Addr.
Stores can be of arbitrary types.
<p>Pos() returns the position of the source-level construct most closely
associated with the memory store operation.
Since implicit memory stores are numerous and varied and depend upon
implementation choices, the details are not specified.
<p>Example printed form:
<pre>*x = y
</pre>

			<pre>type Store struct {
<span id="Store.Addr"></span>    Addr <a href="#Value">Value</a>
<span id="Store.Val"></span>    Val  <a href="#Value">Value</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Store.Block">func (*Store) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57835:57878#L1619">Block</a>
					<a class="permalink" href="#Store.Block">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Store">Store</a>) Block() *<a href="#BasicBlock">BasicBlock</a></pre>
				
				
				
				
			
				
				<h3 id="Store.Operands">func (*Store) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=64271:64320#L1843">Operands</a>
					<a class="permalink" href="#Store.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Store">Store</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="Store.Parent">func (*Store) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57757:57799#L1618">Parent</a>
					<a class="permalink" href="#Store.Parent">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Store">Store</a>) Parent() *<a href="#Function">Function</a></pre>
				
				
				
				
			
				
				<h3 id="Store.Pos">func (*Store) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=60521:60552#L1678">Pos</a>
					<a class="permalink" href="#Store.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Store">Store</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Store.Referrers">func (*Store) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57978:58028#L1621">Referrers</a>
					<a class="permalink" href="#Store.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#Store">Store</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="Store.String">func (*Store) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=9218:9249#L378">String</a>
					<a class="permalink" href="#Store.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (s *<a href="#Store">Store</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Type">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=4051:4112#L81">Type</a>
				<a class="permalink" href="#Type">&#xb6;</a>
				
				
			</h2>
			<p>A Type is a Member of a Package representing a package-level named type.

			<pre>type Type struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="Type.Name">func (*Type) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=58046:58074#L1623">Name</a>
					<a class="permalink" href="#Type.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="#Type">Type</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Type.Object">func (*Type) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=58360:58396#L1627">Object</a>
					<a class="permalink" href="#Type.Object">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="#Type">Type</a>) Object() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Object">Object</a></pre>
				
				
				
				
			
				
				<h3 id="Type.Package">func (*Type) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=58514:58547#L1629">Package</a>
					<a class="permalink" href="#Type.Package">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="#Type">Type</a>) Package() *<a href="#Package">Package</a></pre>
				
				
				
				
			
				
				<h3 id="Type.Pos">func (*Type) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=58126:58156#L1624">Pos</a>
					<a class="permalink" href="#Type.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="#Type">Type</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="Type.RelString">func (*Type) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=58584:58636#L1630">RelString</a>
					<a class="permalink" href="#Type.RelString">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="#Type">Type</a>) RelString(from *<a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Package">Package</a>) <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Type.String">func (*Type) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=58433:58463#L1628">String</a>
					<a class="permalink" href="#Type.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="#Type">Type</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="Type.Token">func (*Type) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=58285:58319#L1626">Token</a>
					<a class="permalink" href="#Type.Token">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="#Type">Type</a>) Token() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Token">Token</a></pre>
				
				
				
				
			
				
				<h3 id="Type.Type">func (*Type) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=58205:58237#L1625">Type</a>
					<a class="permalink" href="#Type.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (t *<a href="#Type">Type</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="TypeAssert">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=40736:40836#L1110">TypeAssert</a>
				<a class="permalink" href="#TypeAssert">&#xb6;</a>
				
				
			</h2>
			<p>The TypeAssert instruction tests whether interface value X has type
AssertedType.
<p>If !CommaOk, on success it returns v, the result of the conversion
(defined below); on failure it panics.
<p>If CommaOk: on success it returns a pair (v, true) where v is the
result of the conversion; on failure it returns (z, false) where z
is AssertedType&apos;s zero value.  The components of the pair must be
accessed using the Extract instruction.
<p>If Underlying: tests whether interface value X has the underlying
type AssertedType.
<p>If AssertedType is a concrete type, TypeAssert checks whether the
dynamic type in interface X is equal to it, and if so, the result
of the conversion is a copy of the value in the interface.
<p>If AssertedType is an interface, TypeAssert checks whether the
dynamic type of the interface is assignable to it, and if so, the
result of the conversion is a copy of the interface value X.
If AssertedType is a superinterface of X.Type(), the operation will
fail iff the operand is nil.  (Contrast with ChangeInterface, which
performs no nil-check.)
<p>Type() reflects the actual type of the result, possibly a
2-types.Tuple; AssertedType is the asserted type.
<p>Depending on the TypeAssert&apos;s purpose, Pos may return:
<ul>
<li>the ast.CallExpr.Lparen of an explicit T(e) conversion;
<li>the ast.TypeAssertExpr.Lparen of an explicit e.(T) operation;
<li>the ast.CaseClause.Case of a case of a type-switch statement;
<li>the Ident(m).NamePos of an interface method value i.m
(for which TypeAssert may be used to effect the nil check).
</ul>
<p>Example printed form:
<pre>t1 = typeassert t0.(int)
t3 = typeassert,ok t2.(T)
</pre>

			<pre>type TypeAssert struct {
<span id="TypeAssert.X"></span>    X            <a href="#Value">Value</a>
<span id="TypeAssert.AssertedType"></span>    AssertedType <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a>
<span id="TypeAssert.CommaOk"></span>    CommaOk      <a href="/pkg/builtin/#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="TypeAssert.Name">func (*TypeAssert) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#TypeAssert.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#TypeAssert">TypeAssert</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="TypeAssert.Operands">func (*TypeAssert) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=64365:64419#L1847">Operands</a>
					<a class="permalink" href="#TypeAssert.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#TypeAssert">TypeAssert</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="TypeAssert.Pos">func (*TypeAssert) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#TypeAssert.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#TypeAssert">TypeAssert</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="TypeAssert.Referrers">func (*TypeAssert) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#TypeAssert.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#TypeAssert">TypeAssert</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="TypeAssert.String">func (*TypeAssert) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=7240:7276#L289">String</a>
					<a class="permalink" href="#TypeAssert.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#TypeAssert">TypeAssert</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="TypeAssert.Type">func (*TypeAssert) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#TypeAssert.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#TypeAssert">TypeAssert</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="UnOp">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=24948:25072#L620">UnOp</a>
				<a class="permalink" href="#UnOp">&#xb6;</a>
				
				
			</h2>
			<p>The UnOp instruction yields the result of Op X.
ARROW is channel receive.
MUL is pointer indirection (load).
XOR is bitwise complement.
SUB is negation.
NOT is logical negation.
<p>If CommaOk and Op=ARROW, the result is a 2-tuple of the value above
and a boolean indicating the success of the receive.  The
components of the tuple are accessed using Extract.
<p>Pos() returns the ast.UnaryExpr.OpPos, if explicit in the source.
For receive operations (ARROW) implicit in ranging over a channel,
Pos() returns the ast.RangeStmt.For.
For implicit memory loads (STAR), Pos() returns the position of the
most closely associated source-level construct; the details are not
specified.
<p>Example printed form:
<pre>t0 = *x
t2 = &lt;-t1,ok
</pre>

			<pre>type UnOp struct {
<span id="UnOp.Op"></span>    Op      <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Token">Token</a> <span class="comment">// One of: NOT SUB ARROW MUL XOR ! - &lt;- * ^</span>
<span id="UnOp.X"></span>    X       <a href="#Value">Value</a>
<span id="UnOp.CommaOk"></span>    CommaOk <a href="/pkg/builtin/#bool">bool</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			

			
				
				<h3 id="UnOp.Name">func (*UnOp) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57416:57448#L1612">Name</a>
					<a class="permalink" href="#UnOp.Name">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#UnOp">UnOp</a>) Name() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="UnOp.Operands">func (*UnOp) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=64453:64501#L1851">Operands</a>
					<a class="permalink" href="#UnOp.Operands">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#UnOp">UnOp</a>) Operands(rands []*<a href="#Value">Value</a>) []*<a href="#Value">Value</a></pre>
				
				
				
				
			
				
				<h3 id="UnOp.Pos">func (*UnOp) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57631:57665#L1615">Pos</a>
					<a class="permalink" href="#UnOp.Pos">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#UnOp">UnOp</a>) Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a></pre>
				
				
				
				
			
				
				<h3 id="UnOp.Referrers">func (*UnOp) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57561:57606#L1614">Referrers</a>
					<a class="permalink" href="#UnOp.Referrers">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#UnOp">UnOp</a>) Referrers() *[]<a href="#Instruction">Instruction</a></pre>
				
				
				
				
			
				
				<h3 id="UnOp.String">func (*UnOp) <a href="/src/golang.org/x/tools/go/ssa/print.go?s=3866:3896#L156">String</a>
					<a class="permalink" href="#UnOp.String">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#UnOp">UnOp</a>) String() <a href="/pkg/builtin/#string">string</a></pre>
				
				
				
				
			
				
				<h3 id="UnOp.Type">func (*UnOp) <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=57291:57327#L1610">Type</a>
					<a class="permalink" href="#UnOp.Type">&#xb6;</a>
					
					
				</h3>
				<pre>func (v *<a href="#UnOp">UnOp</a>) Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a></pre>
				
				
				
				
			
		
			
			
			<h2 id="Value">type <a href="/src/golang.org/x/tools/go/ssa/ssa.go?s=4586:7015#L101">Value</a>
				<a class="permalink" href="#Value">&#xb6;</a>
				
				
			</h2>
			<p>A Value is an SSA value that can be referenced by an instruction.

			<pre>type Value interface {
    <span class="comment">// Name returns the name of this value, and determines how</span>
    <span class="comment">// this Value appears when used as an operand of an</span>
    <span class="comment">// Instruction.</span>
    <span class="comment">//</span>
    <span class="comment">// This is the same as the source name for Parameters,</span>
    <span class="comment">// Builtins, Functions, FreeVars, Globals.</span>
    <span class="comment">// For constants, it is a representation of the constant&#39;s value</span>
    <span class="comment">// and type.  For all other Values this is the name of the</span>
    <span class="comment">// virtual register defined by the instruction.</span>
    <span class="comment">//</span>
    <span class="comment">// The name of an SSA Value is not semantically significant,</span>
    <span class="comment">// and may not even be unique within a function.</span>
    Name() <a href="/pkg/builtin/#string">string</a>

    <span class="comment">// If this value is an Instruction, String returns its</span>
    <span class="comment">// disassembled form; otherwise it returns unspecified</span>
    <span class="comment">// human-readable information about the Value, such as its</span>
    <span class="comment">// kind, name and type.</span>
    String() <a href="/pkg/builtin/#string">string</a>

    <span class="comment">// Type returns the type of this value.  Many instructions</span>
    <span class="comment">// (e.g. IndexAddr) change their behaviour depending on the</span>
    <span class="comment">// types of their operands.</span>
    Type() <a href="/pkg/go/types/">types</a>.<a href="/pkg/go/types/#Type">Type</a>

    <span class="comment">// Parent returns the function to which this Value belongs.</span>
    <span class="comment">// It returns nil for named Functions, Builtin, Const and Global.</span>
    Parent() *<a href="#Function">Function</a>

    <span class="comment">// Referrers returns the list of instructions that have this</span>
    <span class="comment">// value as one of their operands; it may contain duplicates</span>
    <span class="comment">// if an instruction has a repeated operand.</span>
    <span class="comment">//</span>
    <span class="comment">// Referrers actually returns a pointer through which the</span>
    <span class="comment">// caller may perform mutations to the object&#39;s state.</span>
    <span class="comment">//</span>
    <span class="comment">// Referrers is currently only defined if Parent()!=nil,</span>
    <span class="comment">// i.e. for the function-local values FreeVar, Parameter,</span>
    <span class="comment">// Functions (iff anonymous) and all value-defining instructions.</span>
    <span class="comment">// It returns nil for named Functions, Builtin, Const and Global.</span>
    <span class="comment">//</span>
    <span class="comment">// Instruction.Operands contains the inverse of this relation.</span>
    Referrers() *[]<a href="#Instruction">Instruction</a>

    <span class="comment">// Pos returns the location of the AST token most closely</span>
    <span class="comment">// associated with the operation that gave rise to this value,</span>
    <span class="comment">// or token.NoPos if it was not explicit in the source.</span>
    <span class="comment">//</span>
    <span class="comment">// For each ast.Node type, a particular token is designated as</span>
    <span class="comment">// the closest location for the expression, e.g. the Lparen</span>
    <span class="comment">// for an *ast.CallExpr.  This permits a compact but</span>
    <span class="comment">// approximate mapping from Values to source positions for use</span>
    <span class="comment">// in diagnostic messages, for example.</span>
    <span class="comment">//</span>
    <span class="comment">// (Do not use this position to determine which Value</span>
    <span class="comment">// corresponds to an ast.Expr; use Function.ValueForExpr</span>
    <span class="comment">// instead.  NB: it requires that the function was built with</span>
    <span class="comment">// debug information.)</span>
    Pos() <a href="/pkg/go/token/">token</a>.<a href="/pkg/go/token/#Pos">Pos</a>
}</pre>

			

			

			
			
			

			

			
		
	

	





	
	
		<h2 id="pkg-subdirectories">Subdirectories</h2>
	
	<div class="pkg-dir">
		<table>
			<tr>
				<th class="pkg-name">Name</th>
				<th class="pkg-synopsis">Synopsis</th>
			</tr>

			
			<tr>
				<td colspan="2"><a href="..">..</a></td>
			</tr>
			

			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="interp/">interp</a>
					</td>
				
					<td class="pkg-synopsis">
						Package ssa/interp defines an interpreter for the SSA representation of Go programs.
					</td>
				</tr>
			
				<tr>
				
					<td class="pkg-name" style="padding-left: 0px;">
						<a href="ssautil/">ssautil</a>
					</td>
				
					<td class="pkg-synopsis">
						
					</td>
				</tr>
			
		</table>
	</div>



<div id="footer">
Build version go1.23.0.<br>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="/LICENSE">BSD license</a>.<br>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->
</body>
</html>
